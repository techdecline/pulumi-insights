export declare const AccessControlEntryAction: {
    readonly Permit: "Permit";
    readonly Deny: "Deny";
};
/**
 * Action object.
 */
export type AccessControlEntryAction = (typeof AccessControlEntryAction)[keyof typeof AccessControlEntryAction];
export declare const AutoHealActionType: {
    readonly Recycle: "Recycle";
    readonly LogEvent: "LogEvent";
    readonly CustomAction: "CustomAction";
};
/**
 * Predefined action to be taken.
 */
export type AutoHealActionType = (typeof AutoHealActionType)[keyof typeof AutoHealActionType];
export declare const AzureResourceType: {
    readonly Website: "Website";
    readonly TrafficManager: "TrafficManager";
};
/**
 * Azure resource type.
 */
export type AzureResourceType = (typeof AzureResourceType)[keyof typeof AzureResourceType];
export declare const AzureStorageType: {
    readonly AzureFiles: "AzureFiles";
    readonly AzureBlob: "AzureBlob";
};
/**
 * Type of storage.
 */
export type AzureStorageType = (typeof AzureStorageType)[keyof typeof AzureStorageType];
export declare const BuiltInAuthenticationProvider: {
    readonly AzureActiveDirectory: "AzureActiveDirectory";
    readonly Facebook: "Facebook";
    readonly Google: "Google";
    readonly MicrosoftAccount: "MicrosoftAccount";
    readonly Twitter: "Twitter";
    readonly Github: "Github";
};
/**
 * The default authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the unauthenticated client
 * action is set to "RedirectToLoginPage".
 */
export type BuiltInAuthenticationProvider = (typeof BuiltInAuthenticationProvider)[keyof typeof BuiltInAuthenticationProvider];
export declare const ClientCertMode: {
    readonly Required: "Required";
    readonly Optional: "Optional";
};
/**
 * This composes with ClientCertEnabled setting.
 * - ClientCertEnabled: false means ClientCert is ignored.
 * - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
 * - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
 */
export type ClientCertMode = (typeof ClientCertMode)[keyof typeof ClientCertMode];
export declare const ClientCredentialMethod: {
    readonly ClientSecretPost: "ClientSecretPost";
};
export type ClientCredentialMethod = (typeof ClientCredentialMethod)[keyof typeof ClientCredentialMethod];
export declare const ComputeModeOptions: {
    readonly Shared: "Shared";
    readonly Dedicated: "Dedicated";
    readonly Dynamic: "Dynamic";
};
/**
 * Shared or dedicated app hosting.
 */
export type ComputeModeOptions = (typeof ComputeModeOptions)[keyof typeof ComputeModeOptions];
export declare const ConnectionStringType: {
    readonly MySql: "MySql";
    readonly SQLServer: "SQLServer";
    readonly SQLAzure: "SQLAzure";
    readonly Custom: "Custom";
    readonly NotificationHub: "NotificationHub";
    readonly ServiceBus: "ServiceBus";
    readonly EventHub: "EventHub";
    readonly ApiHub: "ApiHub";
    readonly DocDb: "DocDb";
    readonly RedisCache: "RedisCache";
    readonly PostgreSQL: "PostgreSQL";
};
/**
 * Type of database.
 */
export type ConnectionStringType = (typeof ConnectionStringType)[keyof typeof ConnectionStringType];
export declare const CookieExpirationConvention: {
    readonly FixedTime: "FixedTime";
    readonly IdentityProviderDerived: "IdentityProviderDerived";
};
export type CookieExpirationConvention = (typeof CookieExpirationConvention)[keyof typeof CookieExpirationConvention];
export declare const CustomHostNameDnsRecordType: {
    readonly CName: "CName";
    readonly A: "A";
};
/**
 * Custom DNS record type.
 */
export type CustomHostNameDnsRecordType = (typeof CustomHostNameDnsRecordType)[keyof typeof CustomHostNameDnsRecordType];
export declare const DatabaseType: {
    readonly SqlAzure: "SqlAzure";
    readonly MySql: "MySql";
    readonly LocalMySql: "LocalMySql";
    readonly PostgreSql: "PostgreSql";
};
/**
 * Database type (e.g. SqlAzure / MySql).
 */
export type DatabaseType = (typeof DatabaseType)[keyof typeof DatabaseType];
export declare const ForwardProxyConvention: {
    readonly NoProxy: "NoProxy";
    readonly Standard: "Standard";
    readonly Custom: "Custom";
};
export type ForwardProxyConvention = (typeof ForwardProxyConvention)[keyof typeof ForwardProxyConvention];
export declare const FrequencyUnit: {
    readonly Day: "Day";
    readonly Hour: "Hour";
};
/**
 * The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
 */
export type FrequencyUnit = (typeof FrequencyUnit)[keyof typeof FrequencyUnit];
export declare const FtpsState: {
    readonly AllAllowed: "AllAllowed";
    readonly FtpsOnly: "FtpsOnly";
    readonly Disabled: "Disabled";
};
/**
 * State of FTP / FTPS service
 */
export type FtpsState = (typeof FtpsState)[keyof typeof FtpsState];
export declare const HostNameType: {
    readonly Verified: "Verified";
    readonly Managed: "Managed";
};
/**
 * Hostname type.
 */
export type HostNameType = (typeof HostNameType)[keyof typeof HostNameType];
export declare const HostType: {
    readonly Standard: "Standard";
    readonly Repository: "Repository";
};
/**
 * Indicates whether the hostname is a standard or repository hostname.
 */
export type HostType = (typeof HostType)[keyof typeof HostType];
export declare const IpFilterTag: {
    readonly Default: "Default";
    readonly XffProxy: "XffProxy";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
 */
export type IpFilterTag = (typeof IpFilterTag)[keyof typeof IpFilterTag];
export declare const LoadBalancingMode: {
    readonly None: "None";
    readonly Web: "Web";
    readonly Publishing: "Publishing";
    readonly Web_Publishing: "Web,Publishing";
};
/**
 * Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment.
 */
export type LoadBalancingMode = (typeof LoadBalancingMode)[keyof typeof LoadBalancingMode];
export declare const LogLevel: {
    readonly Off: "Off";
    readonly Verbose: "Verbose";
    readonly Information: "Information";
    readonly Warning: "Warning";
    readonly Error: "Error";
};
/**
 * Log level.
 */
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
export declare const ManagedPipelineMode: {
    readonly Integrated: "Integrated";
    readonly Classic: "Classic";
};
/**
 * Managed pipeline mode.
 */
export type ManagedPipelineMode = (typeof ManagedPipelineMode)[keyof typeof ManagedPipelineMode];
export declare const ManagedServiceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * Type of managed service identity.
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const PublicCertificateLocation: {
    readonly CurrentUserMy: "CurrentUserMy";
    readonly LocalMachineMy: "LocalMachineMy";
    readonly Unknown: "Unknown";
};
/**
 * Public Certificate Location
 */
export type PublicCertificateLocation = (typeof PublicCertificateLocation)[keyof typeof PublicCertificateLocation];
export declare const RedundancyMode: {
    readonly None: "None";
    readonly Manual: "Manual";
    readonly Failover: "Failover";
    readonly ActiveActive: "ActiveActive";
    readonly GeoRedundant: "GeoRedundant";
};
/**
 * Site redundancy mode
 */
export type RedundancyMode = (typeof RedundancyMode)[keyof typeof RedundancyMode];
export declare const RouteType: {
    readonly DEFAULT: "DEFAULT";
    readonly INHERITED: "INHERITED";
    readonly STATIC: "STATIC";
};
/**
 * The type of route this is:
 * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
 * INHERITED - Routes inherited from the real Virtual Network routes
 * STATIC - Static route set on the app only
 *
 * These values will be used for syncing an app's routes with those from a Virtual Network.
 */
export type RouteType = (typeof RouteType)[keyof typeof RouteType];
export declare const ScmType: {
    readonly None: "None";
    readonly Dropbox: "Dropbox";
    readonly Tfs: "Tfs";
    readonly LocalGit: "LocalGit";
    readonly GitHub: "GitHub";
    readonly CodePlexGit: "CodePlexGit";
    readonly CodePlexHg: "CodePlexHg";
    readonly BitbucketGit: "BitbucketGit";
    readonly BitbucketHg: "BitbucketHg";
    readonly ExternalGit: "ExternalGit";
    readonly ExternalHg: "ExternalHg";
    readonly OneDrive: "OneDrive";
    readonly VSO: "VSO";
    readonly VSTSRM: "VSTSRM";
};
/**
 * SCM type.
 */
export type ScmType = (typeof ScmType)[keyof typeof ScmType];
export declare const SiteLoadBalancing: {
    readonly WeightedRoundRobin: "WeightedRoundRobin";
    readonly LeastRequests: "LeastRequests";
    readonly LeastResponseTime: "LeastResponseTime";
    readonly WeightedTotalTraffic: "WeightedTotalTraffic";
    readonly RequestHash: "RequestHash";
};
/**
 * Site load balancing.
 */
export type SiteLoadBalancing = (typeof SiteLoadBalancing)[keyof typeof SiteLoadBalancing];
export declare const SslState: {
    readonly Disabled: "Disabled";
    readonly SniEnabled: "SniEnabled";
    readonly IpBasedEnabled: "IpBasedEnabled";
};
/**
 * SSL type.
 */
export type SslState = (typeof SslState)[keyof typeof SslState];
export declare const SupportedTlsVersions: {
    readonly SupportedTlsVersions_1_0: "1.0";
    readonly SupportedTlsVersions_1_1: "1.1";
    readonly SupportedTlsVersions_1_2: "1.2";
};
/**
 * ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
 */
export type SupportedTlsVersions = (typeof SupportedTlsVersions)[keyof typeof SupportedTlsVersions];
export declare const UnauthenticatedClientAction: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientAction = (typeof UnauthenticatedClientAction)[keyof typeof UnauthenticatedClientAction];
export declare const UnauthenticatedClientActionV2: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
    readonly Return401: "Return401";
    readonly Return403: "Return403";
};
export type UnauthenticatedClientActionV2 = (typeof UnauthenticatedClientActionV2)[keyof typeof UnauthenticatedClientActionV2];
