export declare const AuthenticationMethod: {
    /**
     * SystemAssignedManagedIdentity Option
     */
    readonly SystemAssignedManagedIdentity: "SystemAssignedManagedIdentity";
    /**
     * UserAssignedManagedIdentity Option
     */
    readonly UserAssignedManagedIdentity: "UserAssignedManagedIdentity";
    /**
     * AccessToken Option
     */
    readonly AccessToken: "AccessToken";
    /**
     * Sasl Option
     */
    readonly Sasl: "Sasl";
    /**
     * X509Credentials Option
     */
    readonly X509Credentials: "X509Credentials";
};
/**
 * Mode of Authentication.
 */
export type AuthenticationMethod = (typeof AuthenticationMethod)[keyof typeof AuthenticationMethod];
export declare const BrokerAuthenticationMethod: {
    /**
     * Custom authentication configuration.
     */
    readonly Custom: "Custom";
    /**
     * ServiceAccountToken authentication configuration.
     */
    readonly ServiceAccountToken: "ServiceAccountToken";
    /**
     * X.509 authentication configuration.
     */
    readonly X509Credentials: "X509Credentials";
};
/**
 * Custom authentication configuration.
 */
export type BrokerAuthenticationMethod = (typeof BrokerAuthenticationMethod)[keyof typeof BrokerAuthenticationMethod];
export declare const BrokerMemoryProfile: {
    /**
     * Tiny memory profile.
     */
    readonly Tiny: "Tiny";
    /**
     * Low memory profile.
     */
    readonly Low: "Low";
    /**
     * Medium memory profile.
     */
    readonly Medium: "Medium";
    /**
     * High memory profile.
     */
    readonly High: "High";
};
/**
 * Memory profile of Broker.
 */
export type BrokerMemoryProfile = (typeof BrokerMemoryProfile)[keyof typeof BrokerMemoryProfile];
export declare const BrokerProtocolType: {
    /**
     * protocol broker
     */
    readonly Mqtt: "Mqtt";
    /**
     * protocol websocket
     */
    readonly WebSockets: "WebSockets";
};
/**
 * Enable or disable websockets.
 */
export type BrokerProtocolType = (typeof BrokerProtocolType)[keyof typeof BrokerProtocolType];
export declare const BrokerResourceDefinitionMethods: {
    /**
     * Allowed Connecting to Broker
     */
    readonly Connect: "Connect";
    /**
     * Allowed Publishing to Broker
     */
    readonly Publish: "Publish";
    /**
     * Allowed Subscribing to Broker
     */
    readonly Subscribe: "Subscribe";
};
/**
 * Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
 */
export type BrokerResourceDefinitionMethods = (typeof BrokerResourceDefinitionMethods)[keyof typeof BrokerResourceDefinitionMethods];
export declare const CertManagerIssuerKind: {
    /**
     * Issuer kind.
     */
    readonly Issuer: "Issuer";
    /**
     * ClusterIssuer kind.
     */
    readonly ClusterIssuer: "ClusterIssuer";
};
/**
 * kind of issuer (Issuer or ClusterIssuer).
 */
export type CertManagerIssuerKind = (typeof CertManagerIssuerKind)[keyof typeof CertManagerIssuerKind];
export declare const DataFlowEndpointAuthenticationSaslType: {
    /**
     * PLAIN Type
     */
    readonly Plain: "Plain";
    /**
     * SCRAM_SHA_256 Type
     */
    readonly ScramSha256: "ScramSha256";
    /**
     * SCRAM_SHA_512 Type
     */
    readonly ScramSha512: "ScramSha512";
};
/**
 * Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
 */
export type DataFlowEndpointAuthenticationSaslType = (typeof DataFlowEndpointAuthenticationSaslType)[keyof typeof DataFlowEndpointAuthenticationSaslType];
export declare const DataFlowEndpointFabricPathType: {
    /**
     * FILES Type
     */
    readonly Files: "Files";
    /**
     * TABLES Type
     */
    readonly Tables: "Tables";
};
/**
 * Type of location of the data in the workspace. Can be either tables or files.
 */
export type DataFlowEndpointFabricPathType = (typeof DataFlowEndpointFabricPathType)[keyof typeof DataFlowEndpointFabricPathType];
export declare const DataFlowEndpointKafkaAcks: {
    /**
     * ZERO Option
     */
    readonly Zero: "Zero";
    /**
     * ONE Option
     */
    readonly One: "One";
    /**
     * ALL Option
     */
    readonly All: "All";
};
/**
 * Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
 */
export type DataFlowEndpointKafkaAcks = (typeof DataFlowEndpointKafkaAcks)[keyof typeof DataFlowEndpointKafkaAcks];
export declare const DataFlowEndpointKafkaCompression: {
    /**
     * NONE Option
     */
    readonly None: "None";
    /**
     * Gzip Option
     */
    readonly Gzip: "Gzip";
    /**
     * SNAPPY Option
     */
    readonly Snappy: "Snappy";
    /**
     * LZ4 Option
     */
    readonly Lz4: "Lz4";
};
/**
 * Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
 */
export type DataFlowEndpointKafkaCompression = (typeof DataFlowEndpointKafkaCompression)[keyof typeof DataFlowEndpointKafkaCompression];
export declare const DataFlowEndpointKafkaPartitionStrategy: {
    /**
     * Default: Assigns messages to random partitions, using a round-robin algorithm.
     */
    readonly Default: "Default";
    /**
     * Static: Assigns messages to a fixed partition number that's derived from the instance ID of the dataflow.
     */
    readonly Static: "Static";
    /**
     * TOPIC Option
     */
    readonly Topic: "Topic";
    /**
     * PROPERTY Option
     */
    readonly Property: "Property";
};
/**
 * Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
 */
export type DataFlowEndpointKafkaPartitionStrategy = (typeof DataFlowEndpointKafkaPartitionStrategy)[keyof typeof DataFlowEndpointKafkaPartitionStrategy];
export declare const DataFlowMappingType: {
    /**
     * New Properties type
     */
    readonly NewProperties: "NewProperties";
    /**
     * Rename type
     */
    readonly Rename: "Rename";
    /**
     * Compute type
     */
    readonly Compute: "Compute";
    /**
     * Pass-through type
     */
    readonly PassThrough: "PassThrough";
    /**
     * Built in function type
     */
    readonly BuiltInFunction: "BuiltInFunction";
};
/**
 * Type of transformation.
 */
export type DataFlowMappingType = (typeof DataFlowMappingType)[keyof typeof DataFlowMappingType];
export declare const EndpointType: {
    /**
     * Azure Data Explorer Type
     */
    readonly DataExplorer: "DataExplorer";
    /**
     * Azure Data Lake Type
     */
    readonly DataLakeStorage: "DataLakeStorage";
    /**
     * Microsoft Fabric Type
     */
    readonly FabricOneLake: "FabricOneLake";
    /**
     * Kafka Type
     */
    readonly Kafka: "Kafka";
    /**
     * Local Storage Type
     */
    readonly LocalStorage: "LocalStorage";
    /**
     * Broker Type
     */
    readonly Mqtt: "Mqtt";
};
/**
 * Endpoint Type.
 */
export type EndpointType = (typeof EndpointType)[keyof typeof EndpointType];
export declare const ExtendedLocationType: {
    /**
     * CustomLocation type
     */
    readonly CustomLocation: "CustomLocation";
};
/**
 * Type of ExtendedLocation.
 */
export type ExtendedLocationType = (typeof ExtendedLocationType)[keyof typeof ExtendedLocationType];
export declare const FilterType: {
    /**
     * Filter type
     */
    readonly Filter: "Filter";
};
/**
 * The type of dataflow operation.
 */
export type FilterType = (typeof FilterType)[keyof typeof FilterType];
export declare const MqttRetainType: {
    /**
     * Retain the messages.
     */
    readonly Keep: "Keep";
    /**
     * Never retain messages.
     */
    readonly Never: "Never";
};
/**
 * Whether or not to keep the retain setting.
 */
export type MqttRetainType = (typeof MqttRetainType)[keyof typeof MqttRetainType];
export declare const OperationType: {
    /**
     * DataFlow Source Operation
     */
    readonly Source: "Source";
    /**
     * DataFlow Destination Operation
     */
    readonly Destination: "Destination";
    /**
     * DataFlow BuiltIn Transformation Operation
     */
    readonly BuiltInTransformation: "BuiltInTransformation";
};
/**
 * Type of operation.
 */
export type OperationType = (typeof OperationType)[keyof typeof OperationType];
export declare const OperationalMode: {
    /**
     * Enabled is equivalent to True
     */
    readonly Enabled: "Enabled";
    /**
     * Disabled is equivalent to False.
     */
    readonly Disabled: "Disabled";
};
/**
 * Mode for TLS.
 */
export type OperationalMode = (typeof OperationalMode)[keyof typeof OperationalMode];
export declare const OperatorValues: {
    /**
     * In operator.
     */
    readonly In: "In";
    /**
     * NotIn operator.
     */
    readonly NotIn: "NotIn";
    /**
     * Exists operator.
     */
    readonly Exists: "Exists";
    /**
     * DoesNotExist operator.
     */
    readonly DoesNotExist: "DoesNotExist";
};
/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 */
export type OperatorValues = (typeof OperatorValues)[keyof typeof OperatorValues];
export declare const PrivateKeyAlgorithm: {
    /**
     * Algorithm - ec256.
     */
    readonly Ec256: "Ec256";
    /**
     * Algorithm - ec384.
     */
    readonly Ec384: "Ec384";
    /**
     * Algorithm - ec521.
     */
    readonly Ec521: "Ec521";
    /**
     * Algorithm - ed25519.
     */
    readonly Ed25519: "Ed25519";
    /**
     * Algorithm - rsa2048.
     */
    readonly Rsa2048: "Rsa2048";
    /**
     * Algorithm - rsa4096.
     */
    readonly Rsa4096: "Rsa4096";
    /**
     * Algorithm - rsa8192.
     */
    readonly Rsa8192: "Rsa8192";
};
/**
 * algorithm for private key.
 */
export type PrivateKeyAlgorithm = (typeof PrivateKeyAlgorithm)[keyof typeof PrivateKeyAlgorithm];
export declare const PrivateKeyRotationPolicy: {
    /**
     * Rotation Policy - Always.
     */
    readonly Always: "Always";
    /**
     * Rotation Policy - Never.
     */
    readonly Never: "Never";
};
/**
 * cert-manager private key rotationPolicy.
 */
export type PrivateKeyRotationPolicy = (typeof PrivateKeyRotationPolicy)[keyof typeof PrivateKeyRotationPolicy];
export declare const ServiceType: {
    /**
     * Cluster IP Service.
     */
    readonly ClusterIp: "ClusterIp";
    /**
     * Load Balancer Service.
     */
    readonly LoadBalancer: "LoadBalancer";
    /**
     * Node Port Service.
     */
    readonly NodePort: "NodePort";
};
/**
 * Kubernetes Service type of this listener.
 */
export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType];
export declare const SourceSerializationFormat: {
    /**
     * JSON Format
     */
    readonly Json: "Json";
};
/**
 * Content is a JSON Schema. Allowed: JSON Schema/draft-7.
 */
export type SourceSerializationFormat = (typeof SourceSerializationFormat)[keyof typeof SourceSerializationFormat];
export declare const StateStoreResourceDefinitionMethods: {
    /**
     * Get/KeyNotify from Store
     */
    readonly Read: "Read";
    /**
     * Set/Delete in Store
     */
    readonly Write: "Write";
    /**
     * Allowed all operations on Store - Get/KeyNotify/Set/Delete
     */
    readonly ReadWrite: "ReadWrite";
};
/**
 * Give access for `Read`, `Write` and `ReadWrite` access level.
 */
export type StateStoreResourceDefinitionMethods = (typeof StateStoreResourceDefinitionMethods)[keyof typeof StateStoreResourceDefinitionMethods];
export declare const StateStoreResourceKeyTypes: {
    /**
     * Key type - pattern
     */
    readonly Pattern: "Pattern";
    /**
     * Key type - string
     */
    readonly String: "String";
    /**
     * Key type - binary
     */
    readonly Binary: "Binary";
};
/**
 * Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
 */
export type StateStoreResourceKeyTypes = (typeof StateStoreResourceKeyTypes)[keyof typeof StateStoreResourceKeyTypes];
export declare const SubscriberMessageDropStrategy: {
    /**
     * Messages are never dropped.
     */
    readonly None: "None";
    /**
     * The oldest message is dropped.
     */
    readonly DropOldest: "DropOldest";
};
/**
 * The strategy to use for dropping messages from the queue.
 */
export type SubscriberMessageDropStrategy = (typeof SubscriberMessageDropStrategy)[keyof typeof SubscriberMessageDropStrategy];
export declare const TlsCertMethodMode: {
    /**
     * Automatic TLS server certificate configuration.
     */
    readonly Automatic: "Automatic";
    /**
     * Manual TLS server certificate configuration.
     */
    readonly Manual: "Manual";
};
/**
 * Mode of TLS server certificate management.
 */
export type TlsCertMethodMode = (typeof TlsCertMethodMode)[keyof typeof TlsCertMethodMode];
export declare const TransformationSerializationFormat: {
    /**
     * Delta Format
     */
    readonly Delta: "Delta";
    /**
     * JSON Format
     */
    readonly Json: "Json";
    /**
     * Parquet Format
     */
    readonly Parquet: "Parquet";
};
/**
 * Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
 */
export type TransformationSerializationFormat = (typeof TransformationSerializationFormat)[keyof typeof TransformationSerializationFormat];
