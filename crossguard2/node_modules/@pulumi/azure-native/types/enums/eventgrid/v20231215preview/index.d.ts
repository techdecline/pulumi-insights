export declare const AdvancedFilterOperatorType: {
    readonly NumberIn: "NumberIn";
    readonly NumberNotIn: "NumberNotIn";
    readonly NumberLessThan: "NumberLessThan";
    readonly NumberGreaterThan: "NumberGreaterThan";
    readonly NumberLessThanOrEquals: "NumberLessThanOrEquals";
    readonly NumberGreaterThanOrEquals: "NumberGreaterThanOrEquals";
    readonly BoolEquals: "BoolEquals";
    readonly StringIn: "StringIn";
    readonly StringNotIn: "StringNotIn";
    readonly StringBeginsWith: "StringBeginsWith";
    readonly StringEndsWith: "StringEndsWith";
    readonly StringContains: "StringContains";
    readonly NumberInRange: "NumberInRange";
    readonly NumberNotInRange: "NumberNotInRange";
    readonly StringNotBeginsWith: "StringNotBeginsWith";
    readonly StringNotEndsWith: "StringNotEndsWith";
    readonly StringNotContains: "StringNotContains";
    readonly IsNullOrUndefined: "IsNullOrUndefined";
    readonly IsNotNull: "IsNotNull";
};
/**
 * The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
 */
export type AdvancedFilterOperatorType = (typeof AdvancedFilterOperatorType)[keyof typeof AdvancedFilterOperatorType];
export declare const AlternativeAuthenticationNameSource: {
    readonly ClientCertificateSubject: "ClientCertificateSubject";
    readonly ClientCertificateDns: "ClientCertificateDns";
    readonly ClientCertificateUri: "ClientCertificateUri";
    readonly ClientCertificateIp: "ClientCertificateIp";
    readonly ClientCertificateEmail: "ClientCertificateEmail";
};
export type AlternativeAuthenticationNameSource = (typeof AlternativeAuthenticationNameSource)[keyof typeof AlternativeAuthenticationNameSource];
export declare const ChannelProvisioningState: {
    readonly Creating: "Creating";
    readonly Updating: "Updating";
    readonly Deleting: "Deleting";
    readonly Succeeded: "Succeeded";
    readonly Canceled: "Canceled";
    readonly Failed: "Failed";
    readonly IdleDueToMirroredPartnerTopicDeletion: "IdleDueToMirroredPartnerTopicDeletion";
    readonly IdleDueToMirroredPartnerDestinationDeletion: "IdleDueToMirroredPartnerDestinationDeletion";
};
/**
 * Provisioning state of the channel.
 */
export type ChannelProvisioningState = (typeof ChannelProvisioningState)[keyof typeof ChannelProvisioningState];
export declare const ChannelType: {
    readonly PartnerTopic: "PartnerTopic";
    readonly PartnerDestination: "PartnerDestination";
};
/**
 * The type of the event channel which represents the direction flow of events.
 */
export type ChannelType = (typeof ChannelType)[keyof typeof ChannelType];
export declare const ClientCertificateValidationScheme: {
    readonly SubjectMatchesAuthenticationName: "SubjectMatchesAuthenticationName";
    readonly DnsMatchesAuthenticationName: "DnsMatchesAuthenticationName";
    readonly UriMatchesAuthenticationName: "UriMatchesAuthenticationName";
    readonly IpMatchesAuthenticationName: "IpMatchesAuthenticationName";
    readonly EmailMatchesAuthenticationName: "EmailMatchesAuthenticationName";
    readonly ThumbprintMatch: "ThumbprintMatch";
};
/**
 * The validation scheme used to authenticate the client. Default value is SubjectMatchesAuthenticationName.
 */
export type ClientCertificateValidationScheme = (typeof ClientCertificateValidationScheme)[keyof typeof ClientCertificateValidationScheme];
export declare const ClientState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Indicates if the client is enabled or not. Default value is Enabled.
 */
export type ClientState = (typeof ClientState)[keyof typeof ClientState];
export declare const DataResidencyBoundary: {
    readonly WithinGeopair: "WithinGeopair";
    readonly WithinRegion: "WithinRegion";
};
/**
 * Data Residency Boundary of the resource.
 */
export type DataResidencyBoundary = (typeof DataResidencyBoundary)[keyof typeof DataResidencyBoundary];
export declare const DeadLetterEndPointType: {
    readonly StorageBlob: "StorageBlob";
};
/**
 * Type of the endpoint for the dead letter destination
 */
export type DeadLetterEndPointType = (typeof DeadLetterEndPointType)[keyof typeof DeadLetterEndPointType];
export declare const DeliveryAttributeMappingType: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * Type of the delivery attribute or header name.
 */
export type DeliveryAttributeMappingType = (typeof DeliveryAttributeMappingType)[keyof typeof DeliveryAttributeMappingType];
export declare const DeliveryMode: {
    readonly Queue: "Queue";
    readonly Push: "Push";
};
/**
 * Delivery mode of the event subscription.
 */
export type DeliveryMode = (typeof DeliveryMode)[keyof typeof DeliveryMode];
export declare const DeliverySchema: {
    readonly CloudEventSchemaV1_0: "CloudEventSchemaV1_0";
};
/**
 * The event delivery schema for the event subscription.
 */
export type DeliverySchema = (typeof DeliverySchema)[keyof typeof DeliverySchema];
export declare const EndpointType: {
    readonly WebHook: "WebHook";
    readonly EventHub: "EventHub";
    readonly StorageQueue: "StorageQueue";
    readonly HybridConnection: "HybridConnection";
    readonly ServiceBusQueue: "ServiceBusQueue";
    readonly ServiceBusTopic: "ServiceBusTopic";
    readonly AzureFunction: "AzureFunction";
    readonly PartnerDestination: "PartnerDestination";
    readonly MonitorAlert: "MonitorAlert";
    readonly NamespaceTopic: "NamespaceTopic";
};
/**
 * Type of the endpoint for the event subscription destination.
 */
export type EndpointType = (typeof EndpointType)[keyof typeof EndpointType];
export declare const EventDefinitionKind: {
    readonly Inline: "Inline";
};
/**
 * The kind of event type used.
 */
export type EventDefinitionKind = (typeof EventDefinitionKind)[keyof typeof EventDefinitionKind];
export declare const EventDeliverySchema: {
    readonly EventGridSchema: "EventGridSchema";
    readonly CustomInputSchema: "CustomInputSchema";
    readonly CloudEventSchemaV1_0: "CloudEventSchemaV1_0";
};
/**
 * The event delivery schema for the event subscription.
 */
export type EventDeliverySchema = (typeof EventDeliverySchema)[keyof typeof EventDeliverySchema];
export declare const EventInputSchema: {
    readonly CloudEventSchemaV1_0: "CloudEventSchemaV1_0";
};
/**
 * This determines the format that is expected for incoming events published to the topic.
 */
export type EventInputSchema = (typeof EventInputSchema)[keyof typeof EventInputSchema];
export declare const EventSubscriptionIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
};
/**
 * The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
 */
export type EventSubscriptionIdentityType = (typeof EventSubscriptionIdentityType)[keyof typeof EventSubscriptionIdentityType];
export declare const FilterOperatorType: {
    readonly NumberIn: "NumberIn";
    readonly NumberNotIn: "NumberNotIn";
    readonly NumberLessThan: "NumberLessThan";
    readonly NumberGreaterThan: "NumberGreaterThan";
    readonly NumberLessThanOrEquals: "NumberLessThanOrEquals";
    readonly NumberGreaterThanOrEquals: "NumberGreaterThanOrEquals";
    readonly BoolEquals: "BoolEquals";
    readonly StringIn: "StringIn";
    readonly StringNotIn: "StringNotIn";
    readonly StringBeginsWith: "StringBeginsWith";
    readonly StringEndsWith: "StringEndsWith";
    readonly StringContains: "StringContains";
    readonly NumberInRange: "NumberInRange";
    readonly NumberNotInRange: "NumberNotInRange";
    readonly StringNotBeginsWith: "StringNotBeginsWith";
    readonly StringNotEndsWith: "StringNotEndsWith";
    readonly StringNotContains: "StringNotContains";
    readonly IsNullOrUndefined: "IsNullOrUndefined";
    readonly IsNotNull: "IsNotNull";
};
/**
 * The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
 */
export type FilterOperatorType = (typeof FilterOperatorType)[keyof typeof FilterOperatorType];
export declare const IdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
};
/**
 * The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
 */
export type IdentityType = (typeof IdentityType)[keyof typeof IdentityType];
export declare const InputSchema: {
    readonly EventGridSchema: "EventGridSchema";
    readonly CustomEventSchema: "CustomEventSchema";
    readonly CloudEventSchemaV1_0: "CloudEventSchemaV1_0";
};
/**
 * This determines the format that Event Grid should expect for incoming events published to the topic.
 */
export type InputSchema = (typeof InputSchema)[keyof typeof InputSchema];
export declare const InputSchemaMappingType: {
    readonly Json: "Json";
};
/**
 * Type of the custom mapping
 */
export type InputSchemaMappingType = (typeof InputSchemaMappingType)[keyof typeof InputSchemaMappingType];
export declare const IpActionType: {
    readonly Allow: "Allow";
};
/**
 * Action to perform based on the match or no match of the IpMask.
 */
export type IpActionType = (typeof IpActionType)[keyof typeof IpActionType];
export declare const MonitorAlertSeverity: {
    readonly Sev0: "Sev0";
    readonly Sev1: "Sev1";
    readonly Sev2: "Sev2";
    readonly Sev3: "Sev3";
    readonly Sev4: "Sev4";
};
/**
 * The severity that will be attached to every Alert fired through this event subscription.
 * This field must be provided.
 */
export type MonitorAlertSeverity = (typeof MonitorAlertSeverity)[keyof typeof MonitorAlertSeverity];
export declare const PartnerClientAuthenticationType: {
    readonly AzureAD: "AzureAD";
};
/**
 * Type of client authentication
 */
export type PartnerClientAuthenticationType = (typeof PartnerClientAuthenticationType)[keyof typeof PartnerClientAuthenticationType];
export declare const PartnerConfigurationProvisioningState: {
    readonly Creating: "Creating";
    readonly Updating: "Updating";
    readonly Deleting: "Deleting";
    readonly Succeeded: "Succeeded";
    readonly Canceled: "Canceled";
    readonly Failed: "Failed";
};
/**
 * Provisioning state of the partner configuration.
 */
export type PartnerConfigurationProvisioningState = (typeof PartnerConfigurationProvisioningState)[keyof typeof PartnerConfigurationProvisioningState];
export declare const PartnerDestinationActivationState: {
    readonly NeverActivated: "NeverActivated";
    readonly Activated: "Activated";
};
/**
 * Activation state of the partner destination.
 */
export type PartnerDestinationActivationState = (typeof PartnerDestinationActivationState)[keyof typeof PartnerDestinationActivationState];
export declare const PartnerEndpointType: {
    readonly WebHook: "WebHook";
};
/**
 * Type of the endpoint for the partner destination
 */
export type PartnerEndpointType = (typeof PartnerEndpointType)[keyof typeof PartnerEndpointType];
export declare const PartnerTopicActivationState: {
    readonly NeverActivated: "NeverActivated";
    readonly Activated: "Activated";
    readonly Deactivated: "Deactivated";
};
/**
 * Activation state of the partner topic.
 */
export type PartnerTopicActivationState = (typeof PartnerTopicActivationState)[keyof typeof PartnerTopicActivationState];
export declare const PartnerTopicRoutingMode: {
    readonly SourceEventAttribute: "SourceEventAttribute";
    readonly ChannelNameHeader: "ChannelNameHeader";
};
/**
 * This determines if events published to this partner namespace should use the source attribute in the event payload
 * or use the channel name in the header when matching to the partner topic. If none is specified, source attribute routing will be used to match the partner topic.
 */
export type PartnerTopicRoutingMode = (typeof PartnerTopicRoutingMode)[keyof typeof PartnerTopicRoutingMode];
export declare const PermissionType: {
    readonly Publisher: "Publisher";
    readonly Subscriber: "Subscriber";
};
/**
 * The allowed permission.
 */
export type PermissionType = (typeof PermissionType)[keyof typeof PermissionType];
export declare const PersistedConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
};
/**
 * Status of the connection.
 */
export type PersistedConnectionStatus = (typeof PersistedConnectionStatus)[keyof typeof PersistedConnectionStatus];
export declare const PublicNetworkAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
    readonly SecuredByPerimeter: "SecuredByPerimeter";
};
/**
 * This determines if traffic is allowed over public network. By default it is enabled.
 * You can further restrict to specific IPs by configuring <seealso cref="P:Microsoft.Azure.Events.ResourceProvider.Common.Contracts.TopicProperties.InboundIpRules" />
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const PublisherType: {
    readonly Custom: "Custom";
};
/**
 * Publisher type of the namespace topic.
 */
export type PublisherType = (typeof PublisherType)[keyof typeof PublisherType];
export declare const ReadinessState: {
    readonly NeverActivated: "NeverActivated";
    readonly Activated: "Activated";
};
/**
 * The readiness state of the corresponding partner topic.
 */
export type ReadinessState = (typeof ReadinessState)[keyof typeof ReadinessState];
export declare const ResourceKind: {
    readonly Azure: "Azure";
    readonly AzureArc: "AzureArc";
};
/**
 * Kind of the resource.
 */
export type ResourceKind = (typeof ResourceKind)[keyof typeof ResourceKind];
export declare const ResourceProvisioningState: {
    readonly Creating: "Creating";
    readonly Updating: "Updating";
    readonly Deleting: "Deleting";
    readonly Succeeded: "Succeeded";
    readonly Canceled: "Canceled";
    readonly Failed: "Failed";
};
/**
 * Provisioning state of the Private Endpoint Connection.
 */
export type ResourceProvisioningState = (typeof ResourceProvisioningState)[keyof typeof ResourceProvisioningState];
export declare const RoutingIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
};
export type RoutingIdentityType = (typeof RoutingIdentityType)[keyof typeof RoutingIdentityType];
export declare const Sku: {
    readonly Basic: "Basic";
    readonly Premium: "Premium";
};
/**
 * The Sku name of the resource. The possible values are: Basic or Premium.
 */
export type Sku = (typeof Sku)[keyof typeof Sku];
export declare const SkuName: {
    readonly Standard: "Standard";
};
/**
 * The name of the SKU.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const StaticRoutingEnrichmentType: {
    readonly String: "String";
};
/**
 * Static routing enrichment value type. For e.g. this property value can be 'String'.
 */
export type StaticRoutingEnrichmentType = (typeof StaticRoutingEnrichmentType)[keyof typeof StaticRoutingEnrichmentType];
export declare const TlsVersion: {
    readonly TlsVersion_1_0: "1.0";
    readonly TlsVersion_1_1: "1.1";
    readonly TlsVersion_1_2: "1.2";
};
/**
 * Minimum TLS version that should be supported by webhook endpoint
 */
export type TlsVersion = (typeof TlsVersion)[keyof typeof TlsVersion];
export declare const TopicSpacesConfigurationState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Indicate if Topic Spaces Configuration is enabled for the namespace. Default is Disabled.
 */
export type TopicSpacesConfigurationState = (typeof TopicSpacesConfigurationState)[keyof typeof TopicSpacesConfigurationState];
