export declare const DhGroup: {
    readonly None: "None";
    readonly DHGroup1: "DHGroup1";
    readonly DHGroup2: "DHGroup2";
    readonly DHGroup14: "DHGroup14";
    readonly DHGroup2048: "DHGroup2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly DHGroup24: "DHGroup24";
};
/**
 * The DH Groups used in IKE Phase 1 for initial SA.
 */
export type DhGroup = (typeof DhGroup)[keyof typeof DhGroup];
export declare const IPAllocationMethod: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The public IP allocation method. Possible values are: 'Static' and 'Dynamic'.
 */
export type IPAllocationMethod = (typeof IPAllocationMethod)[keyof typeof IPAllocationMethod];
export declare const IPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * The public IP address version. Possible values are: 'IPv4' and 'IPv6'.
 */
export type IPVersion = (typeof IPVersion)[keyof typeof IPVersion];
export declare const IkeEncryption: {
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE encryption algorithm (IKE phase 2).
 */
export type IkeEncryption = (typeof IkeEncryption)[keyof typeof IkeEncryption];
export declare const IkeIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly SHA384: "SHA384";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE integrity algorithm (IKE phase 2).
 */
export type IkeIntegrity = (typeof IkeIntegrity)[keyof typeof IkeIntegrity];
export declare const IpsecEncryption: {
    readonly None: "None";
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec encryption algorithm (IKE phase 1).
 */
export type IpsecEncryption = (typeof IpsecEncryption)[keyof typeof IpsecEncryption];
export declare const IpsecIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec integrity algorithm (IKE phase 1).
 */
export type IpsecIntegrity = (typeof IpsecIntegrity)[keyof typeof IpsecIntegrity];
export declare const PfsGroup: {
    readonly None: "None";
    readonly PFS1: "PFS1";
    readonly PFS2: "PFS2";
    readonly PFS2048: "PFS2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly PFS24: "PFS24";
    readonly PFS14: "PFS14";
    readonly PFSMM: "PFSMM";
};
/**
 * The Pfs Groups used in IKE Phase 2 for new child SA.
 */
export type PfsGroup = (typeof PfsGroup)[keyof typeof PfsGroup];
export declare const PublicIPAddressSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * Name of a public IP address SKU.
 */
export type PublicIPAddressSkuName = (typeof PublicIPAddressSkuName)[keyof typeof PublicIPAddressSkuName];
export declare const RouteNextHopType: {
    readonly VirtualNetworkGateway: "VirtualNetworkGateway";
    readonly VnetLocal: "VnetLocal";
    readonly Internet: "Internet";
    readonly VirtualAppliance: "VirtualAppliance";
    readonly None: "None";
};
/**
 * The type of Azure hop the packet should be sent to. Possible values are: 'VirtualNetworkGateway', 'VnetLocal', 'Internet', 'VirtualAppliance', and 'None'
 */
export type RouteNextHopType = (typeof RouteNextHopType)[keyof typeof RouteNextHopType];
export declare const SecurityRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The network traffic is allowed or denied. Possible values are: 'Allow' and 'Deny'.
 */
export type SecurityRuleAccess = (typeof SecurityRuleAccess)[keyof typeof SecurityRuleAccess];
export declare const SecurityRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are: 'Inbound' and 'Outbound'.
 */
export type SecurityRuleDirection = (typeof SecurityRuleDirection)[keyof typeof SecurityRuleDirection];
export declare const SecurityRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Asterisk: "*";
};
/**
 * Network protocol this rule applies to. Possible values are 'Tcp', 'Udp', and '*'.
 */
export type SecurityRuleProtocol = (typeof SecurityRuleProtocol)[keyof typeof SecurityRuleProtocol];
export declare const TransportProtocol: {
    readonly Udp: "Udp";
    readonly Tcp: "Tcp";
    readonly All: "All";
};
/**
 * The transport protocol for the endpoint. Possible values are 'Udp' or 'Tcp' or 'All'.
 */
export type TransportProtocol = (typeof TransportProtocol)[keyof typeof TransportProtocol];
