export declare const Access: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The access type of the rule.
 */
export type Access = (typeof Access)[keyof typeof Access];
export declare const ActionType: {
    readonly AnomalyScoring: "AnomalyScoring";
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly JSChallenge: "JSChallenge";
};
/**
 * Describes the override action to be applied when rule matches.
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const AddressPrefixType: {
    readonly IPPrefix: "IPPrefix";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Address prefix type.
 */
export type AddressPrefixType = (typeof AddressPrefixType)[keyof typeof AddressPrefixType];
export declare const AdminRuleKind: {
    readonly Custom: "Custom";
    readonly Default: "Default";
};
/**
 * Whether the rule is custom or default.
 */
export type AdminRuleKind = (typeof AdminRuleKind)[keyof typeof AdminRuleKind];
export declare const AdminState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Property to indicate if the Express Route Gateway serves traffic when there are multiple Express Route Gateways in the vnet
 */
export type AdminState = (typeof AdminState)[keyof typeof AdminState];
export declare const ApplicationGatewayClientRevocationOptions: {
    readonly None: "None";
    readonly OCSP: "OCSP";
};
/**
 * Verify client certificate revocation status.
 */
export type ApplicationGatewayClientRevocationOptions = (typeof ApplicationGatewayClientRevocationOptions)[keyof typeof ApplicationGatewayClientRevocationOptions];
export declare const ApplicationGatewayCookieBasedAffinity: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Cookie based affinity.
 */
export type ApplicationGatewayCookieBasedAffinity = (typeof ApplicationGatewayCookieBasedAffinity)[keyof typeof ApplicationGatewayCookieBasedAffinity];
export declare const ApplicationGatewayCustomErrorStatusCode: {
    readonly HttpStatus400: "HttpStatus400";
    readonly HttpStatus403: "HttpStatus403";
    readonly HttpStatus404: "HttpStatus404";
    readonly HttpStatus405: "HttpStatus405";
    readonly HttpStatus408: "HttpStatus408";
    readonly HttpStatus500: "HttpStatus500";
    readonly HttpStatus502: "HttpStatus502";
    readonly HttpStatus503: "HttpStatus503";
    readonly HttpStatus504: "HttpStatus504";
};
/**
 * Status code of the application gateway custom error.
 */
export type ApplicationGatewayCustomErrorStatusCode = (typeof ApplicationGatewayCustomErrorStatusCode)[keyof typeof ApplicationGatewayCustomErrorStatusCode];
export declare const ApplicationGatewayFirewallMode: {
    readonly Detection: "Detection";
    readonly Prevention: "Prevention";
};
/**
 * Web application firewall mode.
 */
export type ApplicationGatewayFirewallMode = (typeof ApplicationGatewayFirewallMode)[keyof typeof ApplicationGatewayFirewallMode];
export declare const ApplicationGatewayFirewallRateLimitDuration: {
    readonly OneMin: "OneMin";
    readonly FiveMins: "FiveMins";
};
/**
 * Duration over which Rate Limit policy will be applied. Applies only when ruleType is RateLimitRule.
 */
export type ApplicationGatewayFirewallRateLimitDuration = (typeof ApplicationGatewayFirewallRateLimitDuration)[keyof typeof ApplicationGatewayFirewallRateLimitDuration];
export declare const ApplicationGatewayFirewallUserSessionVariable: {
    readonly ClientAddr: "ClientAddr";
    readonly GeoLocation: "GeoLocation";
    readonly None: "None";
};
/**
 * User Session clause variable.
 */
export type ApplicationGatewayFirewallUserSessionVariable = (typeof ApplicationGatewayFirewallUserSessionVariable)[keyof typeof ApplicationGatewayFirewallUserSessionVariable];
export declare const ApplicationGatewayLoadDistributionAlgorithm: {
    readonly RoundRobin: "RoundRobin";
    readonly LeastConnections: "LeastConnections";
    readonly IpHash: "IpHash";
};
/**
 * Load Distribution Targets resource of an application gateway.
 */
export type ApplicationGatewayLoadDistributionAlgorithm = (typeof ApplicationGatewayLoadDistributionAlgorithm)[keyof typeof ApplicationGatewayLoadDistributionAlgorithm];
export declare const ApplicationGatewayProtocol: {
    /**
     * Supported for httpListeners and  backendHttpSettingsCollection properties.
     */
    readonly Http: "Http";
    /**
     * Supported for httpListeners and  backendHttpSettingsCollection properties.
     */
    readonly Https: "Https";
    /**
     * Supported for listeners and backendSettingsCollection properties.
     */
    readonly Tcp: "Tcp";
    /**
     * Supported for listeners and backendSettingsCollection properties.
     */
    readonly Tls: "Tls";
};
/**
 * The protocol used for the probe.
 */
export type ApplicationGatewayProtocol = (typeof ApplicationGatewayProtocol)[keyof typeof ApplicationGatewayProtocol];
export declare const ApplicationGatewayRedirectType: {
    readonly Permanent: "Permanent";
    readonly Found: "Found";
    readonly SeeOther: "SeeOther";
    readonly Temporary: "Temporary";
};
/**
 * HTTP redirection type.
 */
export type ApplicationGatewayRedirectType = (typeof ApplicationGatewayRedirectType)[keyof typeof ApplicationGatewayRedirectType];
export declare const ApplicationGatewayRequestRoutingRuleType: {
    readonly Basic: "Basic";
    readonly PathBasedRouting: "PathBasedRouting";
};
/**
 * Rule type.
 */
export type ApplicationGatewayRequestRoutingRuleType = (typeof ApplicationGatewayRequestRoutingRuleType)[keyof typeof ApplicationGatewayRequestRoutingRuleType];
export declare const ApplicationGatewaySkuName: {
    readonly Standard_Small: "Standard_Small";
    readonly Standard_Medium: "Standard_Medium";
    readonly Standard_Large: "Standard_Large";
    readonly WAF_Medium: "WAF_Medium";
    readonly WAF_Large: "WAF_Large";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
    readonly Basic: "Basic";
};
/**
 * Name of an application gateway SKU.
 */
export type ApplicationGatewaySkuName = (typeof ApplicationGatewaySkuName)[keyof typeof ApplicationGatewaySkuName];
export declare const ApplicationGatewaySslCipherSuite: {
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_DHE_RSA_WITH_AES_256_CBC_SHA: "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_128_CBC_SHA: "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_AES_256_GCM_SHA384: "TLS_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_RSA_WITH_AES_128_GCM_SHA256: "TLS_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA256: "TLS_RSA_WITH_AES_256_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA256: "TLS_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA: "TLS_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA: "TLS_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_3DES_EDE_CBC_SHA: "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
};
/**
 * Ssl cipher suites enums.
 */
export type ApplicationGatewaySslCipherSuite = (typeof ApplicationGatewaySslCipherSuite)[keyof typeof ApplicationGatewaySslCipherSuite];
export declare const ApplicationGatewaySslPolicyName: {
    readonly AppGwSslPolicy20150501: "AppGwSslPolicy20150501";
    readonly AppGwSslPolicy20170401: "AppGwSslPolicy20170401";
    readonly AppGwSslPolicy20170401S: "AppGwSslPolicy20170401S";
    readonly AppGwSslPolicy20220101: "AppGwSslPolicy20220101";
    readonly AppGwSslPolicy20220101S: "AppGwSslPolicy20220101S";
};
/**
 * Name of Ssl predefined policy.
 */
export type ApplicationGatewaySslPolicyName = (typeof ApplicationGatewaySslPolicyName)[keyof typeof ApplicationGatewaySslPolicyName];
export declare const ApplicationGatewaySslPolicyType: {
    readonly Predefined: "Predefined";
    readonly Custom: "Custom";
    readonly CustomV2: "CustomV2";
};
/**
 * Type of Ssl Policy.
 */
export type ApplicationGatewaySslPolicyType = (typeof ApplicationGatewaySslPolicyType)[keyof typeof ApplicationGatewaySslPolicyType];
export declare const ApplicationGatewaySslProtocol: {
    readonly TLSv1_0: "TLSv1_0";
    readonly TLSv1_1: "TLSv1_1";
    readonly TLSv1_2: "TLSv1_2";
    readonly TLSv1_3: "TLSv1_3";
};
/**
 * Minimum version of Ssl protocol to be supported on application gateway.
 */
export type ApplicationGatewaySslProtocol = (typeof ApplicationGatewaySslProtocol)[keyof typeof ApplicationGatewaySslProtocol];
export declare const ApplicationGatewayTier: {
    readonly Standard: "Standard";
    readonly WAF: "WAF";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
    readonly Basic: "Basic";
};
/**
 * Tier of an application gateway.
 */
export type ApplicationGatewayTier = (typeof ApplicationGatewayTier)[keyof typeof ApplicationGatewayTier];
export declare const AuthorizationUseStatus: {
    readonly Available: "Available";
    readonly InUse: "InUse";
};
/**
 * The authorization use status.
 */
export type AuthorizationUseStatus = (typeof AuthorizationUseStatus)[keyof typeof AuthorizationUseStatus];
export declare const AutoLearnPrivateRangesMode: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * The operation mode for automatically learning private ranges to not be SNAT
 */
export type AutoLearnPrivateRangesMode = (typeof AutoLearnPrivateRangesMode)[keyof typeof AutoLearnPrivateRangesMode];
export declare const AzureFirewallApplicationRuleProtocolType: {
    readonly Http: "Http";
    readonly Https: "Https";
    readonly Mssql: "Mssql";
};
/**
 * Protocol type.
 */
export type AzureFirewallApplicationRuleProtocolType = (typeof AzureFirewallApplicationRuleProtocolType)[keyof typeof AzureFirewallApplicationRuleProtocolType];
export declare const AzureFirewallNatRCActionType: {
    readonly Snat: "Snat";
    readonly Dnat: "Dnat";
};
/**
 * The type of action.
 */
export type AzureFirewallNatRCActionType = (typeof AzureFirewallNatRCActionType)[keyof typeof AzureFirewallNatRCActionType];
export declare const AzureFirewallNetworkRuleProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
    readonly ICMP: "ICMP";
};
/**
 * The protocol of a Network Rule resource.
 */
export type AzureFirewallNetworkRuleProtocol = (typeof AzureFirewallNetworkRuleProtocol)[keyof typeof AzureFirewallNetworkRuleProtocol];
export declare const AzureFirewallRCActionType: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The type of action.
 */
export type AzureFirewallRCActionType = (typeof AzureFirewallRCActionType)[keyof typeof AzureFirewallRCActionType];
export declare const AzureFirewallSkuName: {
    readonly AZFW_VNet: "AZFW_VNet";
    readonly AZFW_Hub: "AZFW_Hub";
};
/**
 * Name of an Azure Firewall SKU.
 */
export type AzureFirewallSkuName = (typeof AzureFirewallSkuName)[keyof typeof AzureFirewallSkuName];
export declare const AzureFirewallSkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
};
/**
 * Tier of an Azure Firewall.
 */
export type AzureFirewallSkuTier = (typeof AzureFirewallSkuTier)[keyof typeof AzureFirewallSkuTier];
export declare const AzureFirewallThreatIntelMode: {
    readonly Alert: "Alert";
    readonly Deny: "Deny";
    readonly Off: "Off";
};
/**
 * The operation mode for Threat Intelligence.
 */
export type AzureFirewallThreatIntelMode = (typeof AzureFirewallThreatIntelMode)[keyof typeof AzureFirewallThreatIntelMode];
export declare const BastionHostSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Developer: "Developer";
};
/**
 * The name of this Bastion Host.
 */
export type BastionHostSkuName = (typeof BastionHostSkuName)[keyof typeof BastionHostSkuName];
export declare const CommissionedState: {
    readonly Provisioning: "Provisioning";
    readonly Provisioned: "Provisioned";
    readonly Commissioning: "Commissioning";
    readonly CommissionedNoInternetAdvertise: "CommissionedNoInternetAdvertise";
    readonly Commissioned: "Commissioned";
    readonly Decommissioning: "Decommissioning";
    readonly Deprovisioning: "Deprovisioning";
    readonly Deprovisioned: "Deprovisioned";
};
/**
 * The commissioned state of the Custom IP Prefix.
 */
export type CommissionedState = (typeof CommissionedState)[keyof typeof CommissionedState];
export declare const ConfigurationType: {
    readonly SecurityAdmin: "SecurityAdmin";
    readonly Connectivity: "Connectivity";
};
/**
 * Configuration Deployment Type.
 */
export type ConfigurationType = (typeof ConfigurationType)[keyof typeof ConfigurationType];
export declare const ConnectionMonitorEndpointFilterItemType: {
    readonly AgentAddress: "AgentAddress";
};
/**
 * The type of item included in the filter. Currently only 'AgentAddress' is supported.
 */
export type ConnectionMonitorEndpointFilterItemType = (typeof ConnectionMonitorEndpointFilterItemType)[keyof typeof ConnectionMonitorEndpointFilterItemType];
export declare const ConnectionMonitorEndpointFilterType: {
    readonly Include: "Include";
};
/**
 * The behavior of the endpoint filter. Currently only 'Include' is supported.
 */
export type ConnectionMonitorEndpointFilterType = (typeof ConnectionMonitorEndpointFilterType)[keyof typeof ConnectionMonitorEndpointFilterType];
export declare const ConnectionMonitorTestConfigurationProtocol: {
    readonly Tcp: "Tcp";
    readonly Http: "Http";
    readonly Icmp: "Icmp";
};
/**
 * The protocol to use in test evaluation.
 */
export type ConnectionMonitorTestConfigurationProtocol = (typeof ConnectionMonitorTestConfigurationProtocol)[keyof typeof ConnectionMonitorTestConfigurationProtocol];
export declare const ConnectivityTopology: {
    readonly HubAndSpoke: "HubAndSpoke";
    readonly Mesh: "Mesh";
};
/**
 * Connectivity topology type.
 */
export type ConnectivityTopology = (typeof ConnectivityTopology)[keyof typeof ConnectivityTopology];
export declare const CoverageLevel: {
    readonly Default: "Default";
    readonly Low: "Low";
    readonly BelowAverage: "BelowAverage";
    readonly Average: "Average";
    readonly AboveAverage: "AboveAverage";
    readonly Full: "Full";
};
/**
 * Test coverage for the endpoint.
 */
export type CoverageLevel = (typeof CoverageLevel)[keyof typeof CoverageLevel];
export declare const CustomIpPrefixType: {
    readonly Singular: "Singular";
    readonly Parent: "Parent";
    readonly Child: "Child";
};
/**
 * Type of custom IP prefix. Should be Singular, Parent, or Child.
 */
export type CustomIpPrefixType = (typeof CustomIpPrefixType)[keyof typeof CustomIpPrefixType];
export declare const DdosSettingsProtectionMode: {
    readonly VirtualNetworkInherited: "VirtualNetworkInherited";
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * The DDoS protection mode of the public IP
 */
export type DdosSettingsProtectionMode = (typeof DdosSettingsProtectionMode)[keyof typeof DdosSettingsProtectionMode];
export declare const DeleteExistingPeering: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to remove current existing peerings.
 */
export type DeleteExistingPeering = (typeof DeleteExistingPeering)[keyof typeof DeleteExistingPeering];
export declare const DeleteOptions: {
    readonly Delete: "Delete";
    readonly Detach: "Detach";
};
/**
 * Specify what happens to the public IP address when the VM using it is deleted
 */
export type DeleteOptions = (typeof DeleteOptions)[keyof typeof DeleteOptions];
export declare const DestinationPortBehavior: {
    readonly None: "None";
    readonly ListenIfAvailable: "ListenIfAvailable";
};
/**
 * Destination port behavior.
 */
export type DestinationPortBehavior = (typeof DestinationPortBehavior)[keyof typeof DestinationPortBehavior];
export declare const DhGroup: {
    readonly None: "None";
    readonly DHGroup1: "DHGroup1";
    readonly DHGroup2: "DHGroup2";
    readonly DHGroup14: "DHGroup14";
    readonly DHGroup2048: "DHGroup2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly DHGroup24: "DHGroup24";
};
/**
 * The DH Group used in IKE Phase 1 for initial SA.
 */
export type DhGroup = (typeof DhGroup)[keyof typeof DhGroup];
export declare const EndpointType: {
    readonly AzureVM: "AzureVM";
    readonly AzureVNet: "AzureVNet";
    readonly AzureSubnet: "AzureSubnet";
    readonly ExternalAddress: "ExternalAddress";
    readonly MMAWorkspaceMachine: "MMAWorkspaceMachine";
    readonly MMAWorkspaceNetwork: "MMAWorkspaceNetwork";
    readonly AzureArcVM: "AzureArcVM";
    readonly AzureVMSS: "AzureVMSS";
};
/**
 * The endpoint type.
 */
export type EndpointType = (typeof EndpointType)[keyof typeof EndpointType];
export declare const ExpressRouteCircuitPeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of peering.
 */
export type ExpressRouteCircuitPeeringState = (typeof ExpressRouteCircuitPeeringState)[keyof typeof ExpressRouteCircuitPeeringState];
export declare const ExpressRouteCircuitSkuFamily: {
    readonly UnlimitedData: "UnlimitedData";
    readonly MeteredData: "MeteredData";
};
/**
 * The family of the SKU.
 */
export type ExpressRouteCircuitSkuFamily = (typeof ExpressRouteCircuitSkuFamily)[keyof typeof ExpressRouteCircuitSkuFamily];
export declare const ExpressRouteCircuitSkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
    readonly Local: "Local";
};
/**
 * The tier of the SKU.
 */
export type ExpressRouteCircuitSkuTier = (typeof ExpressRouteCircuitSkuTier)[keyof typeof ExpressRouteCircuitSkuTier];
export declare const ExpressRouteLinkAdminState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Administrative state of the physical port.
 */
export type ExpressRouteLinkAdminState = (typeof ExpressRouteLinkAdminState)[keyof typeof ExpressRouteLinkAdminState];
export declare const ExpressRouteLinkMacSecCipher: {
    readonly GcmAes256: "GcmAes256";
    readonly GcmAes128: "GcmAes128";
    readonly GcmAesXpn128: "GcmAesXpn128";
    readonly GcmAesXpn256: "GcmAesXpn256";
};
/**
 * Mac security cipher.
 */
export type ExpressRouteLinkMacSecCipher = (typeof ExpressRouteLinkMacSecCipher)[keyof typeof ExpressRouteLinkMacSecCipher];
export declare const ExpressRouteLinkMacSecSciState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Sci mode enabled/disabled.
 */
export type ExpressRouteLinkMacSecSciState = (typeof ExpressRouteLinkMacSecSciState)[keyof typeof ExpressRouteLinkMacSecSciState];
export declare const ExpressRoutePeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The peering state.
 */
export type ExpressRoutePeeringState = (typeof ExpressRoutePeeringState)[keyof typeof ExpressRoutePeeringState];
export declare const ExpressRoutePeeringType: {
    readonly AzurePublicPeering: "AzurePublicPeering";
    readonly AzurePrivatePeering: "AzurePrivatePeering";
    readonly MicrosoftPeering: "MicrosoftPeering";
};
/**
 * The peering type.
 */
export type ExpressRoutePeeringType = (typeof ExpressRoutePeeringType)[keyof typeof ExpressRoutePeeringType];
export declare const ExpressRoutePortsBillingType: {
    readonly MeteredData: "MeteredData";
    readonly UnlimitedData: "UnlimitedData";
};
/**
 * The billing type of the ExpressRoutePort resource.
 */
export type ExpressRoutePortsBillingType = (typeof ExpressRoutePortsBillingType)[keyof typeof ExpressRoutePortsBillingType];
export declare const ExpressRoutePortsEncapsulation: {
    readonly Dot1Q: "Dot1Q";
    readonly QinQ: "QinQ";
};
/**
 * Encapsulation method on physical ports.
 */
export type ExpressRoutePortsEncapsulation = (typeof ExpressRoutePortsEncapsulation)[keyof typeof ExpressRoutePortsEncapsulation];
export declare const ExtendedLocationTypes: {
    readonly EdgeZone: "EdgeZone";
};
/**
 * The type of the extended location.
 */
export type ExtendedLocationTypes = (typeof ExtendedLocationTypes)[keyof typeof ExtendedLocationTypes];
export declare const FirewallPolicyFilterRuleCollectionActionType: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The type of action.
 */
export type FirewallPolicyFilterRuleCollectionActionType = (typeof FirewallPolicyFilterRuleCollectionActionType)[keyof typeof FirewallPolicyFilterRuleCollectionActionType];
export declare const FirewallPolicyIDPSQuerySortOrder: {
    readonly Ascending: "Ascending";
    readonly Descending: "Descending";
};
/**
 * Describes if results should be in ascending/descending order
 */
export type FirewallPolicyIDPSQuerySortOrder = (typeof FirewallPolicyIDPSQuerySortOrder)[keyof typeof FirewallPolicyIDPSQuerySortOrder];
export declare const FirewallPolicyIntrusionDetectionProfileType: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Advanced: "Advanced";
    readonly Extended: "Extended";
};
/**
 * IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
 */
export type FirewallPolicyIntrusionDetectionProfileType = (typeof FirewallPolicyIntrusionDetectionProfileType)[keyof typeof FirewallPolicyIntrusionDetectionProfileType];
export declare const FirewallPolicyIntrusionDetectionProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly ICMP: "ICMP";
    readonly ANY: "ANY";
};
/**
 * The rule bypass protocol.
 */
export type FirewallPolicyIntrusionDetectionProtocol = (typeof FirewallPolicyIntrusionDetectionProtocol)[keyof typeof FirewallPolicyIntrusionDetectionProtocol];
export declare const FirewallPolicyIntrusionDetectionStateType: {
    readonly Off: "Off";
    readonly Alert: "Alert";
    readonly Deny: "Deny";
};
/**
 * Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
 */
export type FirewallPolicyIntrusionDetectionStateType = (typeof FirewallPolicyIntrusionDetectionStateType)[keyof typeof FirewallPolicyIntrusionDetectionStateType];
export declare const FirewallPolicyNatRuleCollectionActionType: {
    readonly DNAT: "DNAT";
};
/**
 * The type of action.
 */
export type FirewallPolicyNatRuleCollectionActionType = (typeof FirewallPolicyNatRuleCollectionActionType)[keyof typeof FirewallPolicyNatRuleCollectionActionType];
export declare const FirewallPolicyRuleApplicationProtocolType: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol type.
 */
export type FirewallPolicyRuleApplicationProtocolType = (typeof FirewallPolicyRuleApplicationProtocolType)[keyof typeof FirewallPolicyRuleApplicationProtocolType];
export declare const FirewallPolicyRuleCollectionType: {
    readonly FirewallPolicyNatRuleCollection: "FirewallPolicyNatRuleCollection";
    readonly FirewallPolicyFilterRuleCollection: "FirewallPolicyFilterRuleCollection";
};
/**
 * The type of the rule collection.
 */
export type FirewallPolicyRuleCollectionType = (typeof FirewallPolicyRuleCollectionType)[keyof typeof FirewallPolicyRuleCollectionType];
export declare const FirewallPolicyRuleNetworkProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
    readonly ICMP: "ICMP";
};
/**
 * The Network protocol of a Rule.
 */
export type FirewallPolicyRuleNetworkProtocol = (typeof FirewallPolicyRuleNetworkProtocol)[keyof typeof FirewallPolicyRuleNetworkProtocol];
export declare const FirewallPolicyRuleType: {
    readonly ApplicationRule: "ApplicationRule";
    readonly NetworkRule: "NetworkRule";
    readonly NatRule: "NatRule";
};
/**
 * Rule Type.
 */
export type FirewallPolicyRuleType = (typeof FirewallPolicyRuleType)[keyof typeof FirewallPolicyRuleType];
export declare const FirewallPolicySkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
};
/**
 * Tier of Firewall Policy.
 */
export type FirewallPolicySkuTier = (typeof FirewallPolicySkuTier)[keyof typeof FirewallPolicySkuTier];
export declare const FlowLogFormatType: {
    readonly JSON: "JSON";
};
/**
 * The file type of flow log.
 */
export type FlowLogFormatType = (typeof FlowLogFormatType)[keyof typeof FlowLogFormatType];
export declare const GatewayLoadBalancerTunnelInterfaceType: {
    readonly None: "None";
    readonly Internal: "Internal";
    readonly External: "External";
};
/**
 * Traffic type of gateway load balancer tunnel interface.
 */
export type GatewayLoadBalancerTunnelInterfaceType = (typeof GatewayLoadBalancerTunnelInterfaceType)[keyof typeof GatewayLoadBalancerTunnelInterfaceType];
export declare const GatewayLoadBalancerTunnelProtocol: {
    readonly None: "None";
    readonly Native: "Native";
    readonly VXLAN: "VXLAN";
};
/**
 * Protocol of gateway load balancer tunnel interface.
 */
export type GatewayLoadBalancerTunnelProtocol = (typeof GatewayLoadBalancerTunnelProtocol)[keyof typeof GatewayLoadBalancerTunnelProtocol];
export declare const Geo: {
    readonly GLOBAL: "GLOBAL";
    readonly AFRI: "AFRI";
    readonly APAC: "APAC";
    readonly EURO: "EURO";
    readonly LATAM: "LATAM";
    readonly NAM: "NAM";
    readonly ME: "ME";
    readonly OCEANIA: "OCEANIA";
    readonly AQ: "AQ";
};
/**
 * The Geo for CIDR advertising. Should be an Geo code.
 */
export type Geo = (typeof Geo)[keyof typeof Geo];
export declare const GroupConnectivity: {
    readonly None: "None";
    readonly DirectlyConnected: "DirectlyConnected";
};
/**
 * Group connectivity type.
 */
export type GroupConnectivity = (typeof GroupConnectivity)[keyof typeof GroupConnectivity];
export declare const HTTPConfigurationMethod: {
    readonly Get: "Get";
    readonly Post: "Post";
};
/**
 * The HTTP method to use.
 */
export type HTTPConfigurationMethod = (typeof HTTPConfigurationMethod)[keyof typeof HTTPConfigurationMethod];
export declare const HubRoutingPreference: {
    readonly ExpressRoute: "ExpressRoute";
    readonly VpnGateway: "VpnGateway";
    readonly ASPath: "ASPath";
};
/**
 * The hubRoutingPreference of this VirtualHub.
 */
export type HubRoutingPreference = (typeof HubRoutingPreference)[keyof typeof HubRoutingPreference];
export declare const IPAllocationMethod: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The private IP address allocation method.
 */
export type IPAllocationMethod = (typeof IPAllocationMethod)[keyof typeof IPAllocationMethod];
export declare const IPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
 */
export type IPVersion = (typeof IPVersion)[keyof typeof IPVersion];
export declare const IkeEncryption: {
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE encryption algorithm (IKE phase 2).
 */
export type IkeEncryption = (typeof IkeEncryption)[keyof typeof IkeEncryption];
export declare const IkeIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly SHA384: "SHA384";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE integrity algorithm (IKE phase 2).
 */
export type IkeIntegrity = (typeof IkeIntegrity)[keyof typeof IkeIntegrity];
export declare const IpAllocationType: {
    readonly Undefined: "Undefined";
    readonly Hypernet: "Hypernet";
};
/**
 * The type for the IpAllocation.
 */
export type IpAllocationType = (typeof IpAllocationType)[keyof typeof IpAllocationType];
export declare const IpsecEncryption: {
    readonly None: "None";
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec encryption algorithm (IKE phase 1).
 */
export type IpsecEncryption = (typeof IpsecEncryption)[keyof typeof IpsecEncryption];
export declare const IpsecIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec integrity algorithm (IKE phase 1).
 */
export type IpsecIntegrity = (typeof IpsecIntegrity)[keyof typeof IpsecIntegrity];
export declare const IsGlobal: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if global mesh is supported.
 */
export type IsGlobal = (typeof IsGlobal)[keyof typeof IsGlobal];
export declare const LoadBalancerBackendAddressAdminState: {
    readonly None: "None";
    readonly Up: "Up";
    readonly Down: "Down";
};
/**
 * A list of administrative states which once set can override health probe so that Load Balancer will always forward new connections to backend, or deny new connections and reset existing connections.
 */
export type LoadBalancerBackendAddressAdminState = (typeof LoadBalancerBackendAddressAdminState)[keyof typeof LoadBalancerBackendAddressAdminState];
export declare const LoadBalancerOutboundRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly All: "All";
};
/**
 * The protocol for the outbound rule in load balancer.
 */
export type LoadBalancerOutboundRuleProtocol = (typeof LoadBalancerOutboundRuleProtocol)[keyof typeof LoadBalancerOutboundRuleProtocol];
export declare const LoadBalancerSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Gateway: "Gateway";
};
/**
 * Name of a load balancer SKU.
 */
export type LoadBalancerSkuName = (typeof LoadBalancerSkuName)[keyof typeof LoadBalancerSkuName];
export declare const LoadBalancerSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a load balancer SKU.
 */
export type LoadBalancerSkuTier = (typeof LoadBalancerSkuTier)[keyof typeof LoadBalancerSkuTier];
export declare const LoadDistribution: {
    readonly Default: "Default";
    readonly SourceIP: "SourceIP";
    readonly SourceIPProtocol: "SourceIPProtocol";
};
/**
 * The load distribution policy for this rule.
 */
export type LoadDistribution = (typeof LoadDistribution)[keyof typeof LoadDistribution];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of the managed rule. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const NatGatewaySkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of Nat Gateway SKU.
 */
export type NatGatewaySkuName = (typeof NatGatewaySkuName)[keyof typeof NatGatewaySkuName];
export declare const NetworkIntentPolicyBasedService: {
    readonly None: "None";
    readonly All: "All";
    readonly AllowRulesOnly: "AllowRulesOnly";
};
/**
 * Network intent policy based services.
 */
export type NetworkIntentPolicyBasedService = (typeof NetworkIntentPolicyBasedService)[keyof typeof NetworkIntentPolicyBasedService];
export declare const NetworkInterfaceAuxiliaryMode: {
    readonly None: "None";
    readonly MaxConnections: "MaxConnections";
    readonly Floating: "Floating";
    readonly AcceleratedConnections: "AcceleratedConnections";
};
/**
 * Auxiliary mode of Network Interface resource.
 */
export type NetworkInterfaceAuxiliaryMode = (typeof NetworkInterfaceAuxiliaryMode)[keyof typeof NetworkInterfaceAuxiliaryMode];
export declare const NetworkInterfaceAuxiliarySku: {
    readonly None: "None";
    readonly A1: "A1";
    readonly A2: "A2";
    readonly A4: "A4";
    readonly A8: "A8";
};
/**
 * Auxiliary sku of Network Interface resource.
 */
export type NetworkInterfaceAuxiliarySku = (typeof NetworkInterfaceAuxiliarySku)[keyof typeof NetworkInterfaceAuxiliarySku];
export declare const NetworkInterfaceMigrationPhase: {
    readonly None: "None";
    readonly Prepare: "Prepare";
    readonly Commit: "Commit";
    readonly Abort: "Abort";
    readonly Committed: "Committed";
};
/**
 * Migration phase of Network Interface resource.
 */
export type NetworkInterfaceMigrationPhase = (typeof NetworkInterfaceMigrationPhase)[keyof typeof NetworkInterfaceMigrationPhase];
export declare const NetworkInterfaceNicType: {
    readonly Standard: "Standard";
    readonly Elastic: "Elastic";
};
/**
 * Type of Network Interface resource.
 */
export type NetworkInterfaceNicType = (typeof NetworkInterfaceNicType)[keyof typeof NetworkInterfaceNicType];
export declare const NextStep: {
    readonly Unknown: "Unknown";
    readonly Continue: "Continue";
    readonly Terminate: "Terminate";
};
/**
 * Next step after rule is evaluated. Current supported behaviors are 'Continue'(to next rule) and 'Terminate'.
 */
export type NextStep = (typeof NextStep)[keyof typeof NextStep];
export declare const OutputType: {
    readonly Workspace: "Workspace";
};
/**
 * Connection monitor output destination type. Currently, only "Workspace" is supported.
 */
export type OutputType = (typeof OutputType)[keyof typeof OutputType];
export declare const OwaspCrsExclusionEntryMatchVariable: {
    readonly RequestHeaderNames: "RequestHeaderNames";
    readonly RequestCookieNames: "RequestCookieNames";
    readonly RequestArgNames: "RequestArgNames";
    readonly RequestHeaderKeys: "RequestHeaderKeys";
    readonly RequestHeaderValues: "RequestHeaderValues";
    readonly RequestCookieKeys: "RequestCookieKeys";
    readonly RequestCookieValues: "RequestCookieValues";
    readonly RequestArgKeys: "RequestArgKeys";
    readonly RequestArgValues: "RequestArgValues";
};
/**
 * The variable to be excluded.
 */
export type OwaspCrsExclusionEntryMatchVariable = (typeof OwaspCrsExclusionEntryMatchVariable)[keyof typeof OwaspCrsExclusionEntryMatchVariable];
export declare const OwaspCrsExclusionEntrySelectorMatchOperator: {
    readonly Equals: "Equals";
    readonly Contains: "Contains";
    readonly StartsWith: "StartsWith";
    readonly EndsWith: "EndsWith";
    readonly EqualsAny: "EqualsAny";
};
/**
 * When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to.
 */
export type OwaspCrsExclusionEntrySelectorMatchOperator = (typeof OwaspCrsExclusionEntrySelectorMatchOperator)[keyof typeof OwaspCrsExclusionEntrySelectorMatchOperator];
export declare const PacketCaptureTargetType: {
    readonly AzureVM: "AzureVM";
    readonly AzureVMSS: "AzureVMSS";
};
/**
 * Target type of the resource provided.
 */
export type PacketCaptureTargetType = (typeof PacketCaptureTargetType)[keyof typeof PacketCaptureTargetType];
export declare const PcProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
};
/**
 * Protocol to be filtered on.
 */
export type PcProtocol = (typeof PcProtocol)[keyof typeof PcProtocol];
export declare const PfsGroup: {
    readonly None: "None";
    readonly PFS1: "PFS1";
    readonly PFS2: "PFS2";
    readonly PFS2048: "PFS2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly PFS24: "PFS24";
    readonly PFS14: "PFS14";
    readonly PFSMM: "PFSMM";
};
/**
 * The Pfs Group used in IKE Phase 2 for new child SA.
 */
export type PfsGroup = (typeof PfsGroup)[keyof typeof PfsGroup];
export declare const PreferredIPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters.
 */
export type PreferredIPVersion = (typeof PreferredIPVersion)[keyof typeof PreferredIPVersion];
export declare const PreferredRoutingGateway: {
    readonly ExpressRoute: "ExpressRoute";
    readonly VpnGateway: "VpnGateway";
    readonly None: "None";
};
/**
 * The preferred gateway to route on-prem traffic
 */
export type PreferredRoutingGateway = (typeof PreferredRoutingGateway)[keyof typeof PreferredRoutingGateway];
export declare const ProbeProtocol: {
    readonly Http: "Http";
    readonly Tcp: "Tcp";
    readonly Https: "Https";
};
/**
 * The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const ProtocolType: {
    readonly DoNotUse: "DoNotUse";
    readonly Icmp: "Icmp";
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Gre: "Gre";
    readonly Esp: "Esp";
    readonly Ah: "Ah";
    readonly Vxlan: "Vxlan";
    readonly All: "All";
};
/**
 * RNM supported protocol types.
 */
export type ProtocolType = (typeof ProtocolType)[keyof typeof ProtocolType];
export declare const PublicIPAddressMigrationPhase: {
    readonly None: "None";
    readonly Prepare: "Prepare";
    readonly Commit: "Commit";
    readonly Abort: "Abort";
    readonly Committed: "Committed";
};
/**
 * Migration phase of Public IP Address.
 */
export type PublicIPAddressMigrationPhase = (typeof PublicIPAddressMigrationPhase)[keyof typeof PublicIPAddressMigrationPhase];
export declare const PublicIPAddressSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * Name of a public IP address SKU.
 */
export type PublicIPAddressSkuName = (typeof PublicIPAddressSkuName)[keyof typeof PublicIPAddressSkuName];
export declare const PublicIPAddressSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a public IP address SKU.
 */
export type PublicIPAddressSkuTier = (typeof PublicIPAddressSkuTier)[keyof typeof PublicIPAddressSkuTier];
export declare const PublicIPPrefixSkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of a public IP prefix SKU.
 */
export type PublicIPPrefixSkuName = (typeof PublicIPPrefixSkuName)[keyof typeof PublicIPPrefixSkuName];
export declare const PublicIPPrefixSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a public IP prefix SKU.
 */
export type PublicIPPrefixSkuTier = (typeof PublicIPPrefixSkuTier)[keyof typeof PublicIPPrefixSkuTier];
export declare const PublicIpAddressDnsSettingsDomainNameLabelScope: {
    readonly TenantReuse: "TenantReuse";
    readonly SubscriptionReuse: "SubscriptionReuse";
    readonly ResourceGroupReuse: "ResourceGroupReuse";
    readonly NoReuse: "NoReuse";
};
/**
 * The domain name label scope. If a domain name label and a domain name label scope are specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system with a hashed value includes in FQDN.
 */
export type PublicIpAddressDnsSettingsDomainNameLabelScope = (typeof PublicIpAddressDnsSettingsDomainNameLabelScope)[keyof typeof PublicIpAddressDnsSettingsDomainNameLabelScope];
export declare const ResourceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
 */
export type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];
export declare const RouteFilterRuleType: {
    readonly Community: "Community";
};
/**
 * The rule type of the rule.
 */
export type RouteFilterRuleType = (typeof RouteFilterRuleType)[keyof typeof RouteFilterRuleType];
export declare const RouteMapActionType: {
    readonly Unknown: "Unknown";
    readonly Remove: "Remove";
    readonly Add: "Add";
    readonly Replace: "Replace";
    readonly Drop: "Drop";
};
/**
 * Type of action to be taken. Supported types are 'Remove', 'Add', 'Replace', and 'Drop.'
 */
export type RouteMapActionType = (typeof RouteMapActionType)[keyof typeof RouteMapActionType];
export declare const RouteMapMatchCondition: {
    readonly Unknown: "Unknown";
    readonly Contains: "Contains";
    readonly Equals: "Equals";
    readonly NotContains: "NotContains";
    readonly NotEquals: "NotEquals";
};
/**
 * Match condition to apply RouteMap rules.
 */
export type RouteMapMatchCondition = (typeof RouteMapMatchCondition)[keyof typeof RouteMapMatchCondition];
export declare const RouteNextHopType: {
    readonly VirtualNetworkGateway: "VirtualNetworkGateway";
    readonly VnetLocal: "VnetLocal";
    readonly Internet: "Internet";
    readonly VirtualAppliance: "VirtualAppliance";
    readonly None: "None";
};
/**
 * The type of Azure hop the packet should be sent to.
 */
export type RouteNextHopType = (typeof RouteNextHopType)[keyof typeof RouteNextHopType];
export declare const ScrubbingRuleEntryMatchOperator: {
    readonly Equals: "Equals";
    readonly EqualsAny: "EqualsAny";
};
/**
 * When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
 */
export type ScrubbingRuleEntryMatchOperator = (typeof ScrubbingRuleEntryMatchOperator)[keyof typeof ScrubbingRuleEntryMatchOperator];
export declare const ScrubbingRuleEntryMatchVariable: {
    readonly RequestHeaderNames: "RequestHeaderNames";
    readonly RequestCookieNames: "RequestCookieNames";
    readonly RequestArgNames: "RequestArgNames";
    readonly RequestPostArgNames: "RequestPostArgNames";
    readonly RequestJSONArgNames: "RequestJSONArgNames";
    readonly RequestIPAddress: "RequestIPAddress";
};
/**
 * The variable to be scrubbed from the logs.
 */
export type ScrubbingRuleEntryMatchVariable = (typeof ScrubbingRuleEntryMatchVariable)[keyof typeof ScrubbingRuleEntryMatchVariable];
export declare const ScrubbingRuleEntryState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Defines the state of log scrubbing rule. Default value is Enabled.
 */
export type ScrubbingRuleEntryState = (typeof ScrubbingRuleEntryState)[keyof typeof ScrubbingRuleEntryState];
export declare const SecurityConfigurationRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
    readonly AlwaysAllow: "AlwaysAllow";
};
/**
 * Indicates the access allowed for this particular rule
 */
export type SecurityConfigurationRuleAccess = (typeof SecurityConfigurationRuleAccess)[keyof typeof SecurityConfigurationRuleAccess];
export declare const SecurityConfigurationRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * Indicates if the traffic matched against the rule in inbound or outbound.
 */
export type SecurityConfigurationRuleDirection = (typeof SecurityConfigurationRuleDirection)[keyof typeof SecurityConfigurationRuleDirection];
export declare const SecurityConfigurationRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Any: "Any";
    readonly Ah: "Ah";
};
/**
 * Network protocol this rule applies to.
 */
export type SecurityConfigurationRuleProtocol = (typeof SecurityConfigurationRuleProtocol)[keyof typeof SecurityConfigurationRuleProtocol];
export declare const SecurityProviderName: {
    readonly ZScaler: "ZScaler";
    readonly IBoss: "IBoss";
    readonly Checkpoint: "Checkpoint";
};
/**
 * The security provider name.
 */
export type SecurityProviderName = (typeof SecurityProviderName)[keyof typeof SecurityProviderName];
export declare const SecurityRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The network traffic is allowed or denied.
 */
export type SecurityRuleAccess = (typeof SecurityRuleAccess)[keyof typeof SecurityRuleAccess];
export declare const SecurityRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
 */
export type SecurityRuleDirection = (typeof SecurityRuleDirection)[keyof typeof SecurityRuleDirection];
export declare const SecurityRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Asterisk: "*";
    readonly Ah: "Ah";
};
/**
 * Network protocol this rule applies to.
 */
export type SecurityRuleProtocol = (typeof SecurityRuleProtocol)[keyof typeof SecurityRuleProtocol];
export declare const ServiceProviderProvisioningState: {
    readonly NotProvisioned: "NotProvisioned";
    readonly Provisioning: "Provisioning";
    readonly Provisioned: "Provisioned";
    readonly Deprovisioning: "Deprovisioning";
};
/**
 * The ServiceProviderProvisioningState state of the resource.
 */
export type ServiceProviderProvisioningState = (typeof ServiceProviderProvisioningState)[keyof typeof ServiceProviderProvisioningState];
export declare const SyncMode: {
    readonly Automatic: "Automatic";
    readonly Manual: "Manual";
};
/**
 * Backend address synchronous mode for the backend pool
 */
export type SyncMode = (typeof SyncMode)[keyof typeof SyncMode];
export declare const TransportProtocol: {
    readonly Udp: "Udp";
    readonly Tcp: "Tcp";
    readonly All: "All";
};
/**
 * The reference to the transport protocol used by the load balancing rule.
 */
export type TransportProtocol = (typeof TransportProtocol)[keyof typeof TransportProtocol];
export declare const UseHubGateway: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to use hub gateway.
 */
export type UseHubGateway = (typeof UseHubGateway)[keyof typeof UseHubGateway];
export declare const VirtualNetworkEncryptionEnforcement: {
    readonly DropUnencrypted: "DropUnencrypted";
    readonly AllowUnencrypted: "AllowUnencrypted";
};
/**
 * If the encrypted VNet allows VM that does not support encryption
 */
export type VirtualNetworkEncryptionEnforcement = (typeof VirtualNetworkEncryptionEnforcement)[keyof typeof VirtualNetworkEncryptionEnforcement];
export declare const VirtualNetworkGatewayConnectionMode: {
    readonly Default: "Default";
    readonly ResponderOnly: "ResponderOnly";
    readonly InitiatorOnly: "InitiatorOnly";
};
/**
 * The connection mode for this connection.
 */
export type VirtualNetworkGatewayConnectionMode = (typeof VirtualNetworkGatewayConnectionMode)[keyof typeof VirtualNetworkGatewayConnectionMode];
export declare const VirtualNetworkGatewayConnectionProtocol: {
    readonly IKEv2: "IKEv2";
    readonly IKEv1: "IKEv1";
};
/**
 * Connection protocol used for this connection.
 */
export type VirtualNetworkGatewayConnectionProtocol = (typeof VirtualNetworkGatewayConnectionProtocol)[keyof typeof VirtualNetworkGatewayConnectionProtocol];
export declare const VirtualNetworkGatewayConnectionType: {
    readonly IPsec: "IPsec";
    readonly Vnet2Vnet: "Vnet2Vnet";
    readonly ExpressRoute: "ExpressRoute";
    readonly VPNClient: "VPNClient";
};
/**
 * Gateway connection type.
 */
export type VirtualNetworkGatewayConnectionType = (typeof VirtualNetworkGatewayConnectionType)[keyof typeof VirtualNetworkGatewayConnectionType];
export declare const VirtualNetworkGatewaySkuName: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw4: "VpnGw4";
    readonly VpnGw5: "VpnGw5";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly VpnGw4AZ: "VpnGw4AZ";
    readonly VpnGw5AZ: "VpnGw5AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
    readonly ErGwScale: "ErGwScale";
};
/**
 * Gateway SKU name.
 */
export type VirtualNetworkGatewaySkuName = (typeof VirtualNetworkGatewaySkuName)[keyof typeof VirtualNetworkGatewaySkuName];
export declare const VirtualNetworkGatewaySkuTier: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw4: "VpnGw4";
    readonly VpnGw5: "VpnGw5";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly VpnGw4AZ: "VpnGw4AZ";
    readonly VpnGw5AZ: "VpnGw5AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
    readonly ErGwScale: "ErGwScale";
};
/**
 * Gateway SKU tier.
 */
export type VirtualNetworkGatewaySkuTier = (typeof VirtualNetworkGatewaySkuTier)[keyof typeof VirtualNetworkGatewaySkuTier];
export declare const VirtualNetworkGatewayType: {
    readonly Vpn: "Vpn";
    readonly ExpressRoute: "ExpressRoute";
    readonly LocalGateway: "LocalGateway";
};
/**
 * The type of this virtual network gateway.
 */
export type VirtualNetworkGatewayType = (typeof VirtualNetworkGatewayType)[keyof typeof VirtualNetworkGatewayType];
export declare const VirtualNetworkPeeringLevel: {
    readonly FullyInSync: "FullyInSync";
    readonly RemoteNotInSync: "RemoteNotInSync";
    readonly LocalNotInSync: "LocalNotInSync";
    readonly LocalAndRemoteNotInSync: "LocalAndRemoteNotInSync";
};
/**
 * The peering sync status of the virtual network peering.
 */
export type VirtualNetworkPeeringLevel = (typeof VirtualNetworkPeeringLevel)[keyof typeof VirtualNetworkPeeringLevel];
export declare const VirtualNetworkPeeringState: {
    readonly Initiated: "Initiated";
    readonly Connected: "Connected";
    readonly Disconnected: "Disconnected";
};
/**
 * The status of the virtual network peering.
 */
export type VirtualNetworkPeeringState = (typeof VirtualNetworkPeeringState)[keyof typeof VirtualNetworkPeeringState];
export declare const VirtualNetworkPrivateEndpointNetworkPolicies: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Enable or Disable apply network policies on private end point in the subnet.
 */
export type VirtualNetworkPrivateEndpointNetworkPolicies = (typeof VirtualNetworkPrivateEndpointNetworkPolicies)[keyof typeof VirtualNetworkPrivateEndpointNetworkPolicies];
export declare const VirtualNetworkPrivateLinkServiceNetworkPolicies: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Enable or Disable apply network policies on private link service in the subnet.
 */
export type VirtualNetworkPrivateLinkServiceNetworkPolicies = (typeof VirtualNetworkPrivateLinkServiceNetworkPolicies)[keyof typeof VirtualNetworkPrivateLinkServiceNetworkPolicies];
export declare const VnetLocalRouteOverrideCriteria: {
    readonly Contains: "Contains";
    readonly Equal: "Equal";
};
/**
 * Parameter determining whether NVA in spoke vnet is bypassed for traffic with destination in spoke.
 */
export type VnetLocalRouteOverrideCriteria = (typeof VnetLocalRouteOverrideCriteria)[keyof typeof VnetLocalRouteOverrideCriteria];
export declare const VpnAuthenticationType: {
    readonly Certificate: "Certificate";
    readonly Radius: "Radius";
    readonly AAD: "AAD";
};
/**
 * VPN authentication types enabled for the VpnServerConfiguration.
 */
export type VpnAuthenticationType = (typeof VpnAuthenticationType)[keyof typeof VpnAuthenticationType];
export declare const VpnClientProtocol: {
    readonly IkeV2: "IkeV2";
    readonly SSTP: "SSTP";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN client protocol enabled for the virtual network gateway.
 */
export type VpnClientProtocol = (typeof VpnClientProtocol)[keyof typeof VpnClientProtocol];
export declare const VpnGatewayGeneration: {
    readonly None: "None";
    readonly Generation1: "Generation1";
    readonly Generation2: "Generation2";
};
/**
 * The generation for this VirtualNetworkGateway. Must be None if gatewayType is not VPN.
 */
export type VpnGatewayGeneration = (typeof VpnGatewayGeneration)[keyof typeof VpnGatewayGeneration];
export declare const VpnGatewayTunnelingProtocol: {
    readonly IkeV2: "IkeV2";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN protocol enabled for the VpnServerConfiguration.
 */
export type VpnGatewayTunnelingProtocol = (typeof VpnGatewayTunnelingProtocol)[keyof typeof VpnGatewayTunnelingProtocol];
export declare const VpnLinkConnectionMode: {
    readonly Default: "Default";
    readonly ResponderOnly: "ResponderOnly";
    readonly InitiatorOnly: "InitiatorOnly";
};
/**
 * Vpn link connection mode.
 */
export type VpnLinkConnectionMode = (typeof VpnLinkConnectionMode)[keyof typeof VpnLinkConnectionMode];
export declare const VpnNatRuleMode: {
    readonly EgressSnat: "EgressSnat";
    readonly IngressSnat: "IngressSnat";
};
/**
 * The Source NAT direction of a VPN NAT.
 */
export type VpnNatRuleMode = (typeof VpnNatRuleMode)[keyof typeof VpnNatRuleMode];
export declare const VpnNatRuleType: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The type of NAT rule for VPN NAT.
 */
export type VpnNatRuleType = (typeof VpnNatRuleType)[keyof typeof VpnNatRuleType];
export declare const VpnPolicyMemberAttributeType: {
    readonly CertificateGroupId: "CertificateGroupId";
    readonly AADGroupId: "AADGroupId";
    readonly RadiusAzureGroupId: "RadiusAzureGroupId";
};
/**
 * The Vpn Policy member attribute type.
 */
export type VpnPolicyMemberAttributeType = (typeof VpnPolicyMemberAttributeType)[keyof typeof VpnPolicyMemberAttributeType];
export declare const VpnType: {
    readonly PolicyBased: "PolicyBased";
    readonly RouteBased: "RouteBased";
};
/**
 * The type of this virtual network gateway.
 */
export type VpnType = (typeof VpnType)[keyof typeof VpnType];
export declare const WebApplicationFirewallAction: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly JSChallenge: "JSChallenge";
};
/**
 * Type of Actions.
 */
export type WebApplicationFirewallAction = (typeof WebApplicationFirewallAction)[keyof typeof WebApplicationFirewallAction];
export declare const WebApplicationFirewallEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of the policy.
 */
export type WebApplicationFirewallEnabledState = (typeof WebApplicationFirewallEnabledState)[keyof typeof WebApplicationFirewallEnabledState];
export declare const WebApplicationFirewallMatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeaders: "RequestHeaders";
    readonly RequestBody: "RequestBody";
    readonly RequestCookies: "RequestCookies";
};
/**
 * Match Variable.
 */
export type WebApplicationFirewallMatchVariable = (typeof WebApplicationFirewallMatchVariable)[keyof typeof WebApplicationFirewallMatchVariable];
export declare const WebApplicationFirewallMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * The mode of the policy.
 */
export type WebApplicationFirewallMode = (typeof WebApplicationFirewallMode)[keyof typeof WebApplicationFirewallMode];
export declare const WebApplicationFirewallOperator: {
    readonly IPMatch: "IPMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly Regex: "Regex";
    readonly GeoMatch: "GeoMatch";
    readonly Any: "Any";
};
/**
 * The operator to be matched.
 */
export type WebApplicationFirewallOperator = (typeof WebApplicationFirewallOperator)[keyof typeof WebApplicationFirewallOperator];
export declare const WebApplicationFirewallRuleType: {
    readonly MatchRule: "MatchRule";
    readonly RateLimitRule: "RateLimitRule";
    readonly Invalid: "Invalid";
};
/**
 * The rule type.
 */
export type WebApplicationFirewallRuleType = (typeof WebApplicationFirewallRuleType)[keyof typeof WebApplicationFirewallRuleType];
export declare const WebApplicationFirewallScrubbingState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * State of the log scrubbing config. Default value is Enabled.
 */
export type WebApplicationFirewallScrubbingState = (typeof WebApplicationFirewallScrubbingState)[keyof typeof WebApplicationFirewallScrubbingState];
export declare const WebApplicationFirewallState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type WebApplicationFirewallState = (typeof WebApplicationFirewallState)[keyof typeof WebApplicationFirewallState];
export declare const WebApplicationFirewallTransform: {
    readonly Uppercase: "Uppercase";
    readonly Lowercase: "Lowercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
    readonly HtmlEntityDecode: "HtmlEntityDecode";
};
/**
 * Transforms applied before matching.
 */
export type WebApplicationFirewallTransform = (typeof WebApplicationFirewallTransform)[keyof typeof WebApplicationFirewallTransform];
