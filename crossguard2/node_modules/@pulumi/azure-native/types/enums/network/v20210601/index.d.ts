export declare const ActionType: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly Redirect: "Redirect";
};
/**
 * Describes the override action to be applied when rule matches.
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const BackendEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
 */
export type BackendEnabledState = (typeof BackendEnabledState)[keyof typeof BackendEnabledState];
export declare const CustomRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];
export declare const DynamicCompressionEnabled: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to use dynamic compression for cached content
 */
export type DynamicCompressionEnabled = (typeof DynamicCompressionEnabled)[keyof typeof DynamicCompressionEnabled];
export declare const EnforceCertificateNameCheckEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
 */
export type EnforceCertificateNameCheckEnabledState = (typeof EnforceCertificateNameCheckEnabledState)[keyof typeof EnforceCertificateNameCheckEnabledState];
export declare const FrontDoorEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
 */
export type FrontDoorEnabledState = (typeof FrontDoorEnabledState)[keyof typeof FrontDoorEnabledState];
export declare const FrontDoorForwardingProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export type FrontDoorForwardingProtocol = (typeof FrontDoorForwardingProtocol)[keyof typeof FrontDoorForwardingProtocol];
export declare const FrontDoorHealthProbeMethod: {
    readonly GET: "GET";
    readonly HEAD: "HEAD";
};
/**
 * Configures which HTTP method to use to probe the backends defined under backendPools.
 */
export type FrontDoorHealthProbeMethod = (typeof FrontDoorHealthProbeMethod)[keyof typeof FrontDoorHealthProbeMethod];
export declare const FrontDoorMatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeader: "RequestHeader";
    readonly RequestBody: "RequestBody";
    readonly Cookies: "Cookies";
    readonly SocketAddr: "SocketAddr";
};
/**
 * Request variable to compare with.
 */
export type FrontDoorMatchVariable = (typeof FrontDoorMatchVariable)[keyof typeof FrontDoorMatchVariable];
export declare const FrontDoorProtocol: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Accepted protocol schemes.
 */
export type FrontDoorProtocol = (typeof FrontDoorProtocol)[keyof typeof FrontDoorProtocol];
export declare const FrontDoorQuery: {
    readonly StripNone: "StripNone";
    readonly StripAll: "StripAll";
    readonly StripOnly: "StripOnly";
    readonly StripAllExcept: "StripAllExcept";
};
/**
 * Treatment of URL query terms when forming the cache key.
 */
export type FrontDoorQuery = (typeof FrontDoorQuery)[keyof typeof FrontDoorQuery];
export declare const FrontDoorRedirectProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * The protocol of the destination to where the traffic is redirected
 */
export type FrontDoorRedirectProtocol = (typeof FrontDoorRedirectProtocol)[keyof typeof FrontDoorRedirectProtocol];
export declare const FrontDoorRedirectType: {
    readonly Moved: "Moved";
    readonly Found: "Found";
    readonly TemporaryRedirect: "TemporaryRedirect";
    readonly PermanentRedirect: "PermanentRedirect";
};
/**
 * The redirect type the rule will use when redirecting traffic.
 */
export type FrontDoorRedirectType = (typeof FrontDoorRedirectType)[keyof typeof FrontDoorRedirectType];
export declare const HeaderActionType: {
    readonly Append: "Append";
    readonly Delete: "Delete";
    readonly Overwrite: "Overwrite";
};
/**
 * Which type of manipulation to apply to the header.
 */
export type HeaderActionType = (typeof HeaderActionType)[keyof typeof HeaderActionType];
export declare const HealthProbeEnabled: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
 */
export type HealthProbeEnabled = (typeof HealthProbeEnabled)[keyof typeof HealthProbeEnabled];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const ManagedRuleExclusionMatchVariable: {
    readonly RequestHeaderNames: "RequestHeaderNames";
    readonly RequestCookieNames: "RequestCookieNames";
    readonly QueryStringArgNames: "QueryStringArgNames";
    readonly RequestBodyPostArgNames: "RequestBodyPostArgNames";
    readonly RequestBodyJsonArgNames: "RequestBodyJsonArgNames";
};
/**
 * The variable type to be excluded.
 */
export type ManagedRuleExclusionMatchVariable = (typeof ManagedRuleExclusionMatchVariable)[keyof typeof ManagedRuleExclusionMatchVariable];
export declare const ManagedRuleExclusionSelectorMatchOperator: {
    readonly Equals: "Equals";
    readonly Contains: "Contains";
    readonly StartsWith: "StartsWith";
    readonly EndsWith: "EndsWith";
    readonly EqualsAny: "EqualsAny";
};
/**
 * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
 */
export type ManagedRuleExclusionSelectorMatchOperator = (typeof ManagedRuleExclusionSelectorMatchOperator)[keyof typeof ManagedRuleExclusionSelectorMatchOperator];
export declare const ManagedRuleSetActionType: {
    readonly Block: "Block";
    readonly Log: "Log";
    readonly Redirect: "Redirect";
};
/**
 * Defines the action to take when a managed rule set score threshold is met.
 */
export type ManagedRuleSetActionType = (typeof ManagedRuleSetActionType)[keyof typeof ManagedRuleSetActionType];
export declare const MatchProcessingBehavior: {
    readonly Continue: "Continue";
    readonly Stop: "Stop";
};
/**
 * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
 */
export type MatchProcessingBehavior = (typeof MatchProcessingBehavior)[keyof typeof MatchProcessingBehavior];
export declare const Operator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly RegEx: "RegEx";
};
/**
 * Comparison type to use for matching with the variable value.
 */
export type Operator = (typeof Operator)[keyof typeof Operator];
export declare const PolicyEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];
export declare const PolicyMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];
export declare const PolicyRequestBodyCheck: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if policy managed rules will inspect the request body content.
 */
export type PolicyRequestBodyCheck = (typeof PolicyRequestBodyCheck)[keyof typeof PolicyRequestBodyCheck];
export declare const RoutingRuleEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export type RoutingRuleEnabledState = (typeof RoutingRuleEnabledState)[keyof typeof RoutingRuleEnabledState];
export declare const RuleType: {
    readonly MatchRule: "MatchRule";
    readonly RateLimitRule: "RateLimitRule";
};
/**
 * Describes type of rule.
 */
export type RuleType = (typeof RuleType)[keyof typeof RuleType];
export declare const RulesEngineMatchVariable: {
    readonly IsMobile: "IsMobile";
    readonly RemoteAddr: "RemoteAddr";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestPath: "RequestPath";
    readonly RequestFilename: "RequestFilename";
    readonly RequestFilenameExtension: "RequestFilenameExtension";
    readonly RequestHeader: "RequestHeader";
    readonly RequestBody: "RequestBody";
    readonly RequestScheme: "RequestScheme";
};
/**
 * Match Variable
 */
export type RulesEngineMatchVariable = (typeof RulesEngineMatchVariable)[keyof typeof RulesEngineMatchVariable];
export declare const RulesEngineOperator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
};
/**
 * Describes operator to apply to the match condition.
 */
export type RulesEngineOperator = (typeof RulesEngineOperator)[keyof typeof RulesEngineOperator];
export declare const SessionAffinityEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
 */
export type SessionAffinityEnabledState = (typeof SessionAffinityEnabledState)[keyof typeof SessionAffinityEnabledState];
export declare const SkuName: {
    readonly Classic_AzureFrontDoor: "Classic_AzureFrontDoor";
    readonly Standard_AzureFrontDoor: "Standard_AzureFrontDoor";
    readonly Premium_AzureFrontDoor: "Premium_AzureFrontDoor";
};
/**
 * Name of the pricing tier.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const Transform: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms are applied before matching
 */
export type Transform = (typeof Transform)[keyof typeof Transform];
export declare const TransformType: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms applied before matching.
 */
export type TransformType = (typeof TransformType)[keyof typeof TransformType];
