export declare const AccessRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * Direction that specifies whether the access rules is inbound/outbound.
 */
export type AccessRuleDirection = (typeof AccessRuleDirection)[keyof typeof AccessRuleDirection];
export declare const AddressPrefixType: {
    readonly IPPrefix: "IPPrefix";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Address prefix type.
 */
export type AddressPrefixType = (typeof AddressPrefixType)[keyof typeof AddressPrefixType];
export declare const AdminRuleKind: {
    readonly Custom: "Custom";
    readonly Default: "Default";
};
/**
 * Whether the rule is custom or default.
 */
export type AdminRuleKind = (typeof AdminRuleKind)[keyof typeof AdminRuleKind];
export declare const AssociationAccessMode: {
    readonly Learning: "Learning";
    readonly Enforced: "Enforced";
    readonly Audit: "Audit";
};
/**
 * Access mode on the association.
 */
export type AssociationAccessMode = (typeof AssociationAccessMode)[keyof typeof AssociationAccessMode];
export declare const ConfigurationType: {
    readonly SecurityAdmin: "SecurityAdmin";
    readonly SecurityUser: "SecurityUser";
    readonly Connectivity: "Connectivity";
};
/**
 * Configuration Deployment Type.
 */
export type ConfigurationType = (typeof ConfigurationType)[keyof typeof ConfigurationType];
export declare const ConnectivityTopology: {
    readonly HubAndSpoke: "HubAndSpoke";
    readonly Mesh: "Mesh";
};
/**
 * Connectivity topology type.
 */
export type ConnectivityTopology = (typeof ConnectivityTopology)[keyof typeof ConnectivityTopology];
export declare const DeleteExistingPeering: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to remove current existing peerings.
 */
export type DeleteExistingPeering = (typeof DeleteExistingPeering)[keyof typeof DeleteExistingPeering];
export declare const GroupConnectivity: {
    readonly None: "None";
    readonly DirectlyConnected: "DirectlyConnected";
};
/**
 * Group connectivity type.
 */
export type GroupConnectivity = (typeof GroupConnectivity)[keyof typeof GroupConnectivity];
export declare const IsGlobal: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if global mesh is supported.
 */
export type IsGlobal = (typeof IsGlobal)[keyof typeof IsGlobal];
export declare const SecurityConfigurationRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
    readonly AlwaysAllow: "AlwaysAllow";
};
/**
 * Indicates the access allowed for this particular rule
 */
export type SecurityConfigurationRuleAccess = (typeof SecurityConfigurationRuleAccess)[keyof typeof SecurityConfigurationRuleAccess];
export declare const SecurityConfigurationRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * Indicates if the traffic matched against the rule in inbound or outbound.
 */
export type SecurityConfigurationRuleDirection = (typeof SecurityConfigurationRuleDirection)[keyof typeof SecurityConfigurationRuleDirection];
export declare const SecurityConfigurationRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Any: "Any";
    readonly Ah: "Ah";
};
/**
 * Network protocol this rule applies to.
 */
export type SecurityConfigurationRuleProtocol = (typeof SecurityConfigurationRuleProtocol)[keyof typeof SecurityConfigurationRuleProtocol];
export declare const UseHubGateway: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to use hub gateway.
 */
export type UseHubGateway = (typeof UseHubGateway)[keyof typeof UseHubGateway];
