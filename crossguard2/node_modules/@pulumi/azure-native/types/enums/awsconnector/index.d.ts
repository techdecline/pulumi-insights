import * as v20241201 from "./v20241201";
export { v20241201, };
export declare const AccelerateConfigurationAccelerationStatus: {
    /**
     * AccelerateConfigurationAccelerationStatus enum Enabled
     */
    readonly Enabled: "Enabled";
    /**
     * AccelerateConfigurationAccelerationStatus enum Suspended
     */
    readonly Suspended: "Suspended";
};
/**
 * Specifies the transfer acceleration status of the bucket.
 */
export type AccelerateConfigurationAccelerationStatus = (typeof AccelerateConfigurationAccelerationStatus)[keyof typeof AccelerateConfigurationAccelerationStatus];
export declare const AccessControl: {
    /**
     * AccessControl enum AuthenticatedRead
     */
    readonly AuthenticatedRead: "AuthenticatedRead";
    /**
     * AccessControl enum AwsExecRead
     */
    readonly AwsExecRead: "AwsExecRead";
    /**
     * AccessControl enum BucketOwnerFullControl
     */
    readonly BucketOwnerFullControl: "BucketOwnerFullControl";
    /**
     * AccessControl enum BucketOwnerRead
     */
    readonly BucketOwnerRead: "BucketOwnerRead";
    /**
     * AccessControl enum LogDeliveryWrite
     */
    readonly LogDeliveryWrite: "LogDeliveryWrite";
    /**
     * AccessControl enum Private
     */
    readonly Private: "Private";
    /**
     * AccessControl enum PublicRead
     */
    readonly PublicRead: "PublicRead";
    /**
     * AccessControl enum PublicReadWrite
     */
    readonly PublicReadWrite: "PublicReadWrite";
};
/**
 * This is a legacy property, and it is not recommended for most use cases. A majority of modern use cases in Amazon S3 no longer require the use of ACLs, and we recommend that you keep ACLs disabled. For more information, see [Controlling object ownership](https://docs.aws.amazon.com//AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.  A canned access control list (ACL) that grants predefined permissions to the bucket. For more information about canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the *Amazon S3 User Guide*.  S3 buckets are created with ACLs disabled by default. Therefore, unless you explicitly set the [AWS::S3::OwnershipControls](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html) property to enable ACLs, your resource will fail to deploy with any value other than Private. Use cases requiring ACLs are uncommon.  The majority of access control configurations can be successfully and more easily achieved with bucket policies. For more information, see [AWS::S3::BucketPolicy](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html). For examples of common policy configurations, including S3 Server Access Logs buckets and more, see [Bucket policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html) in the *Amazon S3 User Guide*.
 */
export type AccessControl = (typeof AccessControl)[keyof typeof AccessControl];
export declare const Action: {
    /**
     * Action enum ALLOW
     */
    readonly ALLOW: "ALLOW";
    /**
     * Action enum BLOCK
     */
    readonly BLOCK: "BLOCK";
    /**
     * Action enum CAPTCHA
     */
    readonly CAPTCHA: "CAPTCHA";
    /**
     * Action enum CHALLENGE
     */
    readonly CHALLENGE: "CHALLENGE";
    /**
     * Action enum COUNT
     */
    readonly COUNT: "COUNT";
    /**
     * Action enum EXCLUDED_AS_COUNT
     */
    readonly EXCLUDED_AS_COUNT: "EXCLUDED_AS_COUNT";
};
/**
 * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
 */
export type Action = (typeof Action)[keyof typeof Action];
export declare const AddOnStatus: {
    /**
     * AddOnStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * AddOnStatus enum Disabling
     */
    readonly Disabling: "Disabling";
    /**
     * AddOnStatus enum Enabled
     */
    readonly Enabled: "Enabled";
    /**
     * AddOnStatus enum Enabling
     */
    readonly Enabling: "Enabling";
    /**
     * AddOnStatus enum Failed
     */
    readonly Failed: "Failed";
    /**
     * AddOnStatus enum Terminated
     */
    readonly Terminated: "Terminated";
    /**
     * AddOnStatus enum Terminating
     */
    readonly Terminating: "Terminating";
};
/**
 * Status of the Addon
 */
export type AddOnStatus = (typeof AddOnStatus)[keyof typeof AddOnStatus];
export declare const AmdSevSnpSpecification: {
    /**
     * AmdSevSnpSpecification enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * AmdSevSnpSpecification enum enabled
     */
    readonly Enabled: "enabled";
};
/**
 * Property value
 */
export type AmdSevSnpSpecification = (typeof AmdSevSnpSpecification)[keyof typeof AmdSevSnpSpecification];
export declare const AnomalyResultEnum: {
    /**
     * AnomalyResultEnum enum anomalous
     */
    readonly Anomalous: "anomalous";
    /**
     * AnomalyResultEnum enum normal
     */
    readonly Normal: "normal";
};
/**
 * Property value
 */
export type AnomalyResultEnum = (typeof AnomalyResultEnum)[keyof typeof AnomalyResultEnum];
export declare const AppType: {
    /**
     * AppType enum Canvas
     */
    readonly Canvas: "Canvas";
    /**
     * AppType enum JupyterServer
     */
    readonly JupyterServer: "JupyterServer";
    /**
     * AppType enum KernelGateway
     */
    readonly KernelGateway: "KernelGateway";
    /**
     * AppType enum RSessionGateway
     */
    readonly RSessionGateway: "RSessionGateway";
    /**
     * AppType enum RStudioServerPro
     */
    readonly RStudioServerPro: "RStudioServerPro";
};
/**
 * The type of app.
 */
export type AppType = (typeof AppType)[keyof typeof AppType];
export declare const ArchitectureValues: {
    /**
     * ArchitectureValues enum arm64
     */
    readonly Arm64: "arm64";
    /**
     * ArchitectureValues enum arm64_mac
     */
    readonly Arm64_mac: "arm64_mac";
    /**
     * ArchitectureValues enum i386
     */
    readonly I386: "i386";
    /**
     * ArchitectureValues enum x86_64
     */
    readonly X86_64: "x86_64";
    /**
     * ArchitectureValues enum x86_64_mac
     */
    readonly X86_64_mac: "x86_64_mac";
};
/**
 * Property value
 */
export type ArchitectureValues = (typeof ArchitectureValues)[keyof typeof ArchitectureValues];
export declare const Architectures: {
    /**
     * Architectures enum arm64
     */
    readonly Arm64: "arm64";
    /**
     * Architectures enum x86_64
     */
    readonly X86_64: "x86_64";
};
/**
 * Architectures enum
 */
export type Architectures = (typeof Architectures)[keyof typeof Architectures];
export declare const ArtifactNamespace: {
    /**
     * ArtifactNamespace enum BUILD_ID
     */
    readonly BUILD_ID: "BUILD_ID";
    /**
     * ArtifactNamespace enum NONE
     */
    readonly NONE: "NONE";
};
/**
 * Property value
 */
export type ArtifactNamespace = (typeof ArtifactNamespace)[keyof typeof ArtifactNamespace];
export declare const ArtifactPackaging: {
    /**
     * ArtifactPackaging enum NONE
     */
    readonly NONE: "NONE";
    /**
     * ArtifactPackaging enum ZIP
     */
    readonly ZIP: "ZIP";
};
/**
 * Property value
 */
export type ArtifactPackaging = (typeof ArtifactPackaging)[keyof typeof ArtifactPackaging];
export declare const ArtifactsType: {
    /**
     * ArtifactsType enum CODEPIPELINE
     */
    readonly CODEPIPELINE: "CODEPIPELINE";
    /**
     * ArtifactsType enum NO_ARTIFACTS
     */
    readonly NO_ARTIFACTS: "NO_ARTIFACTS";
    /**
     * ArtifactsType enum S3
     */
    readonly S3: "S3";
};
/**
 * Property value
 */
export type ArtifactsType = (typeof ArtifactsType)[keyof typeof ArtifactsType];
export declare const AttachmentStatus: {
    /**
     * AttachmentStatus enum attached
     */
    readonly Attached: "attached";
    /**
     * AttachmentStatus enum attaching
     */
    readonly Attaching: "attaching";
    /**
     * AttachmentStatus enum detached
     */
    readonly Detached: "detached";
    /**
     * AttachmentStatus enum detaching
     */
    readonly Detaching: "detaching";
};
/**
 * Property value
 */
export type AttachmentStatus = (typeof AttachmentStatus)[keyof typeof AttachmentStatus];
export declare const AuthType: {
    /**
     * AuthType enum BASIC_AUTH
     */
    readonly BASIC_AUTH: "BASIC_AUTH";
    /**
     * AuthType enum CODECONNECTIONS
     */
    readonly CODECONNECTIONS: "CODECONNECTIONS";
    /**
     * AuthType enum OAUTH
     */
    readonly OAUTH: "OAUTH";
    /**
     * AuthType enum PERSONAL_ACCESS_TOKEN
     */
    readonly PERSONAL_ACCESS_TOKEN: "PERSONAL_ACCESS_TOKEN";
};
/**
 * Property value
 */
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
export declare const AuthenticationMode: {
    /**
     * AuthenticationMode enum API
     */
    readonly API: "API";
    /**
     * AuthenticationMode enum API_AND_CONFIG_MAP
     */
    readonly API_AND_CONFIG_MAP: "API_AND_CONFIG_MAP";
    /**
     * AuthenticationMode enum CONFIG_MAP
     */
    readonly CONFIG_MAP: "CONFIG_MAP";
};
/**
 * Property value
 */
export type AuthenticationMode = (typeof AuthenticationMode)[keyof typeof AuthenticationMode];
export declare const AuthenticationType: {
    /**
     * AuthenticationType enum AMAZON_COGNITO_USER_POOLS
     */
    readonly AMAZON_COGNITO_USER_POOLS: "AMAZON_COGNITO_USER_POOLS";
    /**
     * AuthenticationType enum API_KEY
     */
    readonly API_KEY: "API_KEY";
    /**
     * AuthenticationType enum AWS_IAM
     */
    readonly AWS_IAM: "AWS_IAM";
    /**
     * AuthenticationType enum AWS_LAMBDA
     */
    readonly AWS_LAMBDA: "AWS_LAMBDA";
    /**
     * AuthenticationType enum OPENID_CONNECT
     */
    readonly OPENID_CONNECT: "OPENID_CONNECT";
};
/**
 * Property value
 */
export type AuthenticationType = (typeof AuthenticationType)[keyof typeof AuthenticationType];
export declare const AuthorizationConfigIAM: {
    /**
     * AuthorizationConfigIAM enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * AuthorizationConfigIAM enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Determines whether to use the Amazon ECS task role defined in a task definition when mounting the Amazon EFS file system. If it is turned on, transit encryption must be turned on in the ``EFSVolumeConfiguration``. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Using Amazon EFS access points](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the *Amazon Elastic Container Service Developer Guide*.
 */
export type AuthorizationConfigIAM = (typeof AuthorizationConfigIAM)[keyof typeof AuthorizationConfigIAM];
export declare const AutoTuneState: {
    /**
     * AutoTuneState enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * AutoTuneState enum DISABLED_AND_ROLLBACK_COMPLETE
     */
    readonly DISABLED_AND_ROLLBACK_COMPLETE: "DISABLED_AND_ROLLBACK_COMPLETE";
    /**
     * AutoTuneState enum DISABLED_AND_ROLLBACK_ERROR
     */
    readonly DISABLED_AND_ROLLBACK_ERROR: "DISABLED_AND_ROLLBACK_ERROR";
    /**
     * AutoTuneState enum DISABLED_AND_ROLLBACK_IN_PROGRESS
     */
    readonly DISABLED_AND_ROLLBACK_IN_PROGRESS: "DISABLED_AND_ROLLBACK_IN_PROGRESS";
    /**
     * AutoTuneState enum DISABLED_AND_ROLLBACK_SCHEDULED
     */
    readonly DISABLED_AND_ROLLBACK_SCHEDULED: "DISABLED_AND_ROLLBACK_SCHEDULED";
    /**
     * AutoTuneState enum DISABLE_IN_PROGRESS
     */
    readonly DISABLE_IN_PROGRESS: "DISABLE_IN_PROGRESS";
    /**
     * AutoTuneState enum ENABLED
     */
    readonly ENABLED: "ENABLED";
    /**
     * AutoTuneState enum ENABLE_IN_PROGRESS
     */
    readonly ENABLE_IN_PROGRESS: "ENABLE_IN_PROGRESS";
    /**
     * AutoTuneState enum ERROR
     */
    readonly ERROR: "ERROR";
};
/**
 * Property value
 */
export type AutoTuneState = (typeof AutoTuneState)[keyof typeof AutoTuneState];
export declare const AwsVpcConfigurationAssignPublicIp: {
    /**
     * AwsVpcConfigurationAssignPublicIp enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * AwsVpcConfigurationAssignPublicIp enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Whether the task's elastic network interface receives a public IP address. The default value is ``DISABLED``.
 */
export type AwsVpcConfigurationAssignPublicIp = (typeof AwsVpcConfigurationAssignPublicIp)[keyof typeof AwsVpcConfigurationAssignPublicIp];
export declare const BackupPolicyStatus: {
    /**
     * BackupPolicyStatus enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * BackupPolicyStatus enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Set the backup policy status for the file system.  +   *ENABLED* - Turns automatic backups on for the file system.   +   *DISABLED* - Turns automatic backups off for the file system.
 */
export type BackupPolicyStatus = (typeof BackupPolicyStatus)[keyof typeof BackupPolicyStatus];
export declare const BatchReportModeType: {
    /**
     * BatchReportModeType enum REPORT_AGGREGATED_BATCH
     */
    readonly REPORT_AGGREGATED_BATCH: "REPORT_AGGREGATED_BATCH";
    /**
     * BatchReportModeType enum REPORT_INDIVIDUAL_BUILDS
     */
    readonly REPORT_INDIVIDUAL_BUILDS: "REPORT_INDIVIDUAL_BUILDS";
};
/**
 * Property value
 */
export type BatchReportModeType = (typeof BatchReportModeType)[keyof typeof BatchReportModeType];
export declare const BootModeValues: {
    /**
     * BootModeValues enum legacy-bios
     */
    readonly LegacyBios: "legacy-bios";
    /**
     * BootModeValues enum uefi
     */
    readonly Uefi: "uefi";
    /**
     * BootModeValues enum uefi-preferred
     */
    readonly UefiPreferred: "uefi-preferred";
};
/**
 * Property value
 */
export type BootModeValues = (typeof BootModeValues)[keyof typeof BootModeValues];
export declare const BucketOwnerAccess: {
    /**
     * BucketOwnerAccess enum FULL
     */
    readonly FULL: "FULL";
    /**
     * BucketOwnerAccess enum NONE
     */
    readonly NONE: "NONE";
    /**
     * BucketOwnerAccess enum READ_ONLY
     */
    readonly READ_ONLY: "READ_ONLY";
};
/**
 * Property value
 */
export type BucketOwnerAccess = (typeof BucketOwnerAccess)[keyof typeof BucketOwnerAccess];
export declare const CFNFeatureConfigurationStatus: {
    /**
     * CFNFeatureConfigurationStatus enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * CFNFeatureConfigurationStatus enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property status
 */
export type CFNFeatureConfigurationStatus = (typeof CFNFeatureConfigurationStatus)[keyof typeof CFNFeatureConfigurationStatus];
export declare const CacheMode: {
    /**
     * CacheMode enum LOCAL_CUSTOM_CACHE
     */
    readonly LOCAL_CUSTOM_CACHE: "LOCAL_CUSTOM_CACHE";
    /**
     * CacheMode enum LOCAL_DOCKER_LAYER_CACHE
     */
    readonly LOCAL_DOCKER_LAYER_CACHE: "LOCAL_DOCKER_LAYER_CACHE";
    /**
     * CacheMode enum LOCAL_SOURCE_CACHE
     */
    readonly LOCAL_SOURCE_CACHE: "LOCAL_SOURCE_CACHE";
};
/**
 * CacheMode enum
 */
export type CacheMode = (typeof CacheMode)[keyof typeof CacheMode];
export declare const CacheType: {
    /**
     * CacheType enum LOCAL
     */
    readonly LOCAL: "LOCAL";
    /**
     * CacheType enum NO_CACHE
     */
    readonly NO_CACHE: "NO_CACHE";
    /**
     * CacheType enum S3
     */
    readonly S3: "S3";
};
/**
 * Property value
 */
export type CacheType = (typeof CacheType)[keyof typeof CacheType];
export declare const CallAs: {
    /**
     * CallAs enum DELEGATED_ADMIN
     */
    readonly DELEGATED_ADMIN: "DELEGATED_ADMIN";
    /**
     * CallAs enum SELF
     */
    readonly SELF: "SELF";
};
/**
 * Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
 */
export type CallAs = (typeof CallAs)[keyof typeof CallAs];
export declare const Capabilities: {
    /**
     * Capabilities enum CAPABILITY_AUTO_EXPAND
     */
    readonly CAPABILITY_AUTO_EXPAND: "CAPABILITY_AUTO_EXPAND";
    /**
     * Capabilities enum CAPABILITY_IAM
     */
    readonly CAPABILITY_IAM: "CAPABILITY_IAM";
    /**
     * Capabilities enum CAPABILITY_NAMED_IAM
     */
    readonly CAPABILITY_NAMED_IAM: "CAPABILITY_NAMED_IAM";
};
/**
 * Capabilities enum
 */
export type Capabilities = (typeof Capabilities)[keyof typeof Capabilities];
export declare const CapacityReservationPreference: {
    /**
     * CapacityReservationPreference enum none
     */
    readonly None: "none";
    /**
     * CapacityReservationPreference enum open
     */
    readonly Open: "open";
};
/**
 * Property value
 */
export type CapacityReservationPreference = (typeof CapacityReservationPreference)[keyof typeof CapacityReservationPreference];
export declare const CertificateStatus: {
    /**
     * CertificateStatus enum EXPIRED
     */
    readonly EXPIRED: "EXPIRED";
    /**
     * CertificateStatus enum FAILED
     */
    readonly FAILED: "FAILED";
    /**
     * CertificateStatus enum INACTIVE
     */
    readonly INACTIVE: "INACTIVE";
    /**
     * CertificateStatus enum ISSUED
     */
    readonly ISSUED: "ISSUED";
    /**
     * CertificateStatus enum PENDING_VALIDATION
     */
    readonly PENDING_VALIDATION: "PENDING_VALIDATION";
    /**
     * CertificateStatus enum REVOKED
     */
    readonly REVOKED: "REVOKED";
    /**
     * CertificateStatus enum VALIDATION_TIMED_OUT
     */
    readonly VALIDATION_TIMED_OUT: "VALIDATION_TIMED_OUT";
};
/**
 * Property value
 */
export type CertificateStatus = (typeof CertificateStatus)[keyof typeof CertificateStatus];
export declare const CertificateType: {
    /**
     * CertificateType enum AMAZON_ISSUED
     */
    readonly AMAZON_ISSUED: "AMAZON_ISSUED";
    /**
     * CertificateType enum IMPORTED
     */
    readonly IMPORTED: "IMPORTED";
    /**
     * CertificateType enum PRIVATE
     */
    readonly PRIVATE: "PRIVATE";
};
/**
 * Property value
 */
export type CertificateType = (typeof CertificateType)[keyof typeof CertificateType];
export declare const ClusterEndpointEncryptionType: {
    /**
     * ClusterEndpointEncryptionType enum NONE
     */
    readonly NONE: "NONE";
    /**
     * ClusterEndpointEncryptionType enum TLS
     */
    readonly TLS: "TLS";
};
/**
 * Property value
 */
export type ClusterEndpointEncryptionType = (typeof ClusterEndpointEncryptionType)[keyof typeof ClusterEndpointEncryptionType];
export declare const ClusterIssueCode: {
    /**
     * ClusterIssueCode enum AccessDenied
     */
    readonly AccessDenied: "AccessDenied";
    /**
     * ClusterIssueCode enum ClusterUnreachable
     */
    readonly ClusterUnreachable: "ClusterUnreachable";
    /**
     * ClusterIssueCode enum ConfigurationConflict
     */
    readonly ConfigurationConflict: "ConfigurationConflict";
    /**
     * ClusterIssueCode enum Ec2SecurityGroupNotFound
     */
    readonly Ec2SecurityGroupNotFound: "Ec2SecurityGroupNotFound";
    /**
     * ClusterIssueCode enum Ec2ServiceNotSubscribed
     */
    readonly Ec2ServiceNotSubscribed: "Ec2ServiceNotSubscribed";
    /**
     * ClusterIssueCode enum Ec2SubnetNotFound
     */
    readonly Ec2SubnetNotFound: "Ec2SubnetNotFound";
    /**
     * ClusterIssueCode enum IamRoleNotFound
     */
    readonly IamRoleNotFound: "IamRoleNotFound";
    /**
     * ClusterIssueCode enum InsufficientFreeAddresses
     */
    readonly InsufficientFreeAddresses: "InsufficientFreeAddresses";
    /**
     * ClusterIssueCode enum InternalFailure
     */
    readonly InternalFailure: "InternalFailure";
    /**
     * ClusterIssueCode enum KmsGrantRevoked
     */
    readonly KmsGrantRevoked: "KmsGrantRevoked";
    /**
     * ClusterIssueCode enum KmsKeyDisabled
     */
    readonly KmsKeyDisabled: "KmsKeyDisabled";
    /**
     * ClusterIssueCode enum KmsKeyMarkedForDeletion
     */
    readonly KmsKeyMarkedForDeletion: "KmsKeyMarkedForDeletion";
    /**
     * ClusterIssueCode enum KmsKeyNotFound
     */
    readonly KmsKeyNotFound: "KmsKeyNotFound";
    /**
     * ClusterIssueCode enum Other
     */
    readonly Other: "Other";
    /**
     * ClusterIssueCode enum ResourceLimitExceeded
     */
    readonly ResourceLimitExceeded: "ResourceLimitExceeded";
    /**
     * ClusterIssueCode enum ResourceNotFound
     */
    readonly ResourceNotFound: "ResourceNotFound";
    /**
     * ClusterIssueCode enum StsRegionalEndpointDisabled
     */
    readonly StsRegionalEndpointDisabled: "StsRegionalEndpointDisabled";
    /**
     * ClusterIssueCode enum UnsupportedVersion
     */
    readonly UnsupportedVersion: "UnsupportedVersion";
    /**
     * ClusterIssueCode enum VpcNotFound
     */
    readonly VpcNotFound: "VpcNotFound";
};
/**
 * Property value
 */
export type ClusterIssueCode = (typeof ClusterIssueCode)[keyof typeof ClusterIssueCode];
export declare const ClusterState: {
    /**
     * ClusterState enum BOOTSTRAPPING
     */
    readonly BOOTSTRAPPING: "BOOTSTRAPPING";
    /**
     * ClusterState enum RUNNING
     */
    readonly RUNNING: "RUNNING";
    /**
     * ClusterState enum STARTING
     */
    readonly STARTING: "STARTING";
    /**
     * ClusterState enum TERMINATED
     */
    readonly TERMINATED: "TERMINATED";
    /**
     * ClusterState enum TERMINATED_WITH_ERRORS
     */
    readonly TERMINATED_WITH_ERRORS: "TERMINATED_WITH_ERRORS";
    /**
     * ClusterState enum TERMINATING
     */
    readonly TERMINATING: "TERMINATING";
    /**
     * ClusterState enum WAITING
     */
    readonly WAITING: "WAITING";
};
/**
 * Property value
 */
export type ClusterState = (typeof ClusterState)[keyof typeof ClusterState];
export declare const ClusterStateChangeReasonCode: {
    /**
     * ClusterStateChangeReasonCode enum ALL_STEPS_COMPLETED
     */
    readonly ALL_STEPS_COMPLETED: "ALL_STEPS_COMPLETED";
    /**
     * ClusterStateChangeReasonCode enum BOOTSTRAP_FAILURE
     */
    readonly BOOTSTRAP_FAILURE: "BOOTSTRAP_FAILURE";
    /**
     * ClusterStateChangeReasonCode enum INSTANCE_FAILURE
     */
    readonly INSTANCE_FAILURE: "INSTANCE_FAILURE";
    /**
     * ClusterStateChangeReasonCode enum INSTANCE_FLEET_TIMEOUT
     */
    readonly INSTANCE_FLEET_TIMEOUT: "INSTANCE_FLEET_TIMEOUT";
    /**
     * ClusterStateChangeReasonCode enum INTERNAL_ERROR
     */
    readonly INTERNAL_ERROR: "INTERNAL_ERROR";
    /**
     * ClusterStateChangeReasonCode enum STEP_FAILURE
     */
    readonly STEP_FAILURE: "STEP_FAILURE";
    /**
     * ClusterStateChangeReasonCode enum USER_REQUEST
     */
    readonly USER_REQUEST: "USER_REQUEST";
    /**
     * ClusterStateChangeReasonCode enum VALIDATION_ERROR
     */
    readonly VALIDATION_ERROR: "VALIDATION_ERROR";
};
/**
 * Property value
 */
export type ClusterStateChangeReasonCode = (typeof ClusterStateChangeReasonCode)[keyof typeof ClusterStateChangeReasonCode];
export declare const ClusterStatus: {
    /**
     * ClusterStatus enum ACTIVE
     */
    readonly ACTIVE: "ACTIVE";
    /**
     * ClusterStatus enum CREATING
     */
    readonly CREATING: "CREATING";
    /**
     * ClusterStatus enum DELETING
     */
    readonly DELETING: "DELETING";
    /**
     * ClusterStatus enum FAILED
     */
    readonly FAILED: "FAILED";
    /**
     * ClusterStatus enum PENDING
     */
    readonly PENDING: "PENDING";
    /**
     * ClusterStatus enum UPDATING
     */
    readonly UPDATING: "UPDATING";
};
/**
 * Property value
 */
export type ClusterStatus = (typeof ClusterStatus)[keyof typeof ClusterStatus];
export declare const ComplianceSeverity: {
    /**
     * ComplianceSeverity enum CRITICAL
     */
    readonly CRITICAL: "CRITICAL";
    /**
     * ComplianceSeverity enum HIGH
     */
    readonly HIGH: "HIGH";
    /**
     * ComplianceSeverity enum INFORMATIONAL
     */
    readonly INFORMATIONAL: "INFORMATIONAL";
    /**
     * ComplianceSeverity enum LOW
     */
    readonly LOW: "LOW";
    /**
     * ComplianceSeverity enum MEDIUM
     */
    readonly MEDIUM: "MEDIUM";
    /**
     * ComplianceSeverity enum UNSPECIFIED
     */
    readonly UNSPECIFIED: "UNSPECIFIED";
};
/**
 * Property value
 */
export type ComplianceSeverity = (typeof ComplianceSeverity)[keyof typeof ComplianceSeverity];
export declare const ComplianceStatus: {
    /**
     * ComplianceStatus enum COMPLIANT
     */
    readonly COMPLIANT: "COMPLIANT";
    /**
     * ComplianceStatus enum NON_COMPLIANT
     */
    readonly NON_COMPLIANT: "NON_COMPLIANT";
};
/**
 * Property value
 */
export type ComplianceStatus = (typeof ComplianceStatus)[keyof typeof ComplianceStatus];
export declare const ComputeType: {
    /**
     * ComputeType enum BUILD_GENERAL1_2XLARGE
     */
    readonly BUILD_GENERAL1_2XLARGE: "BUILD_GENERAL1_2XLARGE";
    /**
     * ComputeType enum BUILD_GENERAL1_LARGE
     */
    readonly BUILD_GENERAL1_LARGE: "BUILD_GENERAL1_LARGE";
    /**
     * ComputeType enum BUILD_GENERAL1_MEDIUM
     */
    readonly BUILD_GENERAL1_MEDIUM: "BUILD_GENERAL1_MEDIUM";
    /**
     * ComputeType enum BUILD_GENERAL1_SMALL
     */
    readonly BUILD_GENERAL1_SMALL: "BUILD_GENERAL1_SMALL";
    /**
     * ComputeType enum BUILD_GENERAL1_XLARGE
     */
    readonly BUILD_GENERAL1_XLARGE: "BUILD_GENERAL1_XLARGE";
    /**
     * ComputeType enum BUILD_LAMBDA_10GB
     */
    readonly BUILD_LAMBDA_10GB: "BUILD_LAMBDA_10GB";
    /**
     * ComputeType enum BUILD_LAMBDA_1GB
     */
    readonly BUILD_LAMBDA_1GB: "BUILD_LAMBDA_1GB";
    /**
     * ComputeType enum BUILD_LAMBDA_2GB
     */
    readonly BUILD_LAMBDA_2GB: "BUILD_LAMBDA_2GB";
    /**
     * ComputeType enum BUILD_LAMBDA_4GB
     */
    readonly BUILD_LAMBDA_4GB: "BUILD_LAMBDA_4GB";
    /**
     * ComputeType enum BUILD_LAMBDA_8GB
     */
    readonly BUILD_LAMBDA_8GB: "BUILD_LAMBDA_8GB";
};
/**
 * Property value
 */
export type ComputeType = (typeof ComputeType)[keyof typeof ComputeType];
export declare const ConfigChangeStatus: {
    /**
     * ConfigChangeStatus enum ApplyingChanges
     */
    readonly ApplyingChanges: "ApplyingChanges";
    /**
     * ConfigChangeStatus enum Cancelled
     */
    readonly Cancelled: "Cancelled";
    /**
     * ConfigChangeStatus enum Completed
     */
    readonly Completed: "Completed";
    /**
     * ConfigChangeStatus enum Initializing
     */
    readonly Initializing: "Initializing";
    /**
     * ConfigChangeStatus enum Pending
     */
    readonly Pending: "Pending";
    /**
     * ConfigChangeStatus enum PendingUserInput
     */
    readonly PendingUserInput: "PendingUserInput";
    /**
     * ConfigChangeStatus enum Validating
     */
    readonly Validating: "Validating";
    /**
     * ConfigChangeStatus enum ValidationFailed
     */
    readonly ValidationFailed: "ValidationFailed";
};
/**
 * Property value
 */
export type ConfigChangeStatus = (typeof ConfigChangeStatus)[keyof typeof ConfigChangeStatus];
export declare const ContinuousBackupsStatus: {
    /**
     * ContinuousBackupsStatus enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * ContinuousBackupsStatus enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property value
 */
export type ContinuousBackupsStatus = (typeof ContinuousBackupsStatus)[keyof typeof ContinuousBackupsStatus];
export declare const CorsRuleAllowedMethods: {
    /**
     * CorsRuleAllowedMethods enum DELETE
     */
    readonly DELETE: "DELETE";
    /**
     * CorsRuleAllowedMethods enum GET
     */
    readonly GET: "GET";
    /**
     * CorsRuleAllowedMethods enum HEAD
     */
    readonly HEAD: "HEAD";
    /**
     * CorsRuleAllowedMethods enum POST
     */
    readonly POST: "POST";
    /**
     * CorsRuleAllowedMethods enum PUT
     */
    readonly PUT: "PUT";
};
/**
 * CorsRuleAllowedMethods enum
 */
export type CorsRuleAllowedMethods = (typeof CorsRuleAllowedMethods)[keyof typeof CorsRuleAllowedMethods];
export declare const CredentialProviderType: {
    /**
     * CredentialProviderType enum SECRETS_MANAGER
     */
    readonly SECRETS_MANAGER: "SECRETS_MANAGER";
};
/**
 * Property value
 */
export type CredentialProviderType = (typeof CredentialProviderType)[keyof typeof CredentialProviderType];
export declare const DataSourceLevelMetricsBehavior: {
    /**
     * DataSourceLevelMetricsBehavior enum FULL_REQUEST_DATA_SOURCE_METRICS
     */
    readonly FULL_REQUEST_DATA_SOURCE_METRICS: "FULL_REQUEST_DATA_SOURCE_METRICS";
    /**
     * DataSourceLevelMetricsBehavior enum PER_DATA_SOURCE_METRICS
     */
    readonly PER_DATA_SOURCE_METRICS: "PER_DATA_SOURCE_METRICS";
};
/**
 * Property value
 */
export type DataSourceLevelMetricsBehavior = (typeof DataSourceLevelMetricsBehavior)[keyof typeof DataSourceLevelMetricsBehavior];
export declare const DataType: {
    /**
     * DataType enum aws:ec2:image
     */
    readonly AwsEc2Image: "aws:ec2:image";
    /**
     * DataType enum text
     */
    readonly Text: "text";
};
/**
 * The data type of the parameter, such as ``text`` or ``aws:ec2:image``. The default is ``text``.
 */
export type DataType = (typeof DataType)[keyof typeof DataType];
export declare const DefaultAction: {
    /**
     * DefaultAction enum ALLOW
     */
    readonly ALLOW: "ALLOW";
    /**
     * DefaultAction enum DENY
     */
    readonly DENY: "DENY";
};
/**
 * Property value
 */
export type DefaultAction = (typeof DefaultAction)[keyof typeof DefaultAction];
export declare const DefaultBehavior: {
    /**
     * DefaultBehavior enum DROP
     */
    readonly DROP: "DROP";
    /**
     * DefaultBehavior enum KEEP
     */
    readonly KEEP: "KEEP";
};
/**
 * Default handling for logs that don't match any of the specified filtering conditions.
 */
export type DefaultBehavior = (typeof DefaultBehavior)[keyof typeof DefaultBehavior];
export declare const DefaultRetentionMode: {
    /**
     * DefaultRetentionMode enum COMPLIANCE
     */
    readonly COMPLIANCE: "COMPLIANCE";
    /**
     * DefaultRetentionMode enum GOVERNANCE
     */
    readonly GOVERNANCE: "GOVERNANCE";
};
/**
 * The default Object Lock retention mode you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
 */
export type DefaultRetentionMode = (typeof DefaultRetentionMode)[keyof typeof DefaultRetentionMode];
export declare const DeleteMarkerReplicationStatus: {
    /**
     * DeleteMarkerReplicationStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * DeleteMarkerReplicationStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Indicates whether to replicate delete markers. Disabled by default.
 */
export type DeleteMarkerReplicationStatus = (typeof DeleteMarkerReplicationStatus)[keyof typeof DeleteMarkerReplicationStatus];
export declare const DeploymentControllerType: {
    /**
     * DeploymentControllerType enum CODE_DEPLOY
     */
    readonly CODE_DEPLOY: "CODE_DEPLOY";
    /**
     * DeploymentControllerType enum ECS
     */
    readonly ECS: "ECS";
    /**
     * DeploymentControllerType enum EXTERNAL
     */
    readonly EXTERNAL: "EXTERNAL";
};
/**
 * The deployment controller type to use. There are three deployment controller types available:  + ECS The rolling update (ECS) deployment type involves replacing the current running version of the container with the latest version. The number of containers Amazon ECS adds or removes from the service during a rolling update is controlled by adjusting the minimum and maximum number of healthy tasks allowed during a service deployment, as specified in the DeploymentConfiguration. + CODE_DEPLOY The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model powered by , which allows you to verify a new deployment of a service before sending production traffic to it. + EXTERNAL The external (EXTERNAL) deployment type enables you to use any third-party deployment controller for full control over the deployment process for an Amazon ECS service.
 */
export type DeploymentControllerType = (typeof DeploymentControllerType)[keyof typeof DeploymentControllerType];
export declare const DeploymentStatus: {
    /**
     * DeploymentStatus enum COMPLETED
     */
    readonly COMPLETED: "COMPLETED";
    /**
     * DeploymentStatus enum ELIGIBLE
     */
    readonly ELIGIBLE: "ELIGIBLE";
    /**
     * DeploymentStatus enum IN_PROGRESS
     */
    readonly IN_PROGRESS: "IN_PROGRESS";
    /**
     * DeploymentStatus enum NOT_ELIGIBLE
     */
    readonly NOT_ELIGIBLE: "NOT_ELIGIBLE";
    /**
     * DeploymentStatus enum PENDING_UPDATE
     */
    readonly PENDING_UPDATE: "PENDING_UPDATE";
};
/**
 * Property value
 */
export type DeploymentStatus = (typeof DeploymentStatus)[keyof typeof DeploymentStatus];
export declare const DeploymentTargetsAccountFilterType: {
    /**
     * DeploymentTargetsAccountFilterType enum DIFFERENCE
     */
    readonly DIFFERENCE: "DIFFERENCE";
    /**
     * DeploymentTargetsAccountFilterType enum INTERSECTION
     */
    readonly INTERSECTION: "INTERSECTION";
    /**
     * DeploymentTargetsAccountFilterType enum NONE
     */
    readonly NONE: "NONE";
    /**
     * DeploymentTargetsAccountFilterType enum UNION
     */
    readonly UNION: "UNION";
};
/**
 * The filter type you want to apply on organizational units and accounts.
 */
export type DeploymentTargetsAccountFilterType = (typeof DeploymentTargetsAccountFilterType)[keyof typeof DeploymentTargetsAccountFilterType];
export declare const DestinationFormat: {
    /**
     * DestinationFormat enum CSV
     */
    readonly CSV: "CSV";
    /**
     * DestinationFormat enum ORC
     */
    readonly ORC: "ORC";
    /**
     * DestinationFormat enum Parquet
     */
    readonly Parquet: "Parquet";
};
/**
 * Specifies the file format used when exporting data to Amazon S3.  *Allowed values*: ``CSV`` | ``ORC`` | ``Parquet``
 */
export type DestinationFormat = (typeof DestinationFormat)[keyof typeof DestinationFormat];
export declare const DeviceType: {
    /**
     * DeviceType enum ebs
     */
    readonly Ebs: "ebs";
    /**
     * DeviceType enum instance-store
     */
    readonly InstanceStore: "instance-store";
};
/**
 * Property value
 */
export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType];
export declare const Distribution: {
    /**
     * Distribution enum ByLogStream
     */
    readonly ByLogStream: "ByLogStream";
    /**
     * Distribution enum Random
     */
    readonly Random: "Random";
};
/**
 * The method used to distribute log data to the destination, which can be either random or grouped by log stream.
 */
export type Distribution = (typeof Distribution)[keyof typeof Distribution];
export declare const DomainProcessingStatusType: {
    /**
     * DomainProcessingStatusType enum Active
     */
    readonly Active: "Active";
    /**
     * DomainProcessingStatusType enum Creating
     */
    readonly Creating: "Creating";
    /**
     * DomainProcessingStatusType enum Deleting
     */
    readonly Deleting: "Deleting";
    /**
     * DomainProcessingStatusType enum Isolated
     */
    readonly Isolated: "Isolated";
    /**
     * DomainProcessingStatusType enum Modifying
     */
    readonly Modifying: "Modifying";
    /**
     * DomainProcessingStatusType enum UpdatingServiceSoftware
     */
    readonly UpdatingServiceSoftware: "UpdatingServiceSoftware";
    /**
     * DomainProcessingStatusType enum UpgradingEngineVersion
     */
    readonly UpgradingEngineVersion: "UpgradingEngineVersion";
};
/**
 * Property value
 */
export type DomainProcessingStatusType = (typeof DomainProcessingStatusType)[keyof typeof DomainProcessingStatusType];
export declare const DomainType: {
    /**
     * DomainType enum standard
     */
    readonly Standard: "standard";
    /**
     * DomainType enum vpc
     */
    readonly Vpc: "vpc";
};
/**
 * Property value
 */
export type DomainType = (typeof DomainType)[keyof typeof DomainType];
export declare const EBSTagSpecificationPropagateTags: {
    /**
     * EBSTagSpecificationPropagateTags enum SERVICE
     */
    readonly SERVICE: "SERVICE";
    /**
     * EBSTagSpecificationPropagateTags enum TASK_DEFINITION
     */
    readonly TASK_DEFINITION: "TASK_DEFINITION";
};
/**
 * Determines whether to propagate the tags from the task definition to the Amazon EBS volume. Tags can only propagate to a ``SERVICE`` specified in ``ServiceVolumeConfiguration``. If no value is specified, the tags aren't propagated.
 */
export type EBSTagSpecificationPropagateTags = (typeof EBSTagSpecificationPropagateTags)[keyof typeof EBSTagSpecificationPropagateTags];
export declare const EFSVolumeConfigurationTransitEncryption: {
    /**
     * EFSVolumeConfigurationTransitEncryption enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * EFSVolumeConfigurationTransitEncryption enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Determines whether to use encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be turned on if Amazon EFS IAM authorization is used. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Encrypting data in transit](https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html) in the *Amazon Elastic File System User Guide*.
 */
export type EFSVolumeConfigurationTransitEncryption = (typeof EFSVolumeConfigurationTransitEncryption)[keyof typeof EFSVolumeConfigurationTransitEncryption];
export declare const EncryptionConfigurationEncryptionType: {
    /**
     * EncryptionConfigurationEncryptionType enum AES256
     */
    readonly AES256: "AES256";
    /**
     * EncryptionConfigurationEncryptionType enum KMS
     */
    readonly KMS: "KMS";
};
/**
 * The encryption type to use. If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see [Protecting data using server-side encryption with an key stored in (SSE-KMS)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html) in the *Amazon Simple Storage Service Console Developer Guide*. If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see [Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) in the *Ama The encryption type to use.
 */
export type EncryptionConfigurationEncryptionType = (typeof EncryptionConfigurationEncryptionType)[keyof typeof EncryptionConfigurationEncryptionType];
export declare const EnvironmentType: {
    /**
     * EnvironmentType enum ARM_CONTAINER
     */
    readonly ARM_CONTAINER: "ARM_CONTAINER";
    /**
     * EnvironmentType enum ARM_LAMBDA_CONTAINER
     */
    readonly ARM_LAMBDA_CONTAINER: "ARM_LAMBDA_CONTAINER";
    /**
     * EnvironmentType enum LINUX_CONTAINER
     */
    readonly LINUX_CONTAINER: "LINUX_CONTAINER";
    /**
     * EnvironmentType enum LINUX_GPU_CONTAINER
     */
    readonly LINUX_GPU_CONTAINER: "LINUX_GPU_CONTAINER";
    /**
     * EnvironmentType enum LINUX_LAMBDA_CONTAINER
     */
    readonly LINUX_LAMBDA_CONTAINER: "LINUX_LAMBDA_CONTAINER";
    /**
     * EnvironmentType enum WINDOWS_CONTAINER
     */
    readonly WINDOWS_CONTAINER: "WINDOWS_CONTAINER";
    /**
     * EnvironmentType enum WINDOWS_SERVER_2019_CONTAINER
     */
    readonly WINDOWS_SERVER_2019_CONTAINER: "WINDOWS_SERVER_2019_CONTAINER";
};
/**
 * Property value
 */
export type EnvironmentType = (typeof EnvironmentType)[keyof typeof EnvironmentType];
export declare const EnvironmentVariableType: {
    /**
     * EnvironmentVariableType enum PARAMETER_STORE
     */
    readonly PARAMETER_STORE: "PARAMETER_STORE";
    /**
     * EnvironmentVariableType enum PLAINTEXT
     */
    readonly PLAINTEXT: "PLAINTEXT";
    /**
     * EnvironmentVariableType enum SECRETS_MANAGER
     */
    readonly SECRETS_MANAGER: "SECRETS_MANAGER";
};
/**
 * Property value
 */
export type EnvironmentVariableType = (typeof EnvironmentVariableType)[keyof typeof EnvironmentVariableType];
export declare const EventCode: {
    /**
     * EventCode enum instance-reboot
     */
    readonly InstanceReboot: "instance-reboot";
    /**
     * EventCode enum instance-retirement
     */
    readonly InstanceRetirement: "instance-retirement";
    /**
     * EventCode enum instance-stop
     */
    readonly InstanceStop: "instance-stop";
    /**
     * EventCode enum system-maintenance
     */
    readonly SystemMaintenance: "system-maintenance";
    /**
     * EventCode enum system-reboot
     */
    readonly SystemReboot: "system-reboot";
};
/**
 * Property value
 */
export type EventCode = (typeof EventCode)[keyof typeof EventCode];
export declare const EventSelectorReadWriteType: {
    /**
     * EventSelectorReadWriteType enum All
     */
    readonly All: "All";
    /**
     * EventSelectorReadWriteType enum ReadOnly
     */
    readonly ReadOnly: "ReadOnly";
    /**
     * EventSelectorReadWriteType enum WriteOnly
     */
    readonly WriteOnly: "WriteOnly";
};
/**
 * Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
 */
export type EventSelectorReadWriteType = (typeof EventSelectorReadWriteType)[keyof typeof EventSelectorReadWriteType];
export declare const ExportSourceType: {
    /**
     * ExportSourceType enum CLUSTER
     */
    readonly CLUSTER: "CLUSTER";
    /**
     * ExportSourceType enum SNAPSHOT
     */
    readonly SNAPSHOT: "SNAPSHOT";
};
/**
 * Property value
 */
export type ExportSourceType = (typeof ExportSourceType)[keyof typeof ExportSourceType];
export declare const ExtendedKeyUsageName: {
    /**
     * ExtendedKeyUsageName enum ANY
     */
    readonly ANY: "ANY";
    /**
     * ExtendedKeyUsageName enum CODE_SIGNING
     */
    readonly CODE_SIGNING: "CODE_SIGNING";
    /**
     * ExtendedKeyUsageName enum CUSTOM
     */
    readonly CUSTOM: "CUSTOM";
    /**
     * ExtendedKeyUsageName enum EMAIL_PROTECTION
     */
    readonly EMAIL_PROTECTION: "EMAIL_PROTECTION";
    /**
     * ExtendedKeyUsageName enum IPSEC_END_SYSTEM
     */
    readonly IPSEC_END_SYSTEM: "IPSEC_END_SYSTEM";
    /**
     * ExtendedKeyUsageName enum IPSEC_TUNNEL
     */
    readonly IPSEC_TUNNEL: "IPSEC_TUNNEL";
    /**
     * ExtendedKeyUsageName enum IPSEC_USER
     */
    readonly IPSEC_USER: "IPSEC_USER";
    /**
     * ExtendedKeyUsageName enum NONE
     */
    readonly NONE: "NONE";
    /**
     * ExtendedKeyUsageName enum OCSP_SIGNING
     */
    readonly OCSP_SIGNING: "OCSP_SIGNING";
    /**
     * ExtendedKeyUsageName enum TIME_STAMPING
     */
    readonly TIME_STAMPING: "TIME_STAMPING";
    /**
     * ExtendedKeyUsageName enum TLS_WEB_CLIENT_AUTHENTICATION
     */
    readonly TLS_WEB_CLIENT_AUTHENTICATION: "TLS_WEB_CLIENT_AUTHENTICATION";
    /**
     * ExtendedKeyUsageName enum TLS_WEB_SERVER_AUTHENTICATION
     */
    readonly TLS_WEB_SERVER_AUTHENTICATION: "TLS_WEB_SERVER_AUTHENTICATION";
};
/**
 * ExtendedKeyUsageName enum
 */
export type ExtendedKeyUsageName = (typeof ExtendedKeyUsageName)[keyof typeof ExtendedKeyUsageName];
export declare const FeatureSet: {
    /**
     * FeatureSet enum ALL
     */
    readonly ALL: "ALL";
    /**
     * FeatureSet enum CONSOLIDATED_BILLING
     */
    readonly CONSOLIDATED_BILLING: "CONSOLIDATED_BILLING";
};
/**
 * Specifies the feature set supported by the new organization. Each feature set supports different levels of functionality.
 */
export type FeatureSet = (typeof FeatureSet)[keyof typeof FeatureSet];
export declare const FieldLogLevel: {
    /**
     * FieldLogLevel enum ALL
     */
    readonly ALL: "ALL";
    /**
     * FieldLogLevel enum ERROR
     */
    readonly ERROR: "ERROR";
    /**
     * FieldLogLevel enum NONE
     */
    readonly NONE: "NONE";
};
/**
 * Property value
 */
export type FieldLogLevel = (typeof FieldLogLevel)[keyof typeof FieldLogLevel];
export declare const FileFormat: {
    /**
     * FileFormat enum parquet
     */
    readonly Parquet: "parquet";
    /**
     * FileFormat enum plain-text
     */
    readonly PlainText: "plain-text";
};
/**
 * Property fileFormat
 */
export type FileFormat = (typeof FileFormat)[keyof typeof FileFormat];
export declare const FileSystemProtectionReplicationOverwriteProtection: {
    /**
     * FileSystemProtectionReplicationOverwriteProtection enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * FileSystemProtectionReplicationOverwriteProtection enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * The status of the file system's replication overwrite protection.  +   ``ENABLED`` – The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ``ENABLED`` by default.   +   ``DISABLED`` – The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.  +   ``REPLICATING`` – The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled, the file system becomes writeable.
 */
export type FileSystemProtectionReplicationOverwriteProtection = (typeof FileSystemProtectionReplicationOverwriteProtection)[keyof typeof FileSystemProtectionReplicationOverwriteProtection];
export declare const FileSystemType: {
    /**
     * FileSystemType enum EFS
     */
    readonly EFS: "EFS";
};
/**
 * Property value
 */
export type FileSystemType = (typeof FileSystemType)[keyof typeof FileSystemType];
export declare const FilterBehavior: {
    /**
     * FilterBehavior enum DROP
     */
    readonly DROP: "DROP";
    /**
     * FilterBehavior enum KEEP
     */
    readonly KEEP: "KEEP";
};
/**
 * How to handle logs that satisfy the filter's conditions and requirement.
 */
export type FilterBehavior = (typeof FilterBehavior)[keyof typeof FilterBehavior];
export declare const FilterRequirement: {
    /**
     * FilterRequirement enum MEETS_ALL
     */
    readonly MEETS_ALL: "MEETS_ALL";
    /**
     * FilterRequirement enum MEETS_ANY
     */
    readonly MEETS_ANY: "MEETS_ANY";
};
/**
 * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
 */
export type FilterRequirement = (typeof FilterRequirement)[keyof typeof FilterRequirement];
export declare const GraphQLApiIntrospectionConfig: {
    /**
     * GraphQLApiIntrospectionConfig enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * GraphQLApiIntrospectionConfig enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property value
 */
export type GraphQLApiIntrospectionConfig = (typeof GraphQLApiIntrospectionConfig)[keyof typeof GraphQLApiIntrospectionConfig];
export declare const GraphQLApiType: {
    /**
     * GraphQLApiType enum GRAPHQL
     */
    readonly GRAPHQL: "GRAPHQL";
    /**
     * GraphQLApiType enum MERGED
     */
    readonly MERGED: "MERGED";
};
/**
 * Property value
 */
export type GraphQLApiType = (typeof GraphQLApiType)[keyof typeof GraphQLApiType];
export declare const GraphQLApiVisibility: {
    /**
     * GraphQLApiVisibility enum GLOBAL
     */
    readonly GLOBAL: "GLOBAL";
    /**
     * GraphQLApiVisibility enum PRIVATE
     */
    readonly PRIVATE: "PRIVATE";
};
/**
 * Property value
 */
export type GraphQLApiVisibility = (typeof GraphQLApiVisibility)[keyof typeof GraphQLApiVisibility];
export declare const HeaderDirection: {
    /**
     * HeaderDirection enum ANY
     */
    readonly ANY: "ANY";
    /**
     * HeaderDirection enum FORWARD
     */
    readonly FORWARD: "FORWARD";
};
/**
 * Property direction
 */
export type HeaderDirection = (typeof HeaderDirection)[keyof typeof HeaderDirection];
export declare const HeaderProtocol: {
    /**
     * HeaderProtocol enum DCERPC
     */
    readonly DCERPC: "DCERPC";
    /**
     * HeaderProtocol enum DHCP
     */
    readonly DHCP: "DHCP";
    /**
     * HeaderProtocol enum DNS
     */
    readonly DNS: "DNS";
    /**
     * HeaderProtocol enum FTP
     */
    readonly FTP: "FTP";
    /**
     * HeaderProtocol enum HTTP
     */
    readonly HTTP: "HTTP";
    /**
     * HeaderProtocol enum ICMP
     */
    readonly ICMP: "ICMP";
    /**
     * HeaderProtocol enum IKEV2
     */
    readonly IKEV2: "IKEV2";
    /**
     * HeaderProtocol enum IMAP
     */
    readonly IMAP: "IMAP";
    /**
     * HeaderProtocol enum IP
     */
    readonly IP: "IP";
    /**
     * HeaderProtocol enum KRB5
     */
    readonly KRB5: "KRB5";
    /**
     * HeaderProtocol enum MSN
     */
    readonly MSN: "MSN";
    /**
     * HeaderProtocol enum NTP
     */
    readonly NTP: "NTP";
    /**
     * HeaderProtocol enum SMB
     */
    readonly SMB: "SMB";
    /**
     * HeaderProtocol enum SMTP
     */
    readonly SMTP: "SMTP";
    /**
     * HeaderProtocol enum SSH
     */
    readonly SSH: "SSH";
    /**
     * HeaderProtocol enum TCP
     */
    readonly TCP: "TCP";
    /**
     * HeaderProtocol enum TFTP
     */
    readonly TFTP: "TFTP";
    /**
     * HeaderProtocol enum TLS
     */
    readonly TLS: "TLS";
    /**
     * HeaderProtocol enum UDP
     */
    readonly UDP: "UDP";
};
/**
 * Property protocol
 */
export type HeaderProtocol = (typeof HeaderProtocol)[keyof typeof HeaderProtocol];
export declare const HostnameType: {
    /**
     * HostnameType enum ip-name
     */
    readonly IpName: "ip-name";
    /**
     * HostnameType enum resource-name
     */
    readonly ResourceName: "resource-name";
};
/**
 * Property value
 */
export type HostnameType = (typeof HostnameType)[keyof typeof HostnameType];
export declare const HttpTokensState: {
    /**
     * HttpTokensState enum optional
     */
    readonly Optional: "optional";
    /**
     * HttpTokensState enum required
     */
    readonly Required: "required";
};
/**
 * Property value
 */
export type HttpTokensState = (typeof HttpTokensState)[keyof typeof HttpTokensState];
export declare const HypervisorType: {
    /**
     * HypervisorType enum ovm
     */
    readonly Ovm: "ovm";
    /**
     * HypervisorType enum xen
     */
    readonly Xen: "xen";
};
/**
 * Property value
 */
export type HypervisorType = (typeof HypervisorType)[keyof typeof HypervisorType];
export declare const IPAddressType: {
    /**
     * IPAddressType enum dualstack
     */
    readonly Dualstack: "dualstack";
    /**
     * IPAddressType enum ipv4
     */
    readonly Ipv4: "ipv4";
};
/**
 * Property value
 */
export type IPAddressType = (typeof IPAddressType)[keyof typeof IPAddressType];
export declare const ImagePullCredentialsType: {
    /**
     * ImagePullCredentialsType enum CODEBUILD
     */
    readonly CODEBUILD: "CODEBUILD";
    /**
     * ImagePullCredentialsType enum SERVICE_ROLE
     */
    readonly SERVICE_ROLE: "SERVICE_ROLE";
};
/**
 * Property value
 */
export type ImagePullCredentialsType = (typeof ImagePullCredentialsType)[keyof typeof ImagePullCredentialsType];
export declare const ImageState: {
    /**
     * ImageState enum available
     */
    readonly Available: "available";
    /**
     * ImageState enum deregistered
     */
    readonly Deregistered: "deregistered";
    /**
     * ImageState enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * ImageState enum error
     */
    readonly Error: "error";
    /**
     * ImageState enum failed
     */
    readonly Failed: "failed";
    /**
     * ImageState enum invalid
     */
    readonly Invalid: "invalid";
    /**
     * ImageState enum pending
     */
    readonly Pending: "pending";
    /**
     * ImageState enum transient
     */
    readonly Transient: "transient";
};
/**
 * Property value
 */
export type ImageState = (typeof ImageState)[keyof typeof ImageState];
export declare const ImageTagMutability: {
    /**
     * ImageTagMutability enum IMMUTABLE
     */
    readonly IMMUTABLE: "IMMUTABLE";
    /**
     * ImageTagMutability enum MUTABLE
     */
    readonly MUTABLE: "MUTABLE";
};
/**
 * The tag mutability setting for the repository. If this parameter is omitted, the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE`` is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
 */
export type ImageTagMutability = (typeof ImageTagMutability)[keyof typeof ImageTagMutability];
export declare const ImageTypeValues: {
    /**
     * ImageTypeValues enum kernel
     */
    readonly Kernel: "kernel";
    /**
     * ImageTypeValues enum machine
     */
    readonly Machine: "machine";
    /**
     * ImageTypeValues enum ramdisk
     */
    readonly Ramdisk: "ramdisk";
};
/**
 * Property value
 */
export type ImageTypeValues = (typeof ImageTypeValues)[keyof typeof ImageTypeValues];
export declare const ImdsSupportValues: {
    /**
     * ImdsSupportValues enum v2.0
     */
    readonly V20: "v2.0";
};
/**
 * Property value
 */
export type ImdsSupportValues = (typeof ImdsSupportValues)[keyof typeof ImdsSupportValues];
export declare const InitiatedBy: {
    /**
     * InitiatedBy enum CUSTOMER
     */
    readonly CUSTOMER: "CUSTOMER";
    /**
     * InitiatedBy enum SERVICE
     */
    readonly SERVICE: "SERVICE";
};
/**
 * Property value
 */
export type InitiatedBy = (typeof InitiatedBy)[keyof typeof InitiatedBy];
export declare const InstanceAutoRecoveryState: {
    /**
     * InstanceAutoRecoveryState enum default
     */
    readonly Default: "default";
    /**
     * InstanceAutoRecoveryState enum disabled
     */
    readonly Disabled: "disabled";
};
/**
 * Property value
 */
export type InstanceAutoRecoveryState = (typeof InstanceAutoRecoveryState)[keyof typeof InstanceAutoRecoveryState];
export declare const InstanceBootModeValues: {
    /**
     * InstanceBootModeValues enum legacy-bios
     */
    readonly LegacyBios: "legacy-bios";
    /**
     * InstanceBootModeValues enum uefi
     */
    readonly Uefi: "uefi";
};
/**
 * Property value
 */
export type InstanceBootModeValues = (typeof InstanceBootModeValues)[keyof typeof InstanceBootModeValues];
export declare const InstanceCollectionType: {
    /**
     * InstanceCollectionType enum INSTANCE_FLEET
     */
    readonly INSTANCE_FLEET: "INSTANCE_FLEET";
    /**
     * InstanceCollectionType enum INSTANCE_GROUP
     */
    readonly INSTANCE_GROUP: "INSTANCE_GROUP";
};
/**
 * Property value
 */
export type InstanceCollectionType = (typeof InstanceCollectionType)[keyof typeof InstanceCollectionType];
export declare const InstanceLifecycleType: {
    /**
     * InstanceLifecycleType enum capacity-block
     */
    readonly CapacityBlock: "capacity-block";
    /**
     * InstanceLifecycleType enum scheduled
     */
    readonly Scheduled: "scheduled";
    /**
     * InstanceLifecycleType enum spot
     */
    readonly Spot: "spot";
};
/**
 * Property value
 */
export type InstanceLifecycleType = (typeof InstanceLifecycleType)[keyof typeof InstanceLifecycleType];
export declare const InstanceMetadataEndpointState: {
    /**
     * InstanceMetadataEndpointState enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * InstanceMetadataEndpointState enum enabled
     */
    readonly Enabled: "enabled";
};
/**
 * Property value
 */
export type InstanceMetadataEndpointState = (typeof InstanceMetadataEndpointState)[keyof typeof InstanceMetadataEndpointState];
export declare const InstanceMetadataOptionsState: {
    /**
     * InstanceMetadataOptionsState enum applied
     */
    readonly Applied: "applied";
    /**
     * InstanceMetadataOptionsState enum pending
     */
    readonly Pending: "pending";
};
/**
 * Property value
 */
export type InstanceMetadataOptionsState = (typeof InstanceMetadataOptionsState)[keyof typeof InstanceMetadataOptionsState];
export declare const InstanceMetadataProtocolState: {
    /**
     * InstanceMetadataProtocolState enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * InstanceMetadataProtocolState enum enabled
     */
    readonly Enabled: "enabled";
};
/**
 * Property value
 */
export type InstanceMetadataProtocolState = (typeof InstanceMetadataProtocolState)[keyof typeof InstanceMetadataProtocolState];
export declare const InstanceMetadataTagsState: {
    /**
     * InstanceMetadataTagsState enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * InstanceMetadataTagsState enum enabled
     */
    readonly Enabled: "enabled";
};
/**
 * Property value
 */
export type InstanceMetadataTagsState = (typeof InstanceMetadataTagsState)[keyof typeof InstanceMetadataTagsState];
export declare const InstanceRoleType: {
    /**
     * InstanceRoleType enum CORE
     */
    readonly CORE: "CORE";
    /**
     * InstanceRoleType enum MASTER
     */
    readonly MASTER: "MASTER";
    /**
     * InstanceRoleType enum TASK
     */
    readonly TASK: "TASK";
};
/**
 * Property value
 */
export type InstanceRoleType = (typeof InstanceRoleType)[keyof typeof InstanceRoleType];
export declare const InstanceStateName: {
    /**
     * InstanceStateName enum pending
     */
    readonly Pending: "pending";
    /**
     * InstanceStateName enum running
     */
    readonly Running: "running";
    /**
     * InstanceStateName enum shutting-down
     */
    readonly ShuttingDown: "shutting-down";
    /**
     * InstanceStateName enum stopped
     */
    readonly Stopped: "stopped";
    /**
     * InstanceStateName enum stopping
     */
    readonly Stopping: "stopping";
    /**
     * InstanceStateName enum terminated
     */
    readonly Terminated: "terminated";
};
/**
 * Property value
 */
export type InstanceStateName = (typeof InstanceStateName)[keyof typeof InstanceStateName];
export declare const InstanceType: {
    /**
     * InstanceType enum ml.c4.2xlarge
     */
    readonly MlC42xlarge: "ml.c4.2xlarge";
    /**
     * InstanceType enum ml.c4.4xlarge
     */
    readonly MlC44xlarge: "ml.c4.4xlarge";
    /**
     * InstanceType enum ml.c4.8xlarge
     */
    readonly MlC48xlarge: "ml.c4.8xlarge";
    /**
     * InstanceType enum ml.c4.xlarge
     */
    readonly MlC4Xlarge: "ml.c4.xlarge";
    /**
     * InstanceType enum ml.c5.18xlarge
     */
    readonly MlC518xlarge: "ml.c5.18xlarge";
    /**
     * InstanceType enum ml.c5.2xlarge
     */
    readonly MlC52xlarge: "ml.c5.2xlarge";
    /**
     * InstanceType enum ml.c5.4xlarge
     */
    readonly MlC54xlarge: "ml.c5.4xlarge";
    /**
     * InstanceType enum ml.c5.9xlarge
     */
    readonly MlC59xlarge: "ml.c5.9xlarge";
    /**
     * InstanceType enum ml.c5.xlarge
     */
    readonly MlC5Xlarge: "ml.c5.xlarge";
    /**
     * InstanceType enum ml.c5d.18xlarge
     */
    readonly MlC5d18xlarge: "ml.c5d.18xlarge";
    /**
     * InstanceType enum ml.c5d.2xlarge
     */
    readonly MlC5d2xlarge: "ml.c5d.2xlarge";
    /**
     * InstanceType enum ml.c5d.4xlarge
     */
    readonly MlC5d4xlarge: "ml.c5d.4xlarge";
    /**
     * InstanceType enum ml.c5d.9xlarge
     */
    readonly MlC5d9xlarge: "ml.c5d.9xlarge";
    /**
     * InstanceType enum ml.c5d.xlarge
     */
    readonly MlC5dXlarge: "ml.c5d.xlarge";
    /**
     * InstanceType enum ml.c6i.12xlarge
     */
    readonly MlC6i12xlarge: "ml.c6i.12xlarge";
    /**
     * InstanceType enum ml.c6i.16xlarge
     */
    readonly MlC6i16xlarge: "ml.c6i.16xlarge";
    /**
     * InstanceType enum ml.c6i.24xlarge
     */
    readonly MlC6i24xlarge: "ml.c6i.24xlarge";
    /**
     * InstanceType enum ml.c6i.2xlarge
     */
    readonly MlC6i2xlarge: "ml.c6i.2xlarge";
    /**
     * InstanceType enum ml.c6i.32xlarge
     */
    readonly MlC6i32xlarge: "ml.c6i.32xlarge";
    /**
     * InstanceType enum ml.c6i.4xlarge
     */
    readonly MlC6i4xlarge: "ml.c6i.4xlarge";
    /**
     * InstanceType enum ml.c6i.8xlarge
     */
    readonly MlC6i8xlarge: "ml.c6i.8xlarge";
    /**
     * InstanceType enum ml.c6i.large
     */
    readonly MlC6iLarge: "ml.c6i.large";
    /**
     * InstanceType enum ml.c6i.xlarge
     */
    readonly MlC6iXlarge: "ml.c6i.xlarge";
    /**
     * InstanceType enum ml.c6id.12xlarge
     */
    readonly MlC6id12xlarge: "ml.c6id.12xlarge";
    /**
     * InstanceType enum ml.c6id.16xlarge
     */
    readonly MlC6id16xlarge: "ml.c6id.16xlarge";
    /**
     * InstanceType enum ml.c6id.24xlarge
     */
    readonly MlC6id24xlarge: "ml.c6id.24xlarge";
    /**
     * InstanceType enum ml.c6id.2xlarge
     */
    readonly MlC6id2xlarge: "ml.c6id.2xlarge";
    /**
     * InstanceType enum ml.c6id.32xlarge
     */
    readonly MlC6id32xlarge: "ml.c6id.32xlarge";
    /**
     * InstanceType enum ml.c6id.4xlarge
     */
    readonly MlC6id4xlarge: "ml.c6id.4xlarge";
    /**
     * InstanceType enum ml.c6id.8xlarge
     */
    readonly MlC6id8xlarge: "ml.c6id.8xlarge";
    /**
     * InstanceType enum ml.c6id.large
     */
    readonly MlC6idLarge: "ml.c6id.large";
    /**
     * InstanceType enum ml.c6id.xlarge
     */
    readonly MlC6idXlarge: "ml.c6id.xlarge";
    /**
     * InstanceType enum ml.c7i.12xlarge
     */
    readonly MlC7i12xlarge: "ml.c7i.12xlarge";
    /**
     * InstanceType enum ml.c7i.16xlarge
     */
    readonly MlC7i16xlarge: "ml.c7i.16xlarge";
    /**
     * InstanceType enum ml.c7i.24xlarge
     */
    readonly MlC7i24xlarge: "ml.c7i.24xlarge";
    /**
     * InstanceType enum ml.c7i.2xlarge
     */
    readonly MlC7i2xlarge: "ml.c7i.2xlarge";
    /**
     * InstanceType enum ml.c7i.48xlarge
     */
    readonly MlC7i48xlarge: "ml.c7i.48xlarge";
    /**
     * InstanceType enum ml.c7i.4xlarge
     */
    readonly MlC7i4xlarge: "ml.c7i.4xlarge";
    /**
     * InstanceType enum ml.c7i.8xlarge
     */
    readonly MlC7i8xlarge: "ml.c7i.8xlarge";
    /**
     * InstanceType enum ml.c7i.large
     */
    readonly MlC7iLarge: "ml.c7i.large";
    /**
     * InstanceType enum ml.c7i.xlarge
     */
    readonly MlC7iXlarge: "ml.c7i.xlarge";
    /**
     * InstanceType enum ml.g4dn.12xlarge
     */
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    /**
     * InstanceType enum ml.g4dn.16xlarge
     */
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    /**
     * InstanceType enum ml.g4dn.2xlarge
     */
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    /**
     * InstanceType enum ml.g4dn.4xlarge
     */
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    /**
     * InstanceType enum ml.g4dn.8xlarge
     */
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    /**
     * InstanceType enum ml.g4dn.xlarge
     */
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    /**
     * InstanceType enum ml.g5.12xlarge
     */
    readonly MlG512xlarge: "ml.g5.12xlarge";
    /**
     * InstanceType enum ml.g5.16xlarge
     */
    readonly MlG516xlarge: "ml.g5.16xlarge";
    /**
     * InstanceType enum ml.g5.24xlarge
     */
    readonly MlG524xlarge: "ml.g5.24xlarge";
    /**
     * InstanceType enum ml.g5.2xlarge
     */
    readonly MlG52xlarge: "ml.g5.2xlarge";
    /**
     * InstanceType enum ml.g5.48xlarge
     */
    readonly MlG548xlarge: "ml.g5.48xlarge";
    /**
     * InstanceType enum ml.g5.4xlarge
     */
    readonly MlG54xlarge: "ml.g5.4xlarge";
    /**
     * InstanceType enum ml.g5.8xlarge
     */
    readonly MlG58xlarge: "ml.g5.8xlarge";
    /**
     * InstanceType enum ml.g5.xlarge
     */
    readonly MlG5Xlarge: "ml.g5.xlarge";
    /**
     * InstanceType enum ml.inf1.24xlarge
     */
    readonly MlInf124xlarge: "ml.inf1.24xlarge";
    /**
     * InstanceType enum ml.inf1.2xlarge
     */
    readonly MlInf12xlarge: "ml.inf1.2xlarge";
    /**
     * InstanceType enum ml.inf1.6xlarge
     */
    readonly MlInf16xlarge: "ml.inf1.6xlarge";
    /**
     * InstanceType enum ml.inf1.xlarge
     */
    readonly MlInf1Xlarge: "ml.inf1.xlarge";
    /**
     * InstanceType enum ml.m4.10xlarge
     */
    readonly MlM410xlarge: "ml.m4.10xlarge";
    /**
     * InstanceType enum ml.m4.16xlarge
     */
    readonly MlM416xlarge: "ml.m4.16xlarge";
    /**
     * InstanceType enum ml.m4.2xlarge
     */
    readonly MlM42xlarge: "ml.m4.2xlarge";
    /**
     * InstanceType enum ml.m4.4xlarge
     */
    readonly MlM44xlarge: "ml.m4.4xlarge";
    /**
     * InstanceType enum ml.m4.xlarge
     */
    readonly MlM4Xlarge: "ml.m4.xlarge";
    /**
     * InstanceType enum ml.m5.12xlarge
     */
    readonly MlM512xlarge: "ml.m5.12xlarge";
    /**
     * InstanceType enum ml.m5.24xlarge
     */
    readonly MlM524xlarge: "ml.m5.24xlarge";
    /**
     * InstanceType enum ml.m5.2xlarge
     */
    readonly MlM52xlarge: "ml.m5.2xlarge";
    /**
     * InstanceType enum ml.m5.4xlarge
     */
    readonly MlM54xlarge: "ml.m5.4xlarge";
    /**
     * InstanceType enum ml.m5.xlarge
     */
    readonly MlM5Xlarge: "ml.m5.xlarge";
    /**
     * InstanceType enum ml.m5d.12xlarge
     */
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    /**
     * InstanceType enum ml.m5d.16xlarge
     */
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    /**
     * InstanceType enum ml.m5d.24xlarge
     */
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    /**
     * InstanceType enum ml.m5d.2xlarge
     */
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    /**
     * InstanceType enum ml.m5d.4xlarge
     */
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    /**
     * InstanceType enum ml.m5d.8xlarge
     */
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    /**
     * InstanceType enum ml.m5d.large
     */
    readonly MlM5dLarge: "ml.m5d.large";
    /**
     * InstanceType enum ml.m5d.xlarge
     */
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    /**
     * InstanceType enum ml.m6i.12xlarge
     */
    readonly MlM6i12xlarge: "ml.m6i.12xlarge";
    /**
     * InstanceType enum ml.m6i.16xlarge
     */
    readonly MlM6i16xlarge: "ml.m6i.16xlarge";
    /**
     * InstanceType enum ml.m6i.24xlarge
     */
    readonly MlM6i24xlarge: "ml.m6i.24xlarge";
    /**
     * InstanceType enum ml.m6i.2xlarge
     */
    readonly MlM6i2xlarge: "ml.m6i.2xlarge";
    /**
     * InstanceType enum ml.m6i.32xlarge
     */
    readonly MlM6i32xlarge: "ml.m6i.32xlarge";
    /**
     * InstanceType enum ml.m6i.4xlarge
     */
    readonly MlM6i4xlarge: "ml.m6i.4xlarge";
    /**
     * InstanceType enum ml.m6i.8xlarge
     */
    readonly MlM6i8xlarge: "ml.m6i.8xlarge";
    /**
     * InstanceType enum ml.m6i.large
     */
    readonly MlM6iLarge: "ml.m6i.large";
    /**
     * InstanceType enum ml.m6i.xlarge
     */
    readonly MlM6iXlarge: "ml.m6i.xlarge";
    /**
     * InstanceType enum ml.m6id.12xlarge
     */
    readonly MlM6id12xlarge: "ml.m6id.12xlarge";
    /**
     * InstanceType enum ml.m6id.16xlarge
     */
    readonly MlM6id16xlarge: "ml.m6id.16xlarge";
    /**
     * InstanceType enum ml.m6id.24xlarge
     */
    readonly MlM6id24xlarge: "ml.m6id.24xlarge";
    /**
     * InstanceType enum ml.m6id.2xlarge
     */
    readonly MlM6id2xlarge: "ml.m6id.2xlarge";
    /**
     * InstanceType enum ml.m6id.32xlarge
     */
    readonly MlM6id32xlarge: "ml.m6id.32xlarge";
    /**
     * InstanceType enum ml.m6id.4xlarge
     */
    readonly MlM6id4xlarge: "ml.m6id.4xlarge";
    /**
     * InstanceType enum ml.m6id.8xlarge
     */
    readonly MlM6id8xlarge: "ml.m6id.8xlarge";
    /**
     * InstanceType enum ml.m6id.large
     */
    readonly MlM6idLarge: "ml.m6id.large";
    /**
     * InstanceType enum ml.m6id.xlarge
     */
    readonly MlM6idXlarge: "ml.m6id.xlarge";
    /**
     * InstanceType enum ml.m7i.12xlarge
     */
    readonly MlM7i12xlarge: "ml.m7i.12xlarge";
    /**
     * InstanceType enum ml.m7i.16xlarge
     */
    readonly MlM7i16xlarge: "ml.m7i.16xlarge";
    /**
     * InstanceType enum ml.m7i.24xlarge
     */
    readonly MlM7i24xlarge: "ml.m7i.24xlarge";
    /**
     * InstanceType enum ml.m7i.2xlarge
     */
    readonly MlM7i2xlarge: "ml.m7i.2xlarge";
    /**
     * InstanceType enum ml.m7i.48xlarge
     */
    readonly MlM7i48xlarge: "ml.m7i.48xlarge";
    /**
     * InstanceType enum ml.m7i.4xlarge
     */
    readonly MlM7i4xlarge: "ml.m7i.4xlarge";
    /**
     * InstanceType enum ml.m7i.8xlarge
     */
    readonly MlM7i8xlarge: "ml.m7i.8xlarge";
    /**
     * InstanceType enum ml.m7i.large
     */
    readonly MlM7iLarge: "ml.m7i.large";
    /**
     * InstanceType enum ml.m7i.xlarge
     */
    readonly MlM7iXlarge: "ml.m7i.xlarge";
    /**
     * InstanceType enum ml.p2.16xlarge
     */
    readonly MlP216xlarge: "ml.p2.16xlarge";
    /**
     * InstanceType enum ml.p2.8xlarge
     */
    readonly MlP28xlarge: "ml.p2.8xlarge";
    /**
     * InstanceType enum ml.p2.xlarge
     */
    readonly MlP2Xlarge: "ml.p2.xlarge";
    /**
     * InstanceType enum ml.p3.16xlarge
     */
    readonly MlP316xlarge: "ml.p3.16xlarge";
    /**
     * InstanceType enum ml.p3.2xlarge
     */
    readonly MlP32xlarge: "ml.p3.2xlarge";
    /**
     * InstanceType enum ml.p3.8xlarge
     */
    readonly MlP38xlarge: "ml.p3.8xlarge";
    /**
     * InstanceType enum ml.p3dn.24xlarge
     */
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    /**
     * InstanceType enum ml.p4d.24xlarge
     */
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    /**
     * InstanceType enum ml.p4de.24xlarge
     */
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    /**
     * InstanceType enum ml.p5.48xlarge
     */
    readonly MlP548xlarge: "ml.p5.48xlarge";
    /**
     * InstanceType enum ml.r5.12xlarge
     */
    readonly MlR512xlarge: "ml.r5.12xlarge";
    /**
     * InstanceType enum ml.r5.16xlarge
     */
    readonly MlR516xlarge: "ml.r5.16xlarge";
    /**
     * InstanceType enum ml.r5.24xlarge
     */
    readonly MlR524xlarge: "ml.r5.24xlarge";
    /**
     * InstanceType enum ml.r5.2xlarge
     */
    readonly MlR52xlarge: "ml.r5.2xlarge";
    /**
     * InstanceType enum ml.r5.4xlarge
     */
    readonly MlR54xlarge: "ml.r5.4xlarge";
    /**
     * InstanceType enum ml.r5.8xlarge
     */
    readonly MlR58xlarge: "ml.r5.8xlarge";
    /**
     * InstanceType enum ml.r5.large
     */
    readonly MlR5Large: "ml.r5.large";
    /**
     * InstanceType enum ml.r5.xlarge
     */
    readonly MlR5Xlarge: "ml.r5.xlarge";
    /**
     * InstanceType enum ml.r6i.12xlarge
     */
    readonly MlR6i12xlarge: "ml.r6i.12xlarge";
    /**
     * InstanceType enum ml.r6i.16xlarge
     */
    readonly MlR6i16xlarge: "ml.r6i.16xlarge";
    /**
     * InstanceType enum ml.r6i.24xlarge
     */
    readonly MlR6i24xlarge: "ml.r6i.24xlarge";
    /**
     * InstanceType enum ml.r6i.2xlarge
     */
    readonly MlR6i2xlarge: "ml.r6i.2xlarge";
    /**
     * InstanceType enum ml.r6i.32xlarge
     */
    readonly MlR6i32xlarge: "ml.r6i.32xlarge";
    /**
     * InstanceType enum ml.r6i.4xlarge
     */
    readonly MlR6i4xlarge: "ml.r6i.4xlarge";
    /**
     * InstanceType enum ml.r6i.8xlarge
     */
    readonly MlR6i8xlarge: "ml.r6i.8xlarge";
    /**
     * InstanceType enum ml.r6i.large
     */
    readonly MlR6iLarge: "ml.r6i.large";
    /**
     * InstanceType enum ml.r6i.xlarge
     */
    readonly MlR6iXlarge: "ml.r6i.xlarge";
    /**
     * InstanceType enum ml.r6id.12xlarge
     */
    readonly MlR6id12xlarge: "ml.r6id.12xlarge";
    /**
     * InstanceType enum ml.r6id.16xlarge
     */
    readonly MlR6id16xlarge: "ml.r6id.16xlarge";
    /**
     * InstanceType enum ml.r6id.24xlarge
     */
    readonly MlR6id24xlarge: "ml.r6id.24xlarge";
    /**
     * InstanceType enum ml.r6id.2xlarge
     */
    readonly MlR6id2xlarge: "ml.r6id.2xlarge";
    /**
     * InstanceType enum ml.r6id.32xlarge
     */
    readonly MlR6id32xlarge: "ml.r6id.32xlarge";
    /**
     * InstanceType enum ml.r6id.4xlarge
     */
    readonly MlR6id4xlarge: "ml.r6id.4xlarge";
    /**
     * InstanceType enum ml.r6id.8xlarge
     */
    readonly MlR6id8xlarge: "ml.r6id.8xlarge";
    /**
     * InstanceType enum ml.r6id.large
     */
    readonly MlR6idLarge: "ml.r6id.large";
    /**
     * InstanceType enum ml.r6id.xlarge
     */
    readonly MlR6idXlarge: "ml.r6id.xlarge";
    /**
     * InstanceType enum ml.r7i.12xlarge
     */
    readonly MlR7i12xlarge: "ml.r7i.12xlarge";
    /**
     * InstanceType enum ml.r7i.16xlarge
     */
    readonly MlR7i16xlarge: "ml.r7i.16xlarge";
    /**
     * InstanceType enum ml.r7i.24xlarge
     */
    readonly MlR7i24xlarge: "ml.r7i.24xlarge";
    /**
     * InstanceType enum ml.r7i.2xlarge
     */
    readonly MlR7i2xlarge: "ml.r7i.2xlarge";
    /**
     * InstanceType enum ml.r7i.48xlarge
     */
    readonly MlR7i48xlarge: "ml.r7i.48xlarge";
    /**
     * InstanceType enum ml.r7i.4xlarge
     */
    readonly MlR7i4xlarge: "ml.r7i.4xlarge";
    /**
     * InstanceType enum ml.r7i.8xlarge
     */
    readonly MlR7i8xlarge: "ml.r7i.8xlarge";
    /**
     * InstanceType enum ml.r7i.large
     */
    readonly MlR7iLarge: "ml.r7i.large";
    /**
     * InstanceType enum ml.r7i.xlarge
     */
    readonly MlR7iXlarge: "ml.r7i.xlarge";
    /**
     * InstanceType enum ml.t2.2xlarge
     */
    readonly MlT22xlarge: "ml.t2.2xlarge";
    /**
     * InstanceType enum ml.t2.large
     */
    readonly MlT2Large: "ml.t2.large";
    /**
     * InstanceType enum ml.t2.medium
     */
    readonly MlT2Medium: "ml.t2.medium";
    /**
     * InstanceType enum ml.t2.xlarge
     */
    readonly MlT2Xlarge: "ml.t2.xlarge";
    /**
     * InstanceType enum ml.t3.2xlarge
     */
    readonly MlT32xlarge: "ml.t3.2xlarge";
    /**
     * InstanceType enum ml.t3.large
     */
    readonly MlT3Large: "ml.t3.large";
    /**
     * InstanceType enum ml.t3.medium
     */
    readonly MlT3Medium: "ml.t3.medium";
    /**
     * InstanceType enum ml.t3.xlarge
     */
    readonly MlT3Xlarge: "ml.t3.xlarge";
};
/**
 * Property value
 */
export type InstanceType = (typeof InstanceType)[keyof typeof InstanceType];
export declare const IntelligentTieringConfigurationStatus: {
    /**
     * IntelligentTieringConfigurationStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * IntelligentTieringConfigurationStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies the status of the configuration.
 */
export type IntelligentTieringConfigurationStatus = (typeof IntelligentTieringConfigurationStatus)[keyof typeof IntelligentTieringConfigurationStatus];
export declare const InventoryConfigurationIncludedObjectVersions: {
    /**
     * InventoryConfigurationIncludedObjectVersions enum All
     */
    readonly All: "All";
    /**
     * InventoryConfigurationIncludedObjectVersions enum Current
     */
    readonly Current: "Current";
};
/**
 * Object versions to include in the inventory list. If set to ``All``, the list includes all the object versions, which adds the version-related fields ``VersionId``, ``IsLatest``, and ``DeleteMarker`` to the list. If set to ``Current``, the list does not contain these version-related fields.
 */
export type InventoryConfigurationIncludedObjectVersions = (typeof InventoryConfigurationIncludedObjectVersions)[keyof typeof InventoryConfigurationIncludedObjectVersions];
export declare const InventoryConfigurationOptionalFields: {
    /**
     * InventoryConfigurationOptionalFields enum BucketKeyStatus
     */
    readonly BucketKeyStatus: "BucketKeyStatus";
    /**
     * InventoryConfigurationOptionalFields enum ChecksumAlgorithm
     */
    readonly ChecksumAlgorithm: "ChecksumAlgorithm";
    /**
     * InventoryConfigurationOptionalFields enum ETag
     */
    readonly ETag: "ETag";
    /**
     * InventoryConfigurationOptionalFields enum EncryptionStatus
     */
    readonly EncryptionStatus: "EncryptionStatus";
    /**
     * InventoryConfigurationOptionalFields enum IntelligentTieringAccessTier
     */
    readonly IntelligentTieringAccessTier: "IntelligentTieringAccessTier";
    /**
     * InventoryConfigurationOptionalFields enum IsMultipartUploaded
     */
    readonly IsMultipartUploaded: "IsMultipartUploaded";
    /**
     * InventoryConfigurationOptionalFields enum LastModifiedDate
     */
    readonly LastModifiedDate: "LastModifiedDate";
    /**
     * InventoryConfigurationOptionalFields enum ObjectAccessControlList
     */
    readonly ObjectAccessControlList: "ObjectAccessControlList";
    /**
     * InventoryConfigurationOptionalFields enum ObjectLockLegalHoldStatus
     */
    readonly ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus";
    /**
     * InventoryConfigurationOptionalFields enum ObjectLockMode
     */
    readonly ObjectLockMode: "ObjectLockMode";
    /**
     * InventoryConfigurationOptionalFields enum ObjectLockRetainUntilDate
     */
    readonly ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate";
    /**
     * InventoryConfigurationOptionalFields enum ObjectOwner
     */
    readonly ObjectOwner: "ObjectOwner";
    /**
     * InventoryConfigurationOptionalFields enum ReplicationStatus
     */
    readonly ReplicationStatus: "ReplicationStatus";
    /**
     * InventoryConfigurationOptionalFields enum Size
     */
    readonly Size: "Size";
    /**
     * InventoryConfigurationOptionalFields enum StorageClass
     */
    readonly StorageClass: "StorageClass";
};
/**
 * InventoryConfigurationOptionalFields enum
 */
export type InventoryConfigurationOptionalFields = (typeof InventoryConfigurationOptionalFields)[keyof typeof InventoryConfigurationOptionalFields];
export declare const InventoryConfigurationScheduleFrequency: {
    /**
     * InventoryConfigurationScheduleFrequency enum Daily
     */
    readonly Daily: "Daily";
    /**
     * InventoryConfigurationScheduleFrequency enum Weekly
     */
    readonly Weekly: "Weekly";
};
/**
 * Specifies the schedule for generating inventory results.
 */
export type InventoryConfigurationScheduleFrequency = (typeof InventoryConfigurationScheduleFrequency)[keyof typeof InventoryConfigurationScheduleFrequency];
export declare const IpFamily: {
    /**
     * IpFamily enum ipv4
     */
    readonly Ipv4: "ipv4";
    /**
     * IpFamily enum ipv6
     */
    readonly Ipv6: "ipv6";
};
/**
 * Property value
 */
export type IpFamily = (typeof IpFamily)[keyof typeof IpFamily];
export declare const IpamState: {
    /**
     * IpamState enum create-complete
     */
    readonly CreateComplete: "create-complete";
    /**
     * IpamState enum create-failed
     */
    readonly CreateFailed: "create-failed";
    /**
     * IpamState enum create-in-progress
     */
    readonly CreateInProgress: "create-in-progress";
    /**
     * IpamState enum delete-complete
     */
    readonly DeleteComplete: "delete-complete";
    /**
     * IpamState enum delete-failed
     */
    readonly DeleteFailed: "delete-failed";
    /**
     * IpamState enum delete-in-progress
     */
    readonly DeleteInProgress: "delete-in-progress";
    /**
     * IpamState enum isolate-complete
     */
    readonly IsolateComplete: "isolate-complete";
    /**
     * IpamState enum isolate-in-progress
     */
    readonly IsolateInProgress: "isolate-in-progress";
    /**
     * IpamState enum modify-complete
     */
    readonly ModifyComplete: "modify-complete";
    /**
     * IpamState enum modify-failed
     */
    readonly ModifyFailed: "modify-failed";
    /**
     * IpamState enum modify-in-progress
     */
    readonly ModifyInProgress: "modify-in-progress";
    /**
     * IpamState enum restore-in-progress
     */
    readonly RestoreInProgress: "restore-in-progress";
};
/**
 * Property value
 */
export type IpamState = (typeof IpamState)[keyof typeof IpamState];
export declare const IpamTier: {
    /**
     * IpamTier enum advanced
     */
    readonly Advanced: "advanced";
    /**
     * IpamTier enum free
     */
    readonly Free: "free";
};
/**
 * Property value
 */
export type IpamTier = (typeof IpamTier)[keyof typeof IpamTier];
export declare const JobComparator: {
    /**
     * JobComparator enum CONTAINS
     */
    readonly CONTAINS: "CONTAINS";
    /**
     * JobComparator enum EQ
     */
    readonly EQ: "EQ";
    /**
     * JobComparator enum GT
     */
    readonly GT: "GT";
    /**
     * JobComparator enum GTE
     */
    readonly GTE: "GTE";
    /**
     * JobComparator enum LT
     */
    readonly LT: "LT";
    /**
     * JobComparator enum LTE
     */
    readonly LTE: "LTE";
    /**
     * JobComparator enum NE
     */
    readonly NE: "NE";
    /**
     * JobComparator enum STARTS_WITH
     */
    readonly STARTS_WITH: "STARTS_WITH";
};
/**
 * Property value
 */
export type JobComparator = (typeof JobComparator)[keyof typeof JobComparator];
export declare const JobStatus: {
    /**
     * JobStatus enum CANCELLED
     */
    readonly CANCELLED: "CANCELLED";
    /**
     * JobStatus enum COMPLETE
     */
    readonly COMPLETE: "COMPLETE";
    /**
     * JobStatus enum IDLE
     */
    readonly IDLE: "IDLE";
    /**
     * JobStatus enum PAUSED
     */
    readonly PAUSED: "PAUSED";
    /**
     * JobStatus enum RUNNING
     */
    readonly RUNNING: "RUNNING";
    /**
     * JobStatus enum USER_PAUSED
     */
    readonly USER_PAUSED: "USER_PAUSED";
};
/**
 * Property value
 */
export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus];
export declare const JobType: {
    /**
     * JobType enum ONE_TIME
     */
    readonly ONE_TIME: "ONE_TIME";
    /**
     * JobType enum SCHEDULED
     */
    readonly SCHEDULED: "SCHEDULED";
};
/**
 * Property value
 */
export type JobType = (typeof JobType)[keyof typeof JobType];
export declare const JoinedMethod: {
    /**
     * JoinedMethod enum CREATED
     */
    readonly CREATED: "CREATED";
    /**
     * JoinedMethod enum INVITED
     */
    readonly INVITED: "INVITED";
};
/**
 * The method by which the account joined the organization.
 */
export type JoinedMethod = (typeof JoinedMethod)[keyof typeof JoinedMethod];
export declare const KeyAlgorithm: {
    /**
     * KeyAlgorithm enum EC_prime256v1
     */
    readonly EC_prime256v1: "EC_prime256v1";
    /**
     * KeyAlgorithm enum EC_secp384r1
     */
    readonly EC_secp384r1: "EC_secp384r1";
    /**
     * KeyAlgorithm enum EC_secp521r1
     */
    readonly EC_secp521r1: "EC_secp521r1";
    /**
     * KeyAlgorithm enum RSA_1024
     */
    readonly RSA_1024: "RSA_1024";
    /**
     * KeyAlgorithm enum RSA_2048
     */
    readonly RSA_2048: "RSA_2048";
    /**
     * KeyAlgorithm enum RSA_3072
     */
    readonly RSA_3072: "RSA_3072";
    /**
     * KeyAlgorithm enum RSA_4096
     */
    readonly RSA_4096: "RSA_4096";
};
/**
 * Property value
 */
export type KeyAlgorithm = (typeof KeyAlgorithm)[keyof typeof KeyAlgorithm];
export declare const KeyFormat: {
    /**
     * KeyFormat enum pem
     */
    readonly Pem: "pem";
    /**
     * KeyFormat enum ppk
     */
    readonly Ppk: "ppk";
};
/**
 * The format of the key pair. Default: ``pem``
 */
export type KeyFormat = (typeof KeyFormat)[keyof typeof KeyFormat];
export declare const KeySpec: {
    /**
     * KeySpec enum ECC_NIST_P256
     */
    readonly ECC_NIST_P256: "ECC_NIST_P256";
    /**
     * KeySpec enum ECC_NIST_P384
     */
    readonly ECC_NIST_P384: "ECC_NIST_P384";
    /**
     * KeySpec enum ECC_NIST_P521
     */
    readonly ECC_NIST_P521: "ECC_NIST_P521";
    /**
     * KeySpec enum ECC_SECG_P256K1
     */
    readonly ECC_SECG_P256K1: "ECC_SECG_P256K1";
    /**
     * KeySpec enum HMAC_224
     */
    readonly HMAC_224: "HMAC_224";
    /**
     * KeySpec enum HMAC_256
     */
    readonly HMAC_256: "HMAC_256";
    /**
     * KeySpec enum HMAC_384
     */
    readonly HMAC_384: "HMAC_384";
    /**
     * KeySpec enum HMAC_512
     */
    readonly HMAC_512: "HMAC_512";
    /**
     * KeySpec enum RSA_2048
     */
    readonly RSA_2048: "RSA_2048";
    /**
     * KeySpec enum RSA_3072
     */
    readonly RSA_3072: "RSA_3072";
    /**
     * KeySpec enum RSA_4096
     */
    readonly RSA_4096: "RSA_4096";
    /**
     * KeySpec enum SM2
     */
    readonly SM2: "SM2";
    /**
     * KeySpec enum SYMMETRIC_DEFAULT
     */
    readonly SYMMETRIC_DEFAULT: "SYMMETRIC_DEFAULT";
};
/**
 * Specifies the type of KMS key to create. The default value, ``SYMMETRIC_DEFAULT``, creates a KMS key with a 256-bit symmetric key for encryption and decryption. In China Regions, ``SYMMETRIC_DEFAULT`` creates a 128-bit symmetric key that uses SM4 encryption. You can't change the ``KeySpec`` value after the KMS key is created. For help choosing a key spec for your KMS key, see [Choosing a KMS key type](https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html) in the *Developer Guide*. The ``KeySpec`` property determines the type of key material in the KMS key and the algorithms that the KMS key supports. To further restrict the algorithms that can be used with the KMS key, use a condition key in its key policy or IAM policy. For more information, see [condition keys](https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms) in the *Developer Guide*.  If you change the value of the ``KeySpec`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.    [services that are integrated with](https://docs.aws.amazon.com/kms/features/#AWS_Service_Integration) use symmetric encryption KMS keys to protect your data. These services do not support encryption with asymmetric KMS keys. For help determining whether a KMS key is asymmetric, see [Identifying asymmetric KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html) in the *Developer Guide*.   KMS supports the following key specs for KMS keys:  +  Symmetric encryption key (default)  +   ``SYMMETRIC_DEFAULT`` (AES-256-GCM)    +  HMAC keys (symmetric)  +   ``HMAC_224``   +   ``HMAC_256``   +   ``HMAC_384``   +   ``HMAC_512``     +  Asymmetric RSA key pairs  +   ``RSA_2048``   +   ``RSA_3072``   +   ``RSA_4096``     +  Asymmetric NIST-recommended elliptic curve key pairs  +   ``ECC_NIST_P256`` (secp256r1)  +   ``ECC_NIST_P384`` (secp384r1)  +   ``ECC_NIST_P521`` (secp521r1)    +  Other asymmetric elliptic curve key pairs  +   ``ECC_SECG_P256K1`` (secp256k1), commonly used for cryptocurrencies.    +  SM2 key pairs (China Regions only)  +   ``SM2``
 */
export type KeySpec = (typeof KeySpec)[keyof typeof KeySpec];
export declare const KeyType: {
    /**
     * KeyType enum ed25519
     */
    readonly Ed25519: "ed25519";
    /**
     * KeyType enum rsa
     */
    readonly Rsa: "rsa";
};
/**
 * The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``
 */
export type KeyType = (typeof KeyType)[keyof typeof KeyType];
export declare const KeyUsage: {
    /**
     * KeyUsage enum ENCRYPT_DECRYPT
     */
    readonly ENCRYPT_DECRYPT: "ENCRYPT_DECRYPT";
    /**
     * KeyUsage enum GENERATE_VERIFY_MAC
     */
    readonly GENERATE_VERIFY_MAC: "GENERATE_VERIFY_MAC";
    /**
     * KeyUsage enum SIGN_VERIFY
     */
    readonly SIGN_VERIFY: "SIGN_VERIFY";
};
/**
 * Determines the [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) for which you can use the KMS key. The default value is ``ENCRYPT_DECRYPT``. This property is required for asymmetric KMS keys and HMAC KMS keys. You can't change the ``KeyUsage`` value after the KMS key is created.  If you change the value of the ``KeyUsage`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  Select only one valid value.  +  For symmetric encryption KMS keys, omit the property or specify ``ENCRYPT_DECRYPT``.  +  For asymmetric KMS keys with RSA key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For asymmetric KMS keys with ECC key material, specify ``SIGN_VERIFY``.  +  For asymmetric KMS keys with SM2 (China Regions only) key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For HMAC KMS keys, specify ``GENERATE_VERIFY_MAC``.
 */
export type KeyUsage = (typeof KeyUsage)[keyof typeof KeyUsage];
export declare const KeyUsageName: {
    /**
     * KeyUsageName enum ANY
     */
    readonly ANY: "ANY";
    /**
     * KeyUsageName enum CERTIFICATE_SIGNING
     */
    readonly CERTIFICATE_SIGNING: "CERTIFICATE_SIGNING";
    /**
     * KeyUsageName enum CRL_SIGNING
     */
    readonly CRL_SIGNING: "CRL_SIGNING";
    /**
     * KeyUsageName enum CUSTOM
     */
    readonly CUSTOM: "CUSTOM";
    /**
     * KeyUsageName enum DATA_ENCIPHERMENT
     */
    readonly DATA_ENCIPHERMENT: "DATA_ENCIPHERMENT";
    /**
     * KeyUsageName enum DECIPHER_ONLY
     */
    readonly DECIPHER_ONLY: "DECIPHER_ONLY";
    /**
     * KeyUsageName enum DIGITAL_SIGNATURE
     */
    readonly DIGITAL_SIGNATURE: "DIGITAL_SIGNATURE";
    /**
     * KeyUsageName enum ENCIPHER_ONLY
     */
    readonly ENCIPHER_ONLY: "ENCIPHER_ONLY";
    /**
     * KeyUsageName enum KEY_AGREEMENT
     */
    readonly KEY_AGREEMENT: "KEY_AGREEMENT";
    /**
     * KeyUsageName enum KEY_ENCIPHERMENT
     */
    readonly KEY_ENCIPHERMENT: "KEY_ENCIPHERMENT";
    /**
     * KeyUsageName enum NON_REPUDIATION
     */
    readonly NON_REPUDIATION: "NON_REPUDIATION";
};
/**
 * KeyUsageName enum
 */
export type KeyUsageName = (typeof KeyUsageName)[keyof typeof KeyUsageName];
export declare const KinesisStreamSpecificationApproximateCreationDateTimePrecision: {
    /**
     * KinesisStreamSpecificationApproximateCreationDateTimePrecision enum MICROSECOND
     */
    readonly MICROSECOND: "MICROSECOND";
    /**
     * KinesisStreamSpecificationApproximateCreationDateTimePrecision enum MILLISECOND
     */
    readonly MILLISECOND: "MILLISECOND";
};
/**
 * The precision for the time and date that the stream was created.
 */
export type KinesisStreamSpecificationApproximateCreationDateTimePrecision = (typeof KinesisStreamSpecificationApproximateCreationDateTimePrecision)[keyof typeof KinesisStreamSpecificationApproximateCreationDateTimePrecision];
export declare const LastRunErrorStatusCode: {
    /**
     * LastRunErrorStatusCode enum ERROR
     */
    readonly ERROR: "ERROR";
    /**
     * LastRunErrorStatusCode enum NONE
     */
    readonly NONE: "NONE";
};
/**
 * Property value
 */
export type LastRunErrorStatusCode = (typeof LastRunErrorStatusCode)[keyof typeof LastRunErrorStatusCode];
export declare const LaunchType: {
    /**
     * LaunchType enum EC2
     */
    readonly EC2: "EC2";
    /**
     * LaunchType enum EXTERNAL
     */
    readonly EXTERNAL: "EXTERNAL";
    /**
     * LaunchType enum FARGATE
     */
    readonly FARGATE: "FARGATE";
};
/**
 * The launch type on which to run your service. For more information, see [Amazon ECS Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
 */
export type LaunchType = (typeof LaunchType)[keyof typeof LaunchType];
export declare const LogDestinationType: {
    /**
     * LogDestinationType enum cloud-watch-logs
     */
    readonly CloudWatchLogs: "cloud-watch-logs";
    /**
     * LogDestinationType enum kinesis-data-firehose
     */
    readonly KinesisDataFirehose: "kinesis-data-firehose";
    /**
     * LogDestinationType enum s3
     */
    readonly S3: "s3";
};
/**
 * Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
 */
export type LogDestinationType = (typeof LogDestinationType)[keyof typeof LogDestinationType];
export declare const LogGroupClass: {
    /**
     * LogGroupClass enum INFREQUENT_ACCESS
     */
    readonly INFREQUENT_ACCESS: "INFREQUENT_ACCESS";
    /**
     * LogGroupClass enum STANDARD
     */
    readonly STANDARD: "STANDARD";
};
/**
 * Specifies the log group class for this log group. There are two classes:  +  The ``Standard`` log class supports all CWL features.  +  The ``Infrequent Access`` log class supports a subset of CWL features and incurs lower costs.   For details about the features supported by each class, see [Log classes](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html)
 */
export type LogGroupClass = (typeof LogGroupClass)[keyof typeof LogGroupClass];
export declare const LogType: {
    /**
     * LogType enum api
     */
    readonly Api: "api";
    /**
     * LogType enum audit
     */
    readonly Audit: "audit";
    /**
     * LogType enum authenticator
     */
    readonly Authenticator: "authenticator";
    /**
     * LogType enum controllerManager
     */
    readonly ControllerManager: "controllerManager";
    /**
     * LogType enum scheduler
     */
    readonly Scheduler: "scheduler";
};
/**
 * LogType enum
 */
export type LogType = (typeof LogType)[keyof typeof LogType];
export declare const LoggingConfigApplicationLogLevel: {
    /**
     * LoggingConfigApplicationLogLevel enum DEBUG
     */
    readonly DEBUG: "DEBUG";
    /**
     * LoggingConfigApplicationLogLevel enum ERROR
     */
    readonly ERROR: "ERROR";
    /**
     * LoggingConfigApplicationLogLevel enum FATAL
     */
    readonly FATAL: "FATAL";
    /**
     * LoggingConfigApplicationLogLevel enum INFO
     */
    readonly INFO: "INFO";
    /**
     * LoggingConfigApplicationLogLevel enum TRACE
     */
    readonly TRACE: "TRACE";
    /**
     * LoggingConfigApplicationLogLevel enum WARN
     */
    readonly WARN: "WARN";
};
/**
 * Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
 */
export type LoggingConfigApplicationLogLevel = (typeof LoggingConfigApplicationLogLevel)[keyof typeof LoggingConfigApplicationLogLevel];
export declare const LoggingConfigLogFormat: {
    /**
     * LoggingConfigLogFormat enum JSON
     */
    readonly JSON: "JSON";
    /**
     * LoggingConfigLogFormat enum Text
     */
    readonly Text: "Text";
};
/**
 * The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
 */
export type LoggingConfigLogFormat = (typeof LoggingConfigLogFormat)[keyof typeof LoggingConfigLogFormat];
export declare const LoggingConfigProtocol: {
    /**
     * LoggingConfigProtocol enum application
     */
    readonly Application: "application";
    /**
     * LoggingConfigProtocol enum firehose
     */
    readonly Firehose: "firehose";
    /**
     * LoggingConfigProtocol enum http/s
     */
    readonly HttpS: "http/s";
    /**
     * LoggingConfigProtocol enum lambda
     */
    readonly Lambda: "lambda";
    /**
     * LoggingConfigProtocol enum sqs
     */
    readonly Sqs: "sqs";
};
/**
 * Property protocol
 */
export type LoggingConfigProtocol = (typeof LoggingConfigProtocol)[keyof typeof LoggingConfigProtocol];
export declare const LoggingConfigSystemLogLevel: {
    /**
     * LoggingConfigSystemLogLevel enum DEBUG
     */
    readonly DEBUG: "DEBUG";
    /**
     * LoggingConfigSystemLogLevel enum INFO
     */
    readonly INFO: "INFO";
    /**
     * LoggingConfigSystemLogLevel enum WARN
     */
    readonly WARN: "WARN";
};
/**
 * Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
 */
export type LoggingConfigSystemLogLevel = (typeof LoggingConfigSystemLogLevel)[keyof typeof LoggingConfigSystemLogLevel];
export declare const LogsConfigStatusType: {
    /**
     * LogsConfigStatusType enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * LogsConfigStatusType enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property value
 */
export type LogsConfigStatusType = (typeof LogsConfigStatusType)[keyof typeof LogsConfigStatusType];
export declare const MaximumExecutionFrequency: {
    /**
     * MaximumExecutionFrequency enum One_Hour
     */
    readonly One_Hour: "One_Hour";
    /**
     * MaximumExecutionFrequency enum Six_Hours
     */
    readonly Six_Hours: "Six_Hours";
    /**
     * MaximumExecutionFrequency enum Three_Hours
     */
    readonly Three_Hours: "Three_Hours";
    /**
     * MaximumExecutionFrequency enum Twelve_Hours
     */
    readonly Twelve_Hours: "Twelve_Hours";
    /**
     * MaximumExecutionFrequency enum TwentyFour_Hours
     */
    readonly TwentyFour_Hours: "TwentyFour_Hours";
};
/**
 * Property value
 */
export type MaximumExecutionFrequency = (typeof MaximumExecutionFrequency)[keyof typeof MaximumExecutionFrequency];
export declare const MetricTransformationUnit: {
    /**
     * MetricTransformationUnit enum Bits
     */
    readonly Bits: "Bits";
    /**
     * MetricTransformationUnit enum Bits/Second
     */
    readonly BitsSecond: "Bits/Second";
    /**
     * MetricTransformationUnit enum Bytes
     */
    readonly Bytes: "Bytes";
    /**
     * MetricTransformationUnit enum Bytes/Second
     */
    readonly BytesSecond: "Bytes/Second";
    /**
     * MetricTransformationUnit enum Count
     */
    readonly Count: "Count";
    /**
     * MetricTransformationUnit enum Count/Second
     */
    readonly CountSecond: "Count/Second";
    /**
     * MetricTransformationUnit enum Gigabits
     */
    readonly Gigabits: "Gigabits";
    /**
     * MetricTransformationUnit enum Gigabits/Second
     */
    readonly GigabitsSecond: "Gigabits/Second";
    /**
     * MetricTransformationUnit enum Gigabytes
     */
    readonly Gigabytes: "Gigabytes";
    /**
     * MetricTransformationUnit enum Gigabytes/Second
     */
    readonly GigabytesSecond: "Gigabytes/Second";
    /**
     * MetricTransformationUnit enum Kilobits
     */
    readonly Kilobits: "Kilobits";
    /**
     * MetricTransformationUnit enum Kilobits/Second
     */
    readonly KilobitsSecond: "Kilobits/Second";
    /**
     * MetricTransformationUnit enum Kilobytes
     */
    readonly Kilobytes: "Kilobytes";
    /**
     * MetricTransformationUnit enum Kilobytes/Second
     */
    readonly KilobytesSecond: "Kilobytes/Second";
    /**
     * MetricTransformationUnit enum Megabits
     */
    readonly Megabits: "Megabits";
    /**
     * MetricTransformationUnit enum Megabits/Second
     */
    readonly MegabitsSecond: "Megabits/Second";
    /**
     * MetricTransformationUnit enum Megabytes
     */
    readonly Megabytes: "Megabytes";
    /**
     * MetricTransformationUnit enum Megabytes/Second
     */
    readonly MegabytesSecond: "Megabytes/Second";
    /**
     * MetricTransformationUnit enum Microseconds
     */
    readonly Microseconds: "Microseconds";
    /**
     * MetricTransformationUnit enum Milliseconds
     */
    readonly Milliseconds: "Milliseconds";
    /**
     * MetricTransformationUnit enum None
     */
    readonly None: "None";
    /**
     * MetricTransformationUnit enum Percent
     */
    readonly Percent: "Percent";
    /**
     * MetricTransformationUnit enum Seconds
     */
    readonly Seconds: "Seconds";
    /**
     * MetricTransformationUnit enum Terabits
     */
    readonly Terabits: "Terabits";
    /**
     * MetricTransformationUnit enum Terabits/Second
     */
    readonly TerabitsSecond: "Terabits/Second";
    /**
     * MetricTransformationUnit enum Terabytes
     */
    readonly Terabytes: "Terabytes";
    /**
     * MetricTransformationUnit enum Terabytes/Second
     */
    readonly TerabytesSecond: "Terabytes/Second";
};
/**
 * The unit to assign to the metric. If you omit this, the unit is set as ``None``.
 */
export type MetricTransformationUnit = (typeof MetricTransformationUnit)[keyof typeof MetricTransformationUnit];
export declare const MetricsStatus: {
    /**
     * MetricsStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * MetricsStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies whether the replication metrics are enabled.
 */
export type MetricsStatus = (typeof MetricsStatus)[keyof typeof MetricsStatus];
export declare const MitigationInEffectEnum: {
    /**
     * MitigationInEffectEnum enum no
     */
    readonly No: "no";
    /**
     * MitigationInEffectEnum enum yes
     */
    readonly Yes: "yes";
};
/**
 * Property value
 */
export type MitigationInEffectEnum = (typeof MitigationInEffectEnum)[keyof typeof MitigationInEffectEnum];
export declare const MonitoringState: {
    /**
     * MonitoringState enum disabled
     */
    readonly Disabled: "disabled";
    /**
     * MonitoringState enum disabling
     */
    readonly Disabling: "disabling";
    /**
     * MonitoringState enum enabled
     */
    readonly Enabled: "enabled";
    /**
     * MonitoringState enum pending
     */
    readonly Pending: "pending";
};
/**
 * Property value
 */
export type MonitoringState = (typeof MonitoringState)[keyof typeof MonitoringState];
export declare const NetworkInterfaceStatus: {
    /**
     * NetworkInterfaceStatus enum associated
     */
    readonly Associated: "associated";
    /**
     * NetworkInterfaceStatus enum attaching
     */
    readonly Attaching: "attaching";
    /**
     * NetworkInterfaceStatus enum available
     */
    readonly Available: "available";
    /**
     * NetworkInterfaceStatus enum detaching
     */
    readonly Detaching: "detaching";
    /**
     * NetworkInterfaceStatus enum in-use
     */
    readonly InUse: "in-use";
};
/**
 * Property value
 */
export type NetworkInterfaceStatus = (typeof NetworkInterfaceStatus)[keyof typeof NetworkInterfaceStatus];
export declare const NetworkOrigin: {
    /**
     * NetworkOrigin enum Internet
     */
    readonly Internet: "Internet";
    /**
     * NetworkOrigin enum VPC
     */
    readonly VPC: "VPC";
};
/**
 * Indicates whether this Access Point allows access from the public Internet. If VpcConfiguration is specified for this Access Point, then NetworkOrigin is VPC, and the Access Point doesn't allow access from the public Internet. Otherwise, NetworkOrigin is Internet, and the Access Point allows access from the public Internet, subject to the Access Point and bucket access policies.
 */
export type NetworkOrigin = (typeof NetworkOrigin)[keyof typeof NetworkOrigin];
export declare const NoncurrentVersionTransitionStorageClass: {
    /**
     * NoncurrentVersionTransitionStorageClass enum DEEP_ARCHIVE
     */
    readonly DEEP_ARCHIVE: "DEEP_ARCHIVE";
    /**
     * NoncurrentVersionTransitionStorageClass enum GLACIER
     */
    readonly GLACIER: "GLACIER";
    /**
     * NoncurrentVersionTransitionStorageClass enum GLACIER_IR
     */
    readonly GLACIER_IR: "GLACIER_IR";
    /**
     * NoncurrentVersionTransitionStorageClass enum INTELLIGENT_TIERING
     */
    readonly INTELLIGENT_TIERING: "INTELLIGENT_TIERING";
    /**
     * NoncurrentVersionTransitionStorageClass enum ONEZONE_IA
     */
    readonly ONEZONE_IA: "ONEZONE_IA";
    /**
     * NoncurrentVersionTransitionStorageClass enum STANDARD_IA
     */
    readonly STANDARD_IA: "STANDARD_IA";
};
/**
 * The class of storage used to store the object.
 */
export type NoncurrentVersionTransitionStorageClass = (typeof NoncurrentVersionTransitionStorageClass)[keyof typeof NoncurrentVersionTransitionStorageClass];
export declare const NotebookInstanceStatus: {
    /**
     * NotebookInstanceStatus enum Deleting
     */
    readonly Deleting: "Deleting";
    /**
     * NotebookInstanceStatus enum Failed
     */
    readonly Failed: "Failed";
    /**
     * NotebookInstanceStatus enum InService
     */
    readonly InService: "InService";
    /**
     * NotebookInstanceStatus enum Pending
     */
    readonly Pending: "Pending";
    /**
     * NotebookInstanceStatus enum Stopped
     */
    readonly Stopped: "Stopped";
    /**
     * NotebookInstanceStatus enum Stopping
     */
    readonly Stopping: "Stopping";
    /**
     * NotebookInstanceStatus enum Updating
     */
    readonly Updating: "Updating";
};
/**
 * Property value
 */
export type NotebookInstanceStatus = (typeof NotebookInstanceStatus)[keyof typeof NotebookInstanceStatus];
export declare const OpenSearchPartitionInstanceType: {
    /**
     * OpenSearchPartitionInstanceType enum c4.2xlarge.search
     */
    readonly C42xlargeSearch: "c4.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c4.4xlarge.search
     */
    readonly C44xlargeSearch: "c4.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c4.8xlarge.search
     */
    readonly C48xlargeSearch: "c4.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c4.large.search
     */
    readonly C4LargeSearch: "c4.large.search";
    /**
     * OpenSearchPartitionInstanceType enum c4.xlarge.search
     */
    readonly C4XlargeSearch: "c4.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.18xlarge.search
     */
    readonly C518xlargeSearch: "c5.18xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.2xlarge.search
     */
    readonly C52xlargeSearch: "c5.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.4xlarge.search
     */
    readonly C54xlargeSearch: "c5.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.9xlarge.search
     */
    readonly C59xlargeSearch: "c5.9xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.large.search
     */
    readonly C5LargeSearch: "c5.large.search";
    /**
     * OpenSearchPartitionInstanceType enum c5.xlarge.search
     */
    readonly C5XlargeSearch: "c5.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.12xlarge.search
     */
    readonly C6g12xlargeSearch: "c6g.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.2xlarge.search
     */
    readonly C6g2xlargeSearch: "c6g.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.4xlarge.search
     */
    readonly C6g4xlargeSearch: "c6g.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.8xlarge.search
     */
    readonly C6g8xlargeSearch: "c6g.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.large.search
     */
    readonly C6gLargeSearch: "c6g.large.search";
    /**
     * OpenSearchPartitionInstanceType enum c6g.xlarge.search
     */
    readonly C6gXlargeSearch: "c6g.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum d2.2xlarge.search
     */
    readonly D22xlargeSearch: "d2.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum d2.4xlarge.search
     */
    readonly D24xlargeSearch: "d2.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum d2.8xlarge.search
     */
    readonly D28xlargeSearch: "d2.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum d2.xlarge.search
     */
    readonly D2XlargeSearch: "d2.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i2.2xlarge.search
     */
    readonly I22xlargeSearch: "i2.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i2.xlarge.search
     */
    readonly I2XlargeSearch: "i2.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.16xlarge.search
     */
    readonly I316xlargeSearch: "i3.16xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.2xlarge.search
     */
    readonly I32xlargeSearch: "i3.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.4xlarge.search
     */
    readonly I34xlargeSearch: "i3.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.8xlarge.search
     */
    readonly I38xlargeSearch: "i3.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.large.search
     */
    readonly I3LargeSearch: "i3.large.search";
    /**
     * OpenSearchPartitionInstanceType enum i3.xlarge.search
     */
    readonly I3XlargeSearch: "i3.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m3.2xlarge.search
     */
    readonly M32xlargeSearch: "m3.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m3.large.search
     */
    readonly M3LargeSearch: "m3.large.search";
    /**
     * OpenSearchPartitionInstanceType enum m3.medium.search
     */
    readonly M3MediumSearch: "m3.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum m3.xlarge.search
     */
    readonly M3XlargeSearch: "m3.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m4.10xlarge.search
     */
    readonly M410xlargeSearch: "m4.10xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m4.2xlarge.search
     */
    readonly M42xlargeSearch: "m4.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m4.4xlarge.search
     */
    readonly M44xlargeSearch: "m4.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m4.large.search
     */
    readonly M4LargeSearch: "m4.large.search";
    /**
     * OpenSearchPartitionInstanceType enum m4.xlarge.search
     */
    readonly M4XlargeSearch: "m4.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.12xlarge.search
     */
    readonly M512xlargeSearch: "m5.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.24xlarge.search
     */
    readonly M524xlargeSearch: "m5.24xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.2xlarge.search
     */
    readonly M52xlargeSearch: "m5.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.4xlarge.search
     */
    readonly M54xlargeSearch: "m5.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.large.search
     */
    readonly M5LargeSearch: "m5.large.search";
    /**
     * OpenSearchPartitionInstanceType enum m5.xlarge.search
     */
    readonly M5XlargeSearch: "m5.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.12xlarge.search
     */
    readonly M6g12xlargeSearch: "m6g.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.2xlarge.search
     */
    readonly M6g2xlargeSearch: "m6g.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.4xlarge.search
     */
    readonly M6g4xlargeSearch: "m6g.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.8xlarge.search
     */
    readonly M6g8xlargeSearch: "m6g.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.large.search
     */
    readonly M6gLargeSearch: "m6g.large.search";
    /**
     * OpenSearchPartitionInstanceType enum m6g.xlarge.search
     */
    readonly M6gXlargeSearch: "m6g.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.12xlarge.search
     */
    readonly Or112xlargeSearch: "or1.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.16xlarge.search
     */
    readonly Or116xlargeSearch: "or1.16xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.2xlarge.search
     */
    readonly Or12xlargeSearch: "or1.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.4xlarge.search
     */
    readonly Or14xlargeSearch: "or1.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.8xlarge.search
     */
    readonly Or18xlargeSearch: "or1.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.large.search
     */
    readonly Or1LargeSearch: "or1.large.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.medium.search
     */
    readonly Or1MediumSearch: "or1.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum or1.xlarge.search
     */
    readonly Or1XlargeSearch: "or1.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r3.2xlarge.search
     */
    readonly R32xlargeSearch: "r3.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r3.4xlarge.search
     */
    readonly R34xlargeSearch: "r3.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r3.8xlarge.search
     */
    readonly R38xlargeSearch: "r3.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r3.large.search
     */
    readonly R3LargeSearch: "r3.large.search";
    /**
     * OpenSearchPartitionInstanceType enum r3.xlarge.search
     */
    readonly R3XlargeSearch: "r3.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.16xlarge.search
     */
    readonly R416xlargeSearch: "r4.16xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.2xlarge.search
     */
    readonly R42xlargeSearch: "r4.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.4xlarge.search
     */
    readonly R44xlargeSearch: "r4.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.8xlarge.search
     */
    readonly R48xlargeSearch: "r4.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.large.search
     */
    readonly R4LargeSearch: "r4.large.search";
    /**
     * OpenSearchPartitionInstanceType enum r4.xlarge.search
     */
    readonly R4XlargeSearch: "r4.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.12xlarge.search
     */
    readonly R512xlargeSearch: "r5.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.24xlarge.search
     */
    readonly R524xlargeSearch: "r5.24xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.2xlarge.search
     */
    readonly R52xlargeSearch: "r5.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.4xlarge.search
     */
    readonly R54xlargeSearch: "r5.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.large.search
     */
    readonly R5LargeSearch: "r5.large.search";
    /**
     * OpenSearchPartitionInstanceType enum r5.xlarge.search
     */
    readonly R5XlargeSearch: "r5.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.12xlarge.search
     */
    readonly R6g12xlargeSearch: "r6g.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.2xlarge.search
     */
    readonly R6g2xlargeSearch: "r6g.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.4xlarge.search
     */
    readonly R6g4xlargeSearch: "r6g.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.8xlarge.search
     */
    readonly R6g8xlargeSearch: "r6g.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.large.search
     */
    readonly R6gLargeSearch: "r6g.large.search";
    /**
     * OpenSearchPartitionInstanceType enum r6g.xlarge.search
     */
    readonly R6gXlargeSearch: "r6g.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.12xlarge.search
     */
    readonly R6gd12xlargeSearch: "r6gd.12xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.16xlarge.search
     */
    readonly R6gd16xlargeSearch: "r6gd.16xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.2xlarge.search
     */
    readonly R6gd2xlargeSearch: "r6gd.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.4xlarge.search
     */
    readonly R6gd4xlargeSearch: "r6gd.4xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.8xlarge.search
     */
    readonly R6gd8xlargeSearch: "r6gd.8xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.large.search
     */
    readonly R6gdLargeSearch: "r6gd.large.search";
    /**
     * OpenSearchPartitionInstanceType enum r6gd.xlarge.search
     */
    readonly R6gdXlargeSearch: "r6gd.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum t2.medium.search
     */
    readonly T2MediumSearch: "t2.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum t2.micro.search
     */
    readonly T2MicroSearch: "t2.micro.search";
    /**
     * OpenSearchPartitionInstanceType enum t2.small.search
     */
    readonly T2SmallSearch: "t2.small.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.2xlarge.search
     */
    readonly T32xlargeSearch: "t3.2xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.large.search
     */
    readonly T3LargeSearch: "t3.large.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.medium.search
     */
    readonly T3MediumSearch: "t3.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.micro.search
     */
    readonly T3MicroSearch: "t3.micro.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.nano.search
     */
    readonly T3NanoSearch: "t3.nano.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.small.search
     */
    readonly T3SmallSearch: "t3.small.search";
    /**
     * OpenSearchPartitionInstanceType enum t3.xlarge.search
     */
    readonly T3XlargeSearch: "t3.xlarge.search";
    /**
     * OpenSearchPartitionInstanceType enum t4g.medium.search
     */
    readonly T4gMediumSearch: "t4g.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum t4g.small.search
     */
    readonly T4gSmallSearch: "t4g.small.search";
    /**
     * OpenSearchPartitionInstanceType enum ultrawarm1.large.search
     */
    readonly Ultrawarm1LargeSearch: "ultrawarm1.large.search";
    /**
     * OpenSearchPartitionInstanceType enum ultrawarm1.medium.search
     */
    readonly Ultrawarm1MediumSearch: "ultrawarm1.medium.search";
    /**
     * OpenSearchPartitionInstanceType enum ultrawarm1.xlarge.search
     */
    readonly Ultrawarm1XlargeSearch: "ultrawarm1.xlarge.search";
};
/**
 * Property value
 */
export type OpenSearchPartitionInstanceType = (typeof OpenSearchPartitionInstanceType)[keyof typeof OpenSearchPartitionInstanceType];
export declare const OpenSearchWarmPartitionInstanceType: {
    /**
     * OpenSearchWarmPartitionInstanceType enum ultrawarm1.large.search
     */
    readonly Ultrawarm1LargeSearch: "ultrawarm1.large.search";
    /**
     * OpenSearchWarmPartitionInstanceType enum ultrawarm1.medium.search
     */
    readonly Ultrawarm1MediumSearch: "ultrawarm1.medium.search";
    /**
     * OpenSearchWarmPartitionInstanceType enum ultrawarm1.xlarge.search
     */
    readonly Ultrawarm1XlargeSearch: "ultrawarm1.xlarge.search";
};
/**
 * Property value
 */
export type OpenSearchWarmPartitionInstanceType = (typeof OpenSearchWarmPartitionInstanceType)[keyof typeof OpenSearchWarmPartitionInstanceType];
export declare const OperationLevelMetricsConfig: {
    /**
     * OperationLevelMetricsConfig enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * OperationLevelMetricsConfig enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property value
 */
export type OperationLevelMetricsConfig = (typeof OperationLevelMetricsConfig)[keyof typeof OperationLevelMetricsConfig];
export declare const OperationPreferencesRegionConcurrencyType: {
    /**
     * OperationPreferencesRegionConcurrencyType enum PARALLEL
     */
    readonly PARALLEL: "PARALLEL";
    /**
     * OperationPreferencesRegionConcurrencyType enum SEQUENTIAL
     */
    readonly SEQUENTIAL: "SEQUENTIAL";
};
/**
 * The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
 */
export type OperationPreferencesRegionConcurrencyType = (typeof OperationPreferencesRegionConcurrencyType)[keyof typeof OperationPreferencesRegionConcurrencyType];
export declare const Origin: {
    /**
     * Origin enum AWS_KMS
     */
    readonly AWS_KMS: "AWS_KMS";
    /**
     * Origin enum EXTERNAL
     */
    readonly EXTERNAL: "EXTERNAL";
};
/**
 * The source of the key material for the KMS key. You cannot change the origin after you create the KMS key. The default is ``AWS_KMS``, which means that KMS creates the key material. To [create a KMS key with no key material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-create-cmk.html) (for imported key material), set this value to ``EXTERNAL``. For more information about importing key material into KMS, see [Importing Key Material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html) in the *Developer Guide*. You can ignore ``ENABLED`` when Origin is ``EXTERNAL``. When a KMS key with Origin ``EXTERNAL`` is created, the key state is ``PENDING_IMPORT`` and ``ENABLED`` is ``false``. After you import the key material, ``ENABLED`` updated to ``true``. The KMS key can then be used for Cryptographic Operations.    CFN doesn't support creating an ``Origin`` parameter of the ``AWS_CLOUDHSM`` or ``EXTERNAL_KEY_STORE`` values.
 */
export type Origin = (typeof Origin)[keyof typeof Origin];
export declare const OwnershipControlsRuleObjectOwnership: {
    /**
     * OwnershipControlsRuleObjectOwnership enum BucketOwnerEnforced
     */
    readonly BucketOwnerEnforced: "BucketOwnerEnforced";
    /**
     * OwnershipControlsRuleObjectOwnership enum BucketOwnerPreferred
     */
    readonly BucketOwnerPreferred: "BucketOwnerPreferred";
    /**
     * OwnershipControlsRuleObjectOwnership enum ObjectWriter
     */
    readonly ObjectWriter: "ObjectWriter";
};
/**
 * Specifies an object ownership rule.
 */
export type OwnershipControlsRuleObjectOwnership = (typeof OwnershipControlsRuleObjectOwnership)[keyof typeof OwnershipControlsRuleObjectOwnership];
export declare const PackageType: {
    /**
     * PackageType enum Image
     */
    readonly Image: "Image";
    /**
     * PackageType enum Zip
     */
    readonly Zip: "Zip";
};
/**
 * The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
 */
export type PackageType = (typeof PackageType)[keyof typeof PackageType];
export declare const PartitionedPrefixPartitionDateSource: {
    /**
     * PartitionedPrefixPartitionDateSource enum DeliveryTime
     */
    readonly DeliveryTime: "DeliveryTime";
    /**
     * PartitionedPrefixPartitionDateSource enum EventTime
     */
    readonly EventTime: "EventTime";
};
/**
 * Specifies the partition date source for the partitioned prefix. PartitionDateSource can be EventTime or DeliveryTime.
 */
export type PartitionedPrefixPartitionDateSource = (typeof PartitionedPrefixPartitionDateSource)[keyof typeof PartitionedPrefixPartitionDateSource];
export declare const Permission: {
    /**
     * Permission enum FULL_CONTROL
     */
    readonly FULL_CONTROL: "FULL_CONTROL";
    /**
     * Permission enum READ
     */
    readonly READ: "READ";
    /**
     * Permission enum READ_ACP
     */
    readonly READ_ACP: "READ_ACP";
    /**
     * Permission enum WRITE
     */
    readonly WRITE: "WRITE";
    /**
     * Permission enum WRITE_ACP
     */
    readonly WRITE_ACP: "WRITE_ACP";
};
/**
 * Property value
 */
export type Permission = (typeof Permission)[keyof typeof Permission];
export declare const PermissionModel: {
    /**
     * PermissionModel enum SELF_MANAGED
     */
    readonly SELF_MANAGED: "SELF_MANAGED";
    /**
     * PermissionModel enum SERVICE_MANAGED
     */
    readonly SERVICE_MANAGED: "SERVICE_MANAGED";
};
/**
 * Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
 */
export type PermissionModel = (typeof PermissionModel)[keyof typeof PermissionModel];
export declare const PingStatus: {
    /**
     * PingStatus enum ConnectionLost
     */
    readonly ConnectionLost: "ConnectionLost";
    /**
     * PingStatus enum Inactive
     */
    readonly Inactive: "Inactive";
    /**
     * PingStatus enum Online
     */
    readonly Online: "Online";
};
/**
 * Property value
 */
export type PingStatus = (typeof PingStatus)[keyof typeof PingStatus];
export declare const PlacementConstraintType: {
    /**
     * PlacementConstraintType enum distinctInstance
     */
    readonly DistinctInstance: "distinctInstance";
    /**
     * PlacementConstraintType enum memberOf
     */
    readonly MemberOf: "memberOf";
};
/**
 * The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.
 */
export type PlacementConstraintType = (typeof PlacementConstraintType)[keyof typeof PlacementConstraintType];
export declare const PlacementGroupStrategy: {
    /**
     * PlacementGroupStrategy enum CLUSTER
     */
    readonly CLUSTER: "CLUSTER";
    /**
     * PlacementGroupStrategy enum NONE
     */
    readonly NONE: "NONE";
    /**
     * PlacementGroupStrategy enum PARTITION
     */
    readonly PARTITION: "PARTITION";
    /**
     * PlacementGroupStrategy enum SPREAD
     */
    readonly SPREAD: "SPREAD";
};
/**
 * Property value
 */
export type PlacementGroupStrategy = (typeof PlacementGroupStrategy)[keyof typeof PlacementGroupStrategy];
export declare const PlacementStrategyType: {
    /**
     * PlacementStrategyType enum binpack
     */
    readonly Binpack: "binpack";
    /**
     * PlacementStrategyType enum random
     */
    readonly Random: "random";
    /**
     * PlacementStrategyType enum spread
     */
    readonly Spread: "spread";
};
/**
 * The type of placement strategy. The ``random`` placement strategy randomly places tasks on available candidates. The ``spread`` placement strategy spreads placement across available candidates evenly based on the ``field`` parameter. The ``binpack`` strategy places tasks on available candidates that have the least available amount of the resource that's specified with the ``field`` parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory but still enough to run the task.
 */
export type PlacementStrategyType = (typeof PlacementStrategyType)[keyof typeof PlacementStrategyType];
export declare const PlatformType: {
    /**
     * PlatformType enum Linux
     */
    readonly Linux: "Linux";
    /**
     * PlatformType enum MacOS
     */
    readonly MacOS: "MacOS";
    /**
     * PlatformType enum Windows
     */
    readonly Windows: "Windows";
};
/**
 * Property value
 */
export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType];
export declare const PlatformValues: {
    /**
     * PlatformValues enum Windows
     */
    readonly Windows: "Windows";
};
/**
 * Property value
 */
export type PlatformValues = (typeof PlatformValues)[keyof typeof PlatformValues];
export declare const PointInTimeRecoveryStatus: {
    /**
     * PointInTimeRecoveryStatus enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * PointInTimeRecoveryStatus enum ENABLED
     */
    readonly ENABLED: "ENABLED";
};
/**
 * Property value
 */
export type PointInTimeRecoveryStatus = (typeof PointInTimeRecoveryStatus)[keyof typeof PointInTimeRecoveryStatus];
export declare const PortMappingAppProtocol: {
    /**
     * PortMappingAppProtocol enum grpc
     */
    readonly Grpc: "grpc";
    /**
     * PortMappingAppProtocol enum http
     */
    readonly Http: "http";
    /**
     * PortMappingAppProtocol enum http2
     */
    readonly Http2: "http2";
};
/**
 * The application protocol that's used for the port mapping. This parameter only applies to Service Connect. We recommend that you set this parameter to be consistent with the protocol that your application uses. If you set this parameter, Amazon ECS adds protocol-specific connection handling to the Service Connect proxy. If you set this parameter, Amazon ECS adds protocol-specific telemetry in the Amazon ECS console and CloudWatch. If you don't set a value for this parameter, then TCP is used. However, Amazon ECS doesn't add protocol-specific telemetry for TCP.  ``appProtocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
 */
export type PortMappingAppProtocol = (typeof PortMappingAppProtocol)[keyof typeof PortMappingAppProtocol];
export declare const ProcessorFeatureName: {
    /**
     * ProcessorFeatureName enum coreCount
     */
    readonly CoreCount: "coreCount";
    /**
     * ProcessorFeatureName enum threadsPerCore
     */
    readonly ThreadsPerCore: "threadsPerCore";
};
/**
 * The name of the processor feature. Valid names are ``coreCount`` and ``threadsPerCore``.
 */
export type ProcessorFeatureName = (typeof ProcessorFeatureName)[keyof typeof ProcessorFeatureName];
export declare const ProductCodeValues: {
    /**
     * ProductCodeValues enum devpay
     */
    readonly Devpay: "devpay";
    /**
     * ProductCodeValues enum marketplace
     */
    readonly Marketplace: "marketplace";
};
/**
 * Property value
 */
export type ProductCodeValues = (typeof ProductCodeValues)[keyof typeof ProductCodeValues];
export declare const ProjectVisibilityType: {
    /**
     * ProjectVisibilityType enum PRIVATE
     */
    readonly PRIVATE: "PRIVATE";
    /**
     * ProjectVisibilityType enum PUBLIC_READ
     */
    readonly PUBLIC_READ: "PUBLIC_READ";
};
/**
 * Property value
 */
export type ProjectVisibilityType = (typeof ProjectVisibilityType)[keyof typeof ProjectVisibilityType];
export declare const PropagateTags: {
    /**
     * PropagateTags enum SERVICE
     */
    readonly SERVICE: "SERVICE";
    /**
     * PropagateTags enum TASK_DEFINITION
     */
    readonly TASK_DEFINITION: "TASK_DEFINITION";
};
/**
 * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The default is ``NONE``.
 */
export type PropagateTags = (typeof PropagateTags)[keyof typeof PropagateTags];
export declare const PropertyValueType: {
    /**
     * PropertyValueType enum PLAIN_TEXT
     */
    readonly PLAIN_TEXT: "PLAIN_TEXT";
    /**
     * PropertyValueType enum STRINGIFIED_JSON
     */
    readonly STRINGIFIED_JSON: "STRINGIFIED_JSON";
};
/**
 * Property value
 */
export type PropertyValueType = (typeof PropertyValueType)[keyof typeof PropertyValueType];
export declare const RRType: {
    /**
     * RRType enum A
     */
    readonly A: "A";
    /**
     * RRType enum AAAA
     */
    readonly AAAA: "AAAA";
    /**
     * RRType enum CAA
     */
    readonly CAA: "CAA";
    /**
     * RRType enum CNAME
     */
    readonly CNAME: "CNAME";
    /**
     * RRType enum DS
     */
    readonly DS: "DS";
    /**
     * RRType enum MX
     */
    readonly MX: "MX";
    /**
     * RRType enum NAPTR
     */
    readonly NAPTR: "NAPTR";
    /**
     * RRType enum NS
     */
    readonly NS: "NS";
    /**
     * RRType enum PTR
     */
    readonly PTR: "PTR";
    /**
     * RRType enum SOA
     */
    readonly SOA: "SOA";
    /**
     * RRType enum SPF
     */
    readonly SPF: "SPF";
    /**
     * RRType enum SRV
     */
    readonly SRV: "SRV";
    /**
     * RRType enum TXT
     */
    readonly TXT: "TXT";
};
/**
 * Property value
 */
export type RRType = (typeof RRType)[keyof typeof RRType];
export declare const RecorderStatus: {
    /**
     * RecorderStatus enum Failure
     */
    readonly Failure: "Failure";
    /**
     * RecorderStatus enum Pending
     */
    readonly Pending: "Pending";
    /**
     * RecorderStatus enum Success
     */
    readonly Success: "Success";
};
/**
 * Property value
 */
export type RecorderStatus = (typeof RecorderStatus)[keyof typeof RecorderStatus];
export declare const RecordingFrequency: {
    /**
     * RecordingFrequency enum CONTINUOUS
     */
    readonly CONTINUOUS: "CONTINUOUS";
    /**
     * RecordingFrequency enum DAILY
     */
    readonly DAILY: "DAILY";
};
/**
 * Property value
 */
export type RecordingFrequency = (typeof RecordingFrequency)[keyof typeof RecordingFrequency];
export declare const RecordingStrategyType: {
    /**
     * RecordingStrategyType enum ALL_SUPPORTED_RESOURCE_TYPES
     */
    readonly ALL_SUPPORTED_RESOURCE_TYPES: "ALL_SUPPORTED_RESOURCE_TYPES";
    /**
     * RecordingStrategyType enum EXCLUSION_BY_RESOURCE_TYPES
     */
    readonly EXCLUSION_BY_RESOURCE_TYPES: "EXCLUSION_BY_RESOURCE_TYPES";
    /**
     * RecordingStrategyType enum INCLUSION_BY_RESOURCE_TYPES
     */
    readonly INCLUSION_BY_RESOURCE_TYPES: "INCLUSION_BY_RESOURCE_TYPES";
};
/**
 * Property value
 */
export type RecordingStrategyType = (typeof RecordingStrategyType)[keyof typeof RecordingStrategyType];
export declare const RedirectAllRequestsToProtocol: {
    /**
     * RedirectAllRequestsToProtocol enum http
     */
    readonly Http: "http";
    /**
     * RedirectAllRequestsToProtocol enum https
     */
    readonly Https: "https";
};
/**
 * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
 */
export type RedirectAllRequestsToProtocol = (typeof RedirectAllRequestsToProtocol)[keyof typeof RedirectAllRequestsToProtocol];
export declare const RedirectRuleProtocol: {
    /**
     * RedirectRuleProtocol enum http
     */
    readonly Http: "http";
    /**
     * RedirectRuleProtocol enum https
     */
    readonly Https: "https";
};
/**
 * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
 */
export type RedirectRuleProtocol = (typeof RedirectRuleProtocol)[keyof typeof RedirectRuleProtocol];
export declare const RenewalEligibility: {
    /**
     * RenewalEligibility enum ELIGIBLE
     */
    readonly ELIGIBLE: "ELIGIBLE";
    /**
     * RenewalEligibility enum INELIGIBLE
     */
    readonly INELIGIBLE: "INELIGIBLE";
};
/**
 * Property value
 */
export type RenewalEligibility = (typeof RenewalEligibility)[keyof typeof RenewalEligibility];
export declare const ReplicaModificationsStatus: {
    /**
     * ReplicaModificationsStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * ReplicaModificationsStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies whether Amazon S3 replicates modifications on replicas.  *Allowed values*: ``Enabled`` | ``Disabled``
 */
export type ReplicaModificationsStatus = (typeof ReplicaModificationsStatus)[keyof typeof ReplicaModificationsStatus];
export declare const ReplicationDestinationStorageClass: {
    /**
     * ReplicationDestinationStorageClass enum DEEP_ARCHIVE
     */
    readonly DEEP_ARCHIVE: "DEEP_ARCHIVE";
    /**
     * ReplicationDestinationStorageClass enum GLACIER
     */
    readonly GLACIER: "GLACIER";
    /**
     * ReplicationDestinationStorageClass enum GLACIER_IR
     */
    readonly GLACIER_IR: "GLACIER_IR";
    /**
     * ReplicationDestinationStorageClass enum INTELLIGENT_TIERING
     */
    readonly INTELLIGENT_TIERING: "INTELLIGENT_TIERING";
    /**
     * ReplicationDestinationStorageClass enum ONEZONE_IA
     */
    readonly ONEZONE_IA: "ONEZONE_IA";
    /**
     * ReplicationDestinationStorageClass enum REDUCED_REDUNDANCY
     */
    readonly REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY";
    /**
     * ReplicationDestinationStorageClass enum STANDARD
     */
    readonly STANDARD: "STANDARD";
    /**
     * ReplicationDestinationStorageClass enum STANDARD_IA
     */
    readonly STANDARD_IA: "STANDARD_IA";
};
/**
 * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica.  For valid values, see the ``StorageClass`` element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the *Amazon S3 API Reference*.
 */
export type ReplicationDestinationStorageClass = (typeof ReplicationDestinationStorageClass)[keyof typeof ReplicationDestinationStorageClass];
export declare const ReplicationRuleStatus: {
    /**
     * ReplicationRuleStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * ReplicationRuleStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies whether the rule is enabled.
 */
export type ReplicationRuleStatus = (typeof ReplicationRuleStatus)[keyof typeof ReplicationRuleStatus];
export declare const ReplicationTimeStatus: {
    /**
     * ReplicationTimeStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * ReplicationTimeStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies whether the replication time is enabled.
 */
export type ReplicationTimeStatus = (typeof ReplicationTimeStatus)[keyof typeof ReplicationTimeStatus];
export declare const RepoUpgradeOnBoot: {
    /**
     * RepoUpgradeOnBoot enum NONE
     */
    readonly NONE: "NONE";
    /**
     * RepoUpgradeOnBoot enum SECURITY
     */
    readonly SECURITY: "SECURITY";
};
/**
 * Property value
 */
export type RepoUpgradeOnBoot = (typeof RepoUpgradeOnBoot)[keyof typeof RepoUpgradeOnBoot];
export declare const ResolverLevelMetricsBehavior: {
    /**
     * ResolverLevelMetricsBehavior enum FULL_REQUEST_RESOLVER_METRICS
     */
    readonly FULL_REQUEST_RESOLVER_METRICS: "FULL_REQUEST_RESOLVER_METRICS";
    /**
     * ResolverLevelMetricsBehavior enum PER_RESOLVER_METRICS
     */
    readonly PER_RESOLVER_METRICS: "PER_RESOLVER_METRICS";
};
/**
 * Property value
 */
export type ResolverLevelMetricsBehavior = (typeof ResolverLevelMetricsBehavior)[keyof typeof ResolverLevelMetricsBehavior];
export declare const ResourceRecordSetFailover: {
    /**
     * ResourceRecordSetFailover enum PRIMARY
     */
    readonly PRIMARY: "PRIMARY";
    /**
     * ResourceRecordSetFailover enum SECONDARY
     */
    readonly SECONDARY: "SECONDARY";
};
/**
 * Property value
 */
export type ResourceRecordSetFailover = (typeof ResourceRecordSetFailover)[keyof typeof ResourceRecordSetFailover];
export declare const ResourceRecordSetRegion: {
    /**
     * ResourceRecordSetRegion enum af-south-1
     */
    readonly AfSouth1: "af-south-1";
    /**
     * ResourceRecordSetRegion enum ap-east-1
     */
    readonly ApEast1: "ap-east-1";
    /**
     * ResourceRecordSetRegion enum ap-northeast-1
     */
    readonly ApNortheast1: "ap-northeast-1";
    /**
     * ResourceRecordSetRegion enum ap-northeast-2
     */
    readonly ApNortheast2: "ap-northeast-2";
    /**
     * ResourceRecordSetRegion enum ap-northeast-3
     */
    readonly ApNortheast3: "ap-northeast-3";
    /**
     * ResourceRecordSetRegion enum ap-south-1
     */
    readonly ApSouth1: "ap-south-1";
    /**
     * ResourceRecordSetRegion enum ap-south-2
     */
    readonly ApSouth2: "ap-south-2";
    /**
     * ResourceRecordSetRegion enum ap-southeast-1
     */
    readonly ApSoutheast1: "ap-southeast-1";
    /**
     * ResourceRecordSetRegion enum ap-southeast-2
     */
    readonly ApSoutheast2: "ap-southeast-2";
    /**
     * ResourceRecordSetRegion enum ap-southeast-3
     */
    readonly ApSoutheast3: "ap-southeast-3";
    /**
     * ResourceRecordSetRegion enum ap-southeast-4
     */
    readonly ApSoutheast4: "ap-southeast-4";
    /**
     * ResourceRecordSetRegion enum ca-central-1
     */
    readonly CaCentral1: "ca-central-1";
    /**
     * ResourceRecordSetRegion enum ca-west-1
     */
    readonly CaWest1: "ca-west-1";
    /**
     * ResourceRecordSetRegion enum cn-north-1
     */
    readonly CnNorth1: "cn-north-1";
    /**
     * ResourceRecordSetRegion enum cn-northwest-1
     */
    readonly CnNorthwest1: "cn-northwest-1";
    /**
     * ResourceRecordSetRegion enum eu-central-1
     */
    readonly EuCentral1: "eu-central-1";
    /**
     * ResourceRecordSetRegion enum eu-central-2
     */
    readonly EuCentral2: "eu-central-2";
    /**
     * ResourceRecordSetRegion enum eu-north-1
     */
    readonly EuNorth1: "eu-north-1";
    /**
     * ResourceRecordSetRegion enum eu-south-1
     */
    readonly EuSouth1: "eu-south-1";
    /**
     * ResourceRecordSetRegion enum eu-south-2
     */
    readonly EuSouth2: "eu-south-2";
    /**
     * ResourceRecordSetRegion enum eu-west-1
     */
    readonly EuWest1: "eu-west-1";
    /**
     * ResourceRecordSetRegion enum eu-west-2
     */
    readonly EuWest2: "eu-west-2";
    /**
     * ResourceRecordSetRegion enum eu-west-3
     */
    readonly EuWest3: "eu-west-3";
    /**
     * ResourceRecordSetRegion enum il-central-1
     */
    readonly IlCentral1: "il-central-1";
    /**
     * ResourceRecordSetRegion enum me-central-1
     */
    readonly MeCentral1: "me-central-1";
    /**
     * ResourceRecordSetRegion enum me-south-1
     */
    readonly MeSouth1: "me-south-1";
    /**
     * ResourceRecordSetRegion enum sa-east-1
     */
    readonly SaEast1: "sa-east-1";
    /**
     * ResourceRecordSetRegion enum us-east-1
     */
    readonly UsEast1: "us-east-1";
    /**
     * ResourceRecordSetRegion enum us-east-2
     */
    readonly UsEast2: "us-east-2";
    /**
     * ResourceRecordSetRegion enum us-west-1
     */
    readonly UsWest1: "us-west-1";
    /**
     * ResourceRecordSetRegion enum us-west-2
     */
    readonly UsWest2: "us-west-2";
};
/**
 * Property value
 */
export type ResourceRecordSetRegion = (typeof ResourceRecordSetRegion)[keyof typeof ResourceRecordSetRegion];
export declare const ResourceSpecInstanceType: {
    /**
     * ResourceSpecInstanceType enum ml.c5.12xlarge
     */
    readonly MlC512xlarge: "ml.c5.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.18xlarge
     */
    readonly MlC518xlarge: "ml.c5.18xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.24xlarge
     */
    readonly MlC524xlarge: "ml.c5.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.2xlarge
     */
    readonly MlC52xlarge: "ml.c5.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.4xlarge
     */
    readonly MlC54xlarge: "ml.c5.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.9xlarge
     */
    readonly MlC59xlarge: "ml.c5.9xlarge";
    /**
     * ResourceSpecInstanceType enum ml.c5.large
     */
    readonly MlC5Large: "ml.c5.large";
    /**
     * ResourceSpecInstanceType enum ml.c5.xlarge
     */
    readonly MlC5Xlarge: "ml.c5.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.12xlarge
     */
    readonly MlG4dn12xlarge: "ml.g4dn.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.16xlarge
     */
    readonly MlG4dn16xlarge: "ml.g4dn.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.2xlarge
     */
    readonly MlG4dn2xlarge: "ml.g4dn.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.4xlarge
     */
    readonly MlG4dn4xlarge: "ml.g4dn.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.8xlarge
     */
    readonly MlG4dn8xlarge: "ml.g4dn.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g4dn.xlarge
     */
    readonly MlG4dnXlarge: "ml.g4dn.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.12xlarge
     */
    readonly MlG512xlarge: "ml.g5.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.16xlarge
     */
    readonly MlG516xlarge: "ml.g5.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.24xlarge
     */
    readonly MlG524xlarge: "ml.g5.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.2xlarge
     */
    readonly MlG52xlarge: "ml.g5.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.48xlarge
     */
    readonly MlG548xlarge: "ml.g5.48xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.4xlarge
     */
    readonly MlG54xlarge: "ml.g5.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.8xlarge
     */
    readonly MlG58xlarge: "ml.g5.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.g5.xlarge
     */
    readonly MlG5Xlarge: "ml.g5.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.geospatial.interactive
     */
    readonly MlGeospatialInteractive: "ml.geospatial.interactive";
    /**
     * ResourceSpecInstanceType enum ml.m5.12xlarge
     */
    readonly MlM512xlarge: "ml.m5.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.16xlarge
     */
    readonly MlM516xlarge: "ml.m5.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.24xlarge
     */
    readonly MlM524xlarge: "ml.m5.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.2xlarge
     */
    readonly MlM52xlarge: "ml.m5.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.4xlarge
     */
    readonly MlM54xlarge: "ml.m5.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.8xlarge
     */
    readonly MlM58xlarge: "ml.m5.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5.large
     */
    readonly MlM5Large: "ml.m5.large";
    /**
     * ResourceSpecInstanceType enum ml.m5.xlarge
     */
    readonly MlM5Xlarge: "ml.m5.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.12xlarge
     */
    readonly MlM5d12xlarge: "ml.m5d.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.16xlarge
     */
    readonly MlM5d16xlarge: "ml.m5d.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.24xlarge
     */
    readonly MlM5d24xlarge: "ml.m5d.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.2xlarge
     */
    readonly MlM5d2xlarge: "ml.m5d.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.4xlarge
     */
    readonly MlM5d4xlarge: "ml.m5d.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.8xlarge
     */
    readonly MlM5d8xlarge: "ml.m5d.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.m5d.large
     */
    readonly MlM5dLarge: "ml.m5d.large";
    /**
     * ResourceSpecInstanceType enum ml.m5d.xlarge
     */
    readonly MlM5dXlarge: "ml.m5d.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p3.16xlarge
     */
    readonly MlP316xlarge: "ml.p3.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p3.2xlarge
     */
    readonly MlP32xlarge: "ml.p3.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p3.8xlarge
     */
    readonly MlP38xlarge: "ml.p3.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p3dn.24xlarge
     */
    readonly MlP3dn24xlarge: "ml.p3dn.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p4d.24xlarge
     */
    readonly MlP4d24xlarge: "ml.p4d.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.p4de.24xlarge
     */
    readonly MlP4de24xlarge: "ml.p4de.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.12xlarge
     */
    readonly MlR512xlarge: "ml.r5.12xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.16xlarge
     */
    readonly MlR516xlarge: "ml.r5.16xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.24xlarge
     */
    readonly MlR524xlarge: "ml.r5.24xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.2xlarge
     */
    readonly MlR52xlarge: "ml.r5.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.4xlarge
     */
    readonly MlR54xlarge: "ml.r5.4xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.8xlarge
     */
    readonly MlR58xlarge: "ml.r5.8xlarge";
    /**
     * ResourceSpecInstanceType enum ml.r5.large
     */
    readonly MlR5Large: "ml.r5.large";
    /**
     * ResourceSpecInstanceType enum ml.r5.xlarge
     */
    readonly MlR5Xlarge: "ml.r5.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.t3.2xlarge
     */
    readonly MlT32xlarge: "ml.t3.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.t3.large
     */
    readonly MlT3Large: "ml.t3.large";
    /**
     * ResourceSpecInstanceType enum ml.t3.medium
     */
    readonly MlT3Medium: "ml.t3.medium";
    /**
     * ResourceSpecInstanceType enum ml.t3.micro
     */
    readonly MlT3Micro: "ml.t3.micro";
    /**
     * ResourceSpecInstanceType enum ml.t3.small
     */
    readonly MlT3Small: "ml.t3.small";
    /**
     * ResourceSpecInstanceType enum ml.t3.xlarge
     */
    readonly MlT3Xlarge: "ml.t3.xlarge";
    /**
     * ResourceSpecInstanceType enum ml.trn1.2xlarge
     */
    readonly MlTrn12xlarge: "ml.trn1.2xlarge";
    /**
     * ResourceSpecInstanceType enum ml.trn1.32xlarge
     */
    readonly MlTrn132xlarge: "ml.trn1.32xlarge";
    /**
     * ResourceSpecInstanceType enum ml.trn1n.32xlarge
     */
    readonly MlTrn1n32xlarge: "ml.trn1n.32xlarge";
    /**
     * ResourceSpecInstanceType enum system
     */
    readonly System: "system";
};
/**
 * The instance type that the image version runs on.
 */
export type ResourceSpecInstanceType = (typeof ResourceSpecInstanceType)[keyof typeof ResourceSpecInstanceType];
export declare const ResourceType: {
    /**
     * ResourceType enum EC2Instance
     */
    readonly EC2Instance: "EC2Instance";
    /**
     * ResourceType enum ManagedInstance
     */
    readonly ManagedInstance: "ManagedInstance";
};
/**
 * Property value
 */
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export declare const RuleStatus: {
    /**
     * RuleStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * RuleStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * If ``Enabled``, the rule is currently being applied. If ``Disabled``, the rule is not currently being applied.
 */
export type RuleStatus = (typeof RuleStatus)[keyof typeof RuleStatus];
export declare const RulesSourceListGeneratedRulesType: {
    /**
     * RulesSourceListGeneratedRulesType enum ALLOWLIST
     */
    readonly ALLOWLIST: "ALLOWLIST";
    /**
     * RulesSourceListGeneratedRulesType enum DENYLIST
     */
    readonly DENYLIST: "DENYLIST";
};
/**
 * Property generatedRulesType
 */
export type RulesSourceListGeneratedRulesType = (typeof RulesSourceListGeneratedRulesType)[keyof typeof RulesSourceListGeneratedRulesType];
export declare const RuntimeManagementConfigUpdateRuntimeOn: {
    /**
     * RuntimeManagementConfigUpdateRuntimeOn enum Auto
     */
    readonly Auto: "Auto";
    /**
     * RuntimeManagementConfigUpdateRuntimeOn enum FunctionUpdate
     */
    readonly FunctionUpdate: "FunctionUpdate";
    /**
     * RuntimeManagementConfigUpdateRuntimeOn enum Manual
     */
    readonly Manual: "Manual";
};
/**
 * Specify the runtime update mode.  +   *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.  +   *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.  +   *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).    *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
 */
export type RuntimeManagementConfigUpdateRuntimeOn = (typeof RuntimeManagementConfigUpdateRuntimeOn)[keyof typeof RuntimeManagementConfigUpdateRuntimeOn];
export declare const SSEStatus: {
    /**
     * SSEStatus enum DISABLED
     */
    readonly DISABLED: "DISABLED";
    /**
     * SSEStatus enum DISABLING
     */
    readonly DISABLING: "DISABLING";
    /**
     * SSEStatus enum ENABLED
     */
    readonly ENABLED: "ENABLED";
    /**
     * SSEStatus enum ENABLING
     */
    readonly ENABLING: "ENABLING";
};
/**
 * Property value
 */
export type SSEStatus = (typeof SSEStatus)[keyof typeof SSEStatus];
export declare const SSEType: {
    /**
     * SSEType enum none
     */
    readonly None: "none";
    /**
     * SSEType enum sse-ebs
     */
    readonly SseEbs: "sse-ebs";
    /**
     * SSEType enum sse-kms
     */
    readonly SseKms: "sse-kms";
};
/**
 * Property value
 */
export type SSEType = (typeof SSEType)[keyof typeof SSEType];
export declare const ScaleDownBehavior: {
    /**
     * ScaleDownBehavior enum TERMINATE_AT_INSTANCE_HOUR
     */
    readonly TERMINATE_AT_INSTANCE_HOUR: "TERMINATE_AT_INSTANCE_HOUR";
    /**
     * ScaleDownBehavior enum TERMINATE_AT_TASK_COMPLETION
     */
    readonly TERMINATE_AT_TASK_COMPLETION: "TERMINATE_AT_TASK_COMPLETION";
};
/**
 * Property value
 */
export type ScaleDownBehavior = (typeof ScaleDownBehavior)[keyof typeof ScaleDownBehavior];
export declare const ScanStatus: {
    /**
     * ScanStatus enum ACTIVE
     */
    readonly ACTIVE: "ACTIVE";
    /**
     * ScanStatus enum COMPLETE
     */
    readonly COMPLETE: "COMPLETE";
    /**
     * ScanStatus enum FAILED
     */
    readonly FAILED: "FAILED";
    /**
     * ScanStatus enum FINDINGS_UNAVAILABLE
     */
    readonly FINDINGS_UNAVAILABLE: "FINDINGS_UNAVAILABLE";
    /**
     * ScanStatus enum IN_PROGRESS
     */
    readonly IN_PROGRESS: "IN_PROGRESS";
    /**
     * ScanStatus enum PENDING
     */
    readonly PENDING: "PENDING";
    /**
     * ScanStatus enum SCAN_ELIGIBILITY_EXPIRED
     */
    readonly SCAN_ELIGIBILITY_EXPIRED: "SCAN_ELIGIBILITY_EXPIRED";
    /**
     * ScanStatus enum UNSUPPORTED_IMAGE
     */
    readonly UNSUPPORTED_IMAGE: "UNSUPPORTED_IMAGE";
};
/**
 * Property value
 */
export type ScanStatus = (typeof ScanStatus)[keyof typeof ScanStatus];
export declare const SchedulingStrategy: {
    /**
     * SchedulingStrategy enum DAEMON
     */
    readonly DAEMON: "DAEMON";
    /**
     * SchedulingStrategy enum REPLICA
     */
    readonly REPLICA: "REPLICA";
};
/**
 * The scheduling strategy to use for the service. For more information, see [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service scheduler strategies available:  +   ``REPLICA``-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types.  +   ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies.  Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types don't support the ``DAEMON`` scheduling strategy.
 */
export type SchedulingStrategy = (typeof SchedulingStrategy)[keyof typeof SchedulingStrategy];
export declare const ServerSideEncryptionByDefaultSSEAlgorithm: {
    /**
     * ServerSideEncryptionByDefaultSSEAlgorithm enum AES256
     */
    readonly AES256: "AES256";
    /**
     * ServerSideEncryptionByDefaultSSEAlgorithm enum aws:kms
     */
    readonly AwsKms: "aws:kms";
    /**
     * ServerSideEncryptionByDefaultSSEAlgorithm enum aws:kms:dsse
     */
    readonly AwsKmsDsse: "aws:kms:dsse";
};
/**
 * Server-side encryption algorithm to use for the default encryption.
 */
export type ServerSideEncryptionByDefaultSSEAlgorithm = (typeof ServerSideEncryptionByDefaultSSEAlgorithm)[keyof typeof ServerSideEncryptionByDefaultSSEAlgorithm];
export declare const ServerType: {
    /**
     * ServerType enum BITBUCKET
     */
    readonly BITBUCKET: "BITBUCKET";
    /**
     * ServerType enum GITHUB
     */
    readonly GITHUB: "GITHUB";
    /**
     * ServerType enum GITHUB_ENTERPRISE
     */
    readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
    /**
     * ServerType enum GITLAB
     */
    readonly GITLAB: "GITLAB";
    /**
     * ServerType enum GITLAB_SELF_MANAGED
     */
    readonly GITLAB_SELF_MANAGED: "GITLAB_SELF_MANAGED";
};
/**
 * Property value
 */
export type ServerType = (typeof ServerType)[keyof typeof ServerType];
export declare const SimpleCriterionKeyForJob: {
    /**
     * SimpleCriterionKeyForJob enum ACCOUNT_ID
     */
    readonly ACCOUNT_ID: "ACCOUNT_ID";
    /**
     * SimpleCriterionKeyForJob enum S3_BUCKET_EFFECTIVE_PERMISSION
     */
    readonly S3_BUCKET_EFFECTIVE_PERMISSION: "S3_BUCKET_EFFECTIVE_PERMISSION";
    /**
     * SimpleCriterionKeyForJob enum S3_BUCKET_NAME
     */
    readonly S3_BUCKET_NAME: "S3_BUCKET_NAME";
    /**
     * SimpleCriterionKeyForJob enum S3_BUCKET_SHARED_ACCESS
     */
    readonly S3_BUCKET_SHARED_ACCESS: "S3_BUCKET_SHARED_ACCESS";
};
/**
 * Property value
 */
export type SimpleCriterionKeyForJob = (typeof SimpleCriterionKeyForJob)[keyof typeof SimpleCriterionKeyForJob];
export declare const SnapStartApplyOn: {
    /**
     * SnapStartApplyOn enum None
     */
    readonly None: "None";
    /**
     * SnapStartApplyOn enum PublishedVersions
     */
    readonly PublishedVersions: "PublishedVersions";
};
/**
 * Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
 */
export type SnapStartApplyOn = (typeof SnapStartApplyOn)[keyof typeof SnapStartApplyOn];
export declare const SnapshotState: {
    /**
     * SnapshotState enum completed
     */
    readonly Completed: "completed";
    /**
     * SnapshotState enum error
     */
    readonly Error: "error";
    /**
     * SnapshotState enum pending
     */
    readonly Pending: "pending";
    /**
     * SnapshotState enum recoverable
     */
    readonly Recoverable: "recoverable";
    /**
     * SnapshotState enum recovering
     */
    readonly Recovering: "recovering";
};
/**
 * Property value
 */
export type SnapshotState = (typeof SnapshotState)[keyof typeof SnapshotState];
export declare const SourceAuthType: {
    /**
     * SourceAuthType enum CODECONNECTIONS
     */
    readonly CODECONNECTIONS: "CODECONNECTIONS";
    /**
     * SourceAuthType enum OAUTH
     */
    readonly OAUTH: "OAUTH";
};
/**
 * Property value
 */
export type SourceAuthType = (typeof SourceAuthType)[keyof typeof SourceAuthType];
export declare const SourceType: {
    /**
     * SourceType enum AWS::EC2::Instance
     */
    readonly AWSEC2Instance: "AWS::EC2::Instance";
    /**
     * SourceType enum AWS::IoT::Thing
     */
    readonly AWSIoTThing: "AWS::IoT::Thing";
    /**
     * SourceType enum AWS::SSM::ManagedInstance
     */
    readonly AWSSSMManagedInstance: "AWS::SSM::ManagedInstance";
};
/**
 * Property value
 */
export type SourceType = (typeof SourceType)[keyof typeof SourceType];
export declare const SseKmsEncryptedObjectsStatus: {
    /**
     * SseKmsEncryptedObjectsStatus enum Disabled
     */
    readonly Disabled: "Disabled";
    /**
     * SseKmsEncryptedObjectsStatus enum Enabled
     */
    readonly Enabled: "Enabled";
};
/**
 * Specifies whether Amazon S3 replicates objects created with server-side encryption using an AWS KMS key stored in AWS Key Management Service.
 */
export type SseKmsEncryptedObjectsStatus = (typeof SseKmsEncryptedObjectsStatus)[keyof typeof SseKmsEncryptedObjectsStatus];
export declare const StackStatus: {
    /**
     * StackStatus enum CREATE_COMPLETE
     */
    readonly CREATE_COMPLETE: "CREATE_COMPLETE";
    /**
     * StackStatus enum CREATE_FAILED
     */
    readonly CREATE_FAILED: "CREATE_FAILED";
    /**
     * StackStatus enum CREATE_IN_PROGRESS
     */
    readonly CREATE_IN_PROGRESS: "CREATE_IN_PROGRESS";
    /**
     * StackStatus enum DELETE_COMPLETE
     */
    readonly DELETE_COMPLETE: "DELETE_COMPLETE";
    /**
     * StackStatus enum DELETE_FAILED
     */
    readonly DELETE_FAILED: "DELETE_FAILED";
    /**
     * StackStatus enum DELETE_IN_PROGRESS
     */
    readonly DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS";
    /**
     * StackStatus enum IMPORT_COMPLETE
     */
    readonly IMPORT_COMPLETE: "IMPORT_COMPLETE";
    /**
     * StackStatus enum IMPORT_IN_PROGRESS
     */
    readonly IMPORT_IN_PROGRESS: "IMPORT_IN_PROGRESS";
    /**
     * StackStatus enum IMPORT_ROLLBACK_COMPLETE
     */
    readonly IMPORT_ROLLBACK_COMPLETE: "IMPORT_ROLLBACK_COMPLETE";
    /**
     * StackStatus enum IMPORT_ROLLBACK_FAILED
     */
    readonly IMPORT_ROLLBACK_FAILED: "IMPORT_ROLLBACK_FAILED";
    /**
     * StackStatus enum IMPORT_ROLLBACK_IN_PROGRESS
     */
    readonly IMPORT_ROLLBACK_IN_PROGRESS: "IMPORT_ROLLBACK_IN_PROGRESS";
    /**
     * StackStatus enum REVIEW_IN_PROGRESS
     */
    readonly REVIEW_IN_PROGRESS: "REVIEW_IN_PROGRESS";
    /**
     * StackStatus enum ROLLBACK_COMPLETE
     */
    readonly ROLLBACK_COMPLETE: "ROLLBACK_COMPLETE";
    /**
     * StackStatus enum ROLLBACK_FAILED
     */
    readonly ROLLBACK_FAILED: "ROLLBACK_FAILED";
    /**
     * StackStatus enum ROLLBACK_IN_PROGRESS
     */
    readonly ROLLBACK_IN_PROGRESS: "ROLLBACK_IN_PROGRESS";
    /**
     * StackStatus enum UPDATE_COMPLETE
     */
    readonly UPDATE_COMPLETE: "UPDATE_COMPLETE";
    /**
     * StackStatus enum UPDATE_COMPLETE_CLEANUP_IN_PROGRESS
     */
    readonly UPDATE_COMPLETE_CLEANUP_IN_PROGRESS: "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS";
    /**
     * StackStatus enum UPDATE_FAILED
     */
    readonly UPDATE_FAILED: "UPDATE_FAILED";
    /**
     * StackStatus enum UPDATE_IN_PROGRESS
     */
    readonly UPDATE_IN_PROGRESS: "UPDATE_IN_PROGRESS";
    /**
     * StackStatus enum UPDATE_ROLLBACK_COMPLETE
     */
    readonly UPDATE_ROLLBACK_COMPLETE: "UPDATE_ROLLBACK_COMPLETE";
    /**
     * StackStatus enum UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS
     */
    readonly UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS: "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS";
    /**
     * StackStatus enum UPDATE_ROLLBACK_FAILED
     */
    readonly UPDATE_ROLLBACK_FAILED: "UPDATE_ROLLBACK_FAILED";
    /**
     * StackStatus enum UPDATE_ROLLBACK_IN_PROGRESS
     */
    readonly UPDATE_ROLLBACK_IN_PROGRESS: "UPDATE_ROLLBACK_IN_PROGRESS";
};
/**
 * Property stackStatus
 */
export type StackStatus = (typeof StackStatus)[keyof typeof StackStatus];
export declare const StatefulEngineOptionsRuleOrder: {
    /**
     * StatefulEngineOptionsRuleOrder enum DEFAULT_ACTION_ORDER
     */
    readonly DEFAULT_ACTION_ORDER: "DEFAULT_ACTION_ORDER";
    /**
     * StatefulEngineOptionsRuleOrder enum STRICT_ORDER
     */
    readonly STRICT_ORDER: "STRICT_ORDER";
};
/**
 * Property ruleOrder
 */
export type StatefulEngineOptionsRuleOrder = (typeof StatefulEngineOptionsRuleOrder)[keyof typeof StatefulEngineOptionsRuleOrder];
export declare const StatefulEngineOptionsStreamExceptionPolicy: {
    /**
     * StatefulEngineOptionsStreamExceptionPolicy enum CONTINUE
     */
    readonly CONTINUE: "CONTINUE";
    /**
     * StatefulEngineOptionsStreamExceptionPolicy enum DROP
     */
    readonly DROP: "DROP";
    /**
     * StatefulEngineOptionsStreamExceptionPolicy enum REJECT
     */
    readonly REJECT: "REJECT";
};
/**
 * Property streamExceptionPolicy
 */
export type StatefulEngineOptionsStreamExceptionPolicy = (typeof StatefulEngineOptionsStreamExceptionPolicy)[keyof typeof StatefulEngineOptionsStreamExceptionPolicy];
export declare const StatefulRuleAction: {
    /**
     * StatefulRuleAction enum ALERT
     */
    readonly ALERT: "ALERT";
    /**
     * StatefulRuleAction enum DROP
     */
    readonly DROP: "DROP";
    /**
     * StatefulRuleAction enum PASS
     */
    readonly PASS: "PASS";
    /**
     * StatefulRuleAction enum REJECT
     */
    readonly REJECT: "REJECT";
};
/**
 * Property action
 */
export type StatefulRuleAction = (typeof StatefulRuleAction)[keyof typeof StatefulRuleAction];
export declare const StatefulRuleGroupOverrideAction: {
    /**
     * StatefulRuleGroupOverrideAction enum DROP_TO_ALERT
     */
    readonly DROP_TO_ALERT: "DROP_TO_ALERT";
};
/**
 * Property action
 */
export type StatefulRuleGroupOverrideAction = (typeof StatefulRuleGroupOverrideAction)[keyof typeof StatefulRuleGroupOverrideAction];
export declare const StatefulRuleOptionsRuleOrder: {
    /**
     * StatefulRuleOptionsRuleOrder enum DEFAULT_ACTION_ORDER
     */
    readonly DEFAULT_ACTION_ORDER: "DEFAULT_ACTION_ORDER";
    /**
     * StatefulRuleOptionsRuleOrder enum STRICT_ORDER
     */
    readonly STRICT_ORDER: "STRICT_ORDER";
};
/**
 * Property ruleOrder
 */
export type StatefulRuleOptionsRuleOrder = (typeof StatefulRuleOptionsRuleOrder)[keyof typeof StatefulRuleOptionsRuleOrder];
export declare const Status: {
    /**
     * Status enum ACTIVE
     */
    readonly ACTIVE: "ACTIVE";
    /**
     * Status enum PENDING_CLOSURE
     */
    readonly PENDING_CLOSURE: "PENDING_CLOSURE";
    /**
     * Status enum SUSPENDED
     */
    readonly SUSPENDED: "SUSPENDED";
};
/**
 * The status of the account in the organization.
 */
export type Status = (typeof Status)[keyof typeof Status];
export declare const StatusName: {
    /**
     * StatusName enum reachability
     */
    readonly Reachability: "reachability";
};
/**
 * Property value
 */
export type StatusName = (typeof StatusName)[keyof typeof StatusName];
export declare const StatusType: {
    /**
     * statusType enum Active
     */
    readonly Active: "Active";
    /**
     * statusType enum Inactive
     */
    readonly Inactive: "Inactive";
};
/**
 * Property value
 */
export type StatusType = (typeof StatusType)[keyof typeof StatusType];
export declare const StorageTier: {
    /**
     * StorageTier enum archive
     */
    readonly Archive: "archive";
    /**
     * StorageTier enum standard
     */
    readonly Standard: "standard";
};
/**
 * Property value
 */
export type StorageTier = (typeof StorageTier)[keyof typeof StorageTier];
export declare const SummaryStatus: {
    /**
     * SummaryStatus enum impaired
     */
    readonly Impaired: "impaired";
    /**
     * SummaryStatus enum initializing
     */
    readonly Initializing: "initializing";
    /**
     * SummaryStatus enum insufficient-data
     */
    readonly InsufficientData: "insufficient-data";
    /**
     * SummaryStatus enum not-applicable
     */
    readonly NotApplicable: "not-applicable";
    /**
     * SummaryStatus enum ok
     */
    readonly Ok: "ok";
};
/**
 * Property value
 */
export type SummaryStatus = (typeof SummaryStatus)[keyof typeof SummaryStatus];
export declare const TLSSecurityPolicy: {
    /**
     * TLSSecurityPolicy enum Policy-Min-TLS-1-0-2019-07
     */
    readonly PolicyMinTLS10201907: "Policy-Min-TLS-1-0-2019-07";
    /**
     * TLSSecurityPolicy enum Policy-Min-TLS-1-2-2019-07
     */
    readonly PolicyMinTLS12201907: "Policy-Min-TLS-1-2-2019-07";
    /**
     * TLSSecurityPolicy enum Policy-Min-TLS-1-2-PFS-2023-10
     */
    readonly PolicyMinTLS12PFS202310: "Policy-Min-TLS-1-2-PFS-2023-10";
};
/**
 * Property value
 */
export type TLSSecurityPolicy = (typeof TLSSecurityPolicy)[keyof typeof TLSSecurityPolicy];
export declare const TargetHealthReasonEnum: {
    /**
     * TargetHealthReasonEnum enum Elb.InitialHealthChecking
     */
    readonly ElbInitialHealthChecking: "Elb.InitialHealthChecking";
    /**
     * TargetHealthReasonEnum enum Elb.InternalError
     */
    readonly ElbInternalError: "Elb.InternalError";
    /**
     * TargetHealthReasonEnum enum Elb.RegistrationInProgress
     */
    readonly ElbRegistrationInProgress: "Elb.RegistrationInProgress";
    /**
     * TargetHealthReasonEnum enum Target.DeregistrationInProgress
     */
    readonly TargetDeregistrationInProgress: "Target.DeregistrationInProgress";
    /**
     * TargetHealthReasonEnum enum Target.FailedHealthChecks
     */
    readonly TargetFailedHealthChecks: "Target.FailedHealthChecks";
    /**
     * TargetHealthReasonEnum enum Target.HealthCheckDisabled
     */
    readonly TargetHealthCheckDisabled: "Target.HealthCheckDisabled";
    /**
     * TargetHealthReasonEnum enum Target.InvalidState
     */
    readonly TargetInvalidState: "Target.InvalidState";
    /**
     * TargetHealthReasonEnum enum Target.IpUnusable
     */
    readonly TargetIpUnusable: "Target.IpUnusable";
    /**
     * TargetHealthReasonEnum enum Target.NotInUse
     */
    readonly TargetNotInUse: "Target.NotInUse";
    /**
     * TargetHealthReasonEnum enum Target.NotRegistered
     */
    readonly TargetNotRegistered: "Target.NotRegistered";
    /**
     * TargetHealthReasonEnum enum Target.ResponseCodeMismatch
     */
    readonly TargetResponseCodeMismatch: "Target.ResponseCodeMismatch";
    /**
     * TargetHealthReasonEnum enum Target.Timeout
     */
    readonly TargetTimeout: "Target.Timeout";
};
/**
 * Property value
 */
export type TargetHealthReasonEnum = (typeof TargetHealthReasonEnum)[keyof typeof TargetHealthReasonEnum];
export declare const TargetHealthStateEnum: {
    /**
     * TargetHealthStateEnum enum draining
     */
    readonly Draining: "draining";
    /**
     * TargetHealthStateEnum enum healthy
     */
    readonly Healthy: "healthy";
    /**
     * TargetHealthStateEnum enum initial
     */
    readonly Initial: "initial";
    /**
     * TargetHealthStateEnum enum unavailable
     */
    readonly Unavailable: "unavailable";
    /**
     * TargetHealthStateEnum enum unhealthy
     */
    readonly Unhealthy: "unhealthy";
    /**
     * TargetHealthStateEnum enum unhealthy.draining
     */
    readonly UnhealthyDraining: "unhealthy.draining";
    /**
     * TargetHealthStateEnum enum unused
     */
    readonly Unused: "unused";
};
/**
 * Property value
 */
export type TargetHealthStateEnum = (typeof TargetHealthStateEnum)[keyof typeof TargetHealthStateEnum];
export declare const Tenancy: {
    /**
     * Tenancy enum dedicated
     */
    readonly Dedicated: "dedicated";
    /**
     * Tenancy enum default
     */
    readonly Default: "default";
    /**
     * Tenancy enum host
     */
    readonly Host: "host";
};
/**
 * Property value
 */
export type Tenancy = (typeof Tenancy)[keyof typeof Tenancy];
export declare const Tier: {
    /**
     * Tier enum Advanced
     */
    readonly Advanced: "Advanced";
    /**
     * Tier enum Intelligent-Tiering
     */
    readonly IntelligentTiering: "Intelligent-Tiering";
    /**
     * Tier enum Standard
     */
    readonly Standard: "Standard";
};
/**
 * The parameter tier.
 */
export type Tier = (typeof Tier)[keyof typeof Tier];
export declare const TieringAccessTier: {
    /**
     * TieringAccessTier enum ARCHIVE_ACCESS
     */
    readonly ARCHIVE_ACCESS: "ARCHIVE_ACCESS";
    /**
     * TieringAccessTier enum DEEP_ARCHIVE_ACCESS
     */
    readonly DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS";
};
/**
 * S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
 */
export type TieringAccessTier = (typeof TieringAccessTier)[keyof typeof TieringAccessTier];
export declare const TpmSupportValues: {
    /**
     * TpmSupportValues enum v2.0
     */
    readonly V20: "v2.0";
};
/**
 * Property value
 */
export type TpmSupportValues = (typeof TpmSupportValues)[keyof typeof TpmSupportValues];
export declare const TracingConfigMode: {
    /**
     * TracingConfigMode enum Active
     */
    readonly Active: "Active";
    /**
     * TracingConfigMode enum PassThrough
     */
    readonly PassThrough: "PassThrough";
};
/**
 * The tracing mode.
 */
export type TracingConfigMode = (typeof TracingConfigMode)[keyof typeof TracingConfigMode];
export declare const TrafficType: {
    /**
     * TrafficType enum ACCEPT
     */
    readonly ACCEPT: "ACCEPT";
    /**
     * TrafficType enum ALL
     */
    readonly ALL: "ALL";
    /**
     * TrafficType enum REJECT
     */
    readonly REJECT: "REJECT";
};
/**
 * The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
 */
export type TrafficType = (typeof TrafficType)[keyof typeof TrafficType];
export declare const TransitionStorageClass: {
    /**
     * TransitionStorageClass enum DEEP_ARCHIVE
     */
    readonly DEEP_ARCHIVE: "DEEP_ARCHIVE";
    /**
     * TransitionStorageClass enum GLACIER
     */
    readonly GLACIER: "GLACIER";
    /**
     * TransitionStorageClass enum GLACIER_IR
     */
    readonly GLACIER_IR: "GLACIER_IR";
    /**
     * TransitionStorageClass enum INTELLIGENT_TIERING
     */
    readonly INTELLIGENT_TIERING: "INTELLIGENT_TIERING";
    /**
     * TransitionStorageClass enum ONEZONE_IA
     */
    readonly ONEZONE_IA: "ONEZONE_IA";
    /**
     * TransitionStorageClass enum STANDARD_IA
     */
    readonly STANDARD_IA: "STANDARD_IA";
};
/**
 * The storage class to which you want the object to transition.
 */
export type TransitionStorageClass = (typeof TransitionStorageClass)[keyof typeof TransitionStorageClass];
export declare const Type: {
    /**
     * Type enum String
     */
    readonly String: "String";
    /**
     * Type enum StringList
     */
    readonly StringList: "StringList";
};
/**
 * The type of parameter.
 */
export type Type = (typeof Type)[keyof typeof Type];
export declare const VersioningConfigurationStatus: {
    /**
     * VersioningConfigurationStatus enum Enabled
     */
    readonly Enabled: "Enabled";
    /**
     * VersioningConfigurationStatus enum Suspended
     */
    readonly Suspended: "Suspended";
};
/**
 * The versioning state of the bucket.
 */
export type VersioningConfigurationStatus = (typeof VersioningConfigurationStatus)[keyof typeof VersioningConfigurationStatus];
export declare const VirtualizationType: {
    /**
     * VirtualizationType enum hvm
     */
    readonly Hvm: "hvm";
    /**
     * VirtualizationType enum paravirtual
     */
    readonly Paravirtual: "paravirtual";
};
/**
 * Property value
 */
export type VirtualizationType = (typeof VirtualizationType)[keyof typeof VirtualizationType];
export declare const VolumeType: {
    /**
     * VolumeType enum gp2
     */
    readonly Gp2: "gp2";
    /**
     * VolumeType enum gp3
     */
    readonly Gp3: "gp3";
    /**
     * VolumeType enum io1
     */
    readonly Io1: "io1";
    /**
     * VolumeType enum standard
     */
    readonly Standard: "standard";
};
/**
 * Property value
 */
export type VolumeType = (typeof VolumeType)[keyof typeof VolumeType];
export declare const VpcEndpointType: {
    /**
     * VpcEndpointType enum Gateway
     */
    readonly Gateway: "Gateway";
    /**
     * VpcEndpointType enum GatewayLoadBalancer
     */
    readonly GatewayLoadBalancer: "GatewayLoadBalancer";
    /**
     * VpcEndpointType enum Interface
     */
    readonly Interface: "Interface";
};
/**
 * The type of endpoint. Default: Gateway
 */
export type VpcEndpointType = (typeof VpcEndpointType)[keyof typeof VpcEndpointType];
export declare const WebhookBuildType: {
    /**
     * WebhookBuildType enum BUILD
     */
    readonly BUILD: "BUILD";
    /**
     * WebhookBuildType enum BUILD_BATCH
     */
    readonly BUILD_BATCH: "BUILD_BATCH";
};
/**
 * Property value
 */
export type WebhookBuildType = (typeof WebhookBuildType)[keyof typeof WebhookBuildType];
export declare const WebhookFilterType: {
    /**
     * WebhookFilterType enum ACTOR_ACCOUNT_ID
     */
    readonly ACTOR_ACCOUNT_ID: "ACTOR_ACCOUNT_ID";
    /**
     * WebhookFilterType enum BASE_REF
     */
    readonly BASE_REF: "BASE_REF";
    /**
     * WebhookFilterType enum COMMIT_MESSAGE
     */
    readonly COMMIT_MESSAGE: "COMMIT_MESSAGE";
    /**
     * WebhookFilterType enum EVENT
     */
    readonly EVENT: "EVENT";
    /**
     * WebhookFilterType enum FILE_PATH
     */
    readonly FILE_PATH: "FILE_PATH";
    /**
     * WebhookFilterType enum HEAD_REF
     */
    readonly HEAD_REF: "HEAD_REF";
    /**
     * WebhookFilterType enum RELEASE_NAME
     */
    readonly RELEASE_NAME: "RELEASE_NAME";
    /**
     * WebhookFilterType enum TAG_NAME
     */
    readonly TAG_NAME: "TAG_NAME";
    /**
     * WebhookFilterType enum WORKFLOW_NAME
     */
    readonly WORKFLOW_NAME: "WORKFLOW_NAME";
};
/**
 * Property value
 */
export type WebhookFilterType = (typeof WebhookFilterType)[keyof typeof WebhookFilterType];
