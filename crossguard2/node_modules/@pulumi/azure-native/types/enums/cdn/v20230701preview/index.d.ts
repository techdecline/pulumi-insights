export declare const AFDEndpointProtocols: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Supported protocols for the customer's endpoint.
 */
export type AFDEndpointProtocols = (typeof AFDEndpointProtocols)[keyof typeof AFDEndpointProtocols];
export declare const ActionType: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly Redirect: "Redirect";
};
/**
 * Describes what action to be applied when rule matches
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const AfdCertificateType: {
    readonly CustomerCertificate: "CustomerCertificate";
    readonly ManagedCertificate: "ManagedCertificate";
    readonly AzureFirstPartyManagedCertificate: "AzureFirstPartyManagedCertificate";
};
/**
 * Defines the source of the SSL certificate.
 */
export type AfdCertificateType = (typeof AfdCertificateType)[keyof typeof AfdCertificateType];
export declare const AfdMinimumTlsVersion: {
    readonly TLS10: "TLS10";
    readonly TLS12: "TLS12";
};
/**
 * TLS protocol version that will be used for Https
 */
export type AfdMinimumTlsVersion = (typeof AfdMinimumTlsVersion)[keyof typeof AfdMinimumTlsVersion];
export declare const AfdQueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly UseQueryString: "UseQueryString";
    readonly IgnoreSpecifiedQueryStrings: "IgnoreSpecifiedQueryStrings";
    readonly IncludeSpecifiedQueryStrings: "IncludeSpecifiedQueryStrings";
};
/**
 * Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
 */
export type AfdQueryStringCachingBehavior = (typeof AfdQueryStringCachingBehavior)[keyof typeof AfdQueryStringCachingBehavior];
export declare const Algorithm: {
    readonly SHA256: "SHA256";
};
/**
 * Algorithm to use for URL signing
 */
export type Algorithm = (typeof Algorithm)[keyof typeof Algorithm];
export declare const AutoGeneratedDomainNameLabelScope: {
    readonly TenantReuse: "TenantReuse";
    readonly SubscriptionReuse: "SubscriptionReuse";
    readonly ResourceGroupReuse: "ResourceGroupReuse";
    readonly NoReuse: "NoReuse";
};
/**
 * Indicates the endpoint name reuse scope. The default value is TenantReuse.
 */
export type AutoGeneratedDomainNameLabelScope = (typeof AutoGeneratedDomainNameLabelScope)[keyof typeof AutoGeneratedDomainNameLabelScope];
export declare const CacheBehavior: {
    readonly BypassCache: "BypassCache";
    readonly Override: "Override";
    readonly SetIfMissing: "SetIfMissing";
};
/**
 * Caching behavior for the requests
 */
export type CacheBehavior = (typeof CacheBehavior)[keyof typeof CacheBehavior];
export declare const CacheType: {
    readonly All: "All";
};
/**
 * The level at which the content needs to be cached.
 */
export type CacheType = (typeof CacheType)[keyof typeof CacheType];
export declare const ClientPortOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type ClientPortOperator = (typeof ClientPortOperator)[keyof typeof ClientPortOperator];
export declare const CookiesOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type CookiesOperator = (typeof CookiesOperator)[keyof typeof CookiesOperator];
export declare const CustomRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];
export declare const DeliveryRuleAction: {
    readonly CacheExpiration: "CacheExpiration";
    readonly CacheKeyQueryString: "CacheKeyQueryString";
    readonly ModifyRequestHeader: "ModifyRequestHeader";
    readonly ModifyResponseHeader: "ModifyResponseHeader";
    readonly UrlRedirect: "UrlRedirect";
    readonly UrlRewrite: "UrlRewrite";
    readonly UrlSigning: "UrlSigning";
    readonly OriginGroupOverride: "OriginGroupOverride";
    readonly RouteConfigurationOverride: "RouteConfigurationOverride";
    readonly AfdUrlSigning: "AfdUrlSigning";
};
/**
 * The name of the action for the delivery rule.
 */
export type DeliveryRuleAction = (typeof DeliveryRuleAction)[keyof typeof DeliveryRuleAction];
export declare const DestinationProtocol: {
    readonly MatchRequest: "MatchRequest";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for the redirect. The default value is MatchRequest
 */
export type DestinationProtocol = (typeof DestinationProtocol)[keyof typeof DestinationProtocol];
export declare const EnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export type EnabledState = (typeof EnabledState)[keyof typeof EnabledState];
export declare const ForwardingProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export type ForwardingProtocol = (typeof ForwardingProtocol)[keyof typeof ForwardingProtocol];
export declare const GeoFilterActions: {
    readonly Block: "Block";
    readonly Allow: "Allow";
};
/**
 * Action of the geo filter, i.e. allow or block access.
 */
export type GeoFilterActions = (typeof GeoFilterActions)[keyof typeof GeoFilterActions];
export declare const HeaderAction: {
    readonly Append: "Append";
    readonly Overwrite: "Overwrite";
    readonly Delete: "Delete";
};
/**
 * Action to perform
 */
export type HeaderAction = (typeof HeaderAction)[keyof typeof HeaderAction];
export declare const HealthProbeRequestType: {
    readonly NotSet: "NotSet";
    readonly GET: "GET";
    readonly HEAD: "HEAD";
};
/**
 * The type of health probe request that is made.
 */
export type HealthProbeRequestType = (typeof HealthProbeRequestType)[keyof typeof HealthProbeRequestType];
export declare const HostNameOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type HostNameOperator = (typeof HostNameOperator)[keyof typeof HostNameOperator];
export declare const HttpVersionOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export type HttpVersionOperator = (typeof HttpVersionOperator)[keyof typeof HttpVersionOperator];
export declare const HttpsRedirect: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
 */
export type HttpsRedirect = (typeof HttpsRedirect)[keyof typeof HttpsRedirect];
export declare const IsDeviceOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export type IsDeviceOperator = (typeof IsDeviceOperator)[keyof typeof IsDeviceOperator];
export declare const LinkToDefaultDomain: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * whether this route will be linked to the default endpoint domain.
 */
export type LinkToDefaultDomain = (typeof LinkToDefaultDomain)[keyof typeof LinkToDefaultDomain];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const ManagedServiceIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
};
/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const MatchProcessingBehavior: {
    readonly Continue: "Continue";
    readonly Stop: "Stop";
};
/**
 * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
 */
export type MatchProcessingBehavior = (typeof MatchProcessingBehavior)[keyof typeof MatchProcessingBehavior];
export declare const MatchVariable: {
    readonly RemoteAddress: "RemoteAddress";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeader: "RequestHeader";
    readonly RequestBody: "RequestBody";
    readonly RequestScheme: "RequestScheme";
    readonly UrlPath: "UrlPath";
    readonly UrlFileExtension: "UrlFileExtension";
    readonly UrlFileName: "UrlFileName";
    readonly HttpVersion: "HttpVersion";
    readonly Cookies: "Cookies";
    readonly IsDevice: "IsDevice";
    readonly SocketAddr: "SocketAddr";
    readonly ClientPort: "ClientPort";
    readonly ServerPort: "ServerPort";
    readonly HostName: "HostName";
    readonly SslProtocol: "SslProtocol";
};
/**
 * The name of the condition for the delivery rule.
 */
export type MatchVariable = (typeof MatchVariable)[keyof typeof MatchVariable];
export declare const Operator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type Operator = (typeof Operator)[keyof typeof Operator];
export declare const OptimizationType: {
    readonly GeneralWebDelivery: "GeneralWebDelivery";
    readonly GeneralMediaStreaming: "GeneralMediaStreaming";
    readonly VideoOnDemandMediaStreaming: "VideoOnDemandMediaStreaming";
    readonly LargeFileDownload: "LargeFileDownload";
    readonly DynamicSiteAcceleration: "DynamicSiteAcceleration";
};
/**
 * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
 */
export type OptimizationType = (typeof OptimizationType)[keyof typeof OptimizationType];
export declare const ParamIndicator: {
    readonly Expires: "Expires";
    readonly KeyId: "KeyId";
    readonly Signature: "Signature";
};
/**
 * Indicates the purpose of the parameter
 */
export type ParamIndicator = (typeof ParamIndicator)[keyof typeof ParamIndicator];
export declare const PolicyEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * describes if the policy is in enabled state or disabled state
 */
export type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];
export declare const PolicyMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];
export declare const PostArgsOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type PostArgsOperator = (typeof PostArgsOperator)[keyof typeof PostArgsOperator];
export declare const ProbeProtocol: {
    readonly NotSet: "NotSet";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for health probe.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const QueryStringBehavior: {
    readonly Include: "Include";
    readonly IncludeAll: "IncludeAll";
    readonly Exclude: "Exclude";
    readonly ExcludeAll: "ExcludeAll";
};
/**
 * Caching behavior for the requests
 */
export type QueryStringBehavior = (typeof QueryStringBehavior)[keyof typeof QueryStringBehavior];
export declare const QueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly BypassCaching: "BypassCaching";
    readonly UseQueryString: "UseQueryString";
    readonly NotSet: "NotSet";
};
/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export type QueryStringCachingBehavior = (typeof QueryStringCachingBehavior)[keyof typeof QueryStringCachingBehavior];
export declare const QueryStringOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type QueryStringOperator = (typeof QueryStringOperator)[keyof typeof QueryStringOperator];
export declare const RedirectType: {
    readonly Moved: "Moved";
    readonly Found: "Found";
    readonly TemporaryRedirect: "TemporaryRedirect";
    readonly PermanentRedirect: "PermanentRedirect";
};
/**
 * The redirect type the rule will use when redirecting traffic.
 */
export type RedirectType = (typeof RedirectType)[keyof typeof RedirectType];
export declare const RemoteAddressOperator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
};
/**
 * Describes operator to be matched
 */
export type RemoteAddressOperator = (typeof RemoteAddressOperator)[keyof typeof RemoteAddressOperator];
export declare const RequestBodyOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type RequestBodyOperator = (typeof RequestBodyOperator)[keyof typeof RequestBodyOperator];
export declare const RequestHeaderOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type RequestHeaderOperator = (typeof RequestHeaderOperator)[keyof typeof RequestHeaderOperator];
export declare const RequestMethodOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export type RequestMethodOperator = (typeof RequestMethodOperator)[keyof typeof RequestMethodOperator];
export declare const RequestUriOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type RequestUriOperator = (typeof RequestUriOperator)[keyof typeof RequestUriOperator];
export declare const ResponseBasedDetectedErrorTypes: {
    readonly None: "None";
    readonly TcpErrorsOnly: "TcpErrorsOnly";
    readonly TcpAndHttpErrors: "TcpAndHttpErrors";
};
/**
 * Type of response errors for real user requests for which origin will be deemed unhealthy
 */
export type ResponseBasedDetectedErrorTypes = (typeof ResponseBasedDetectedErrorTypes)[keyof typeof ResponseBasedDetectedErrorTypes];
export declare const RuleCacheBehavior: {
    readonly HonorOrigin: "HonorOrigin";
    readonly OverrideAlways: "OverrideAlways";
    readonly OverrideIfOriginMissing: "OverrideIfOriginMissing";
};
/**
 * Caching behavior for the requests
 */
export type RuleCacheBehavior = (typeof RuleCacheBehavior)[keyof typeof RuleCacheBehavior];
export declare const RuleIsCompressionEnabled: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
 */
export type RuleIsCompressionEnabled = (typeof RuleIsCompressionEnabled)[keyof typeof RuleIsCompressionEnabled];
export declare const RuleQueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly UseQueryString: "UseQueryString";
    readonly IgnoreSpecifiedQueryStrings: "IgnoreSpecifiedQueryStrings";
    readonly IncludeSpecifiedQueryStrings: "IncludeSpecifiedQueryStrings";
};
/**
 * Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
 */
export type RuleQueryStringCachingBehavior = (typeof RuleQueryStringCachingBehavior)[keyof typeof RuleQueryStringCachingBehavior];
export declare const SecretType: {
    readonly UrlSigningKey: "UrlSigningKey";
    readonly CustomerCertificate: "CustomerCertificate";
    readonly ManagedCertificate: "ManagedCertificate";
    readonly AzureFirstPartyManagedCertificate: "AzureFirstPartyManagedCertificate";
};
/**
 * The type of the secret resource.
 */
export type SecretType = (typeof SecretType)[keyof typeof SecretType];
export declare const SecurityPolicyType: {
    readonly WebApplicationFirewall: "WebApplicationFirewall";
};
/**
 * The type of the Security policy to create.
 */
export type SecurityPolicyType = (typeof SecurityPolicyType)[keyof typeof SecurityPolicyType];
export declare const ServerPortOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type ServerPortOperator = (typeof ServerPortOperator)[keyof typeof ServerPortOperator];
export declare const SharedPrivateLinkResourceStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
    readonly Timeout: "Timeout";
};
/**
 * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
 */
export type SharedPrivateLinkResourceStatus = (typeof SharedPrivateLinkResourceStatus)[keyof typeof SharedPrivateLinkResourceStatus];
export declare const SkuName: {
    readonly Standard_Verizon: "Standard_Verizon";
    readonly Premium_Verizon: "Premium_Verizon";
    readonly Custom_Verizon: "Custom_Verizon";
    readonly Standard_Akamai: "Standard_Akamai";
    readonly Standard_ChinaCdn: "Standard_ChinaCdn";
    readonly Standard_Microsoft: "Standard_Microsoft";
    readonly Standard_AzureFrontDoor: "Standard_AzureFrontDoor";
    readonly Premium_AzureFrontDoor: "Premium_AzureFrontDoor";
    readonly Standard_955BandWidth_ChinaCdn: "Standard_955BandWidth_ChinaCdn";
    readonly Standard_AvgBandWidth_ChinaCdn: "Standard_AvgBandWidth_ChinaCdn";
    readonly StandardPlus_ChinaCdn: "StandardPlus_ChinaCdn";
    readonly StandardPlus_955BandWidth_ChinaCdn: "StandardPlus_955BandWidth_ChinaCdn";
    readonly StandardPlus_AvgBandWidth_ChinaCdn: "StandardPlus_AvgBandWidth_ChinaCdn";
};
/**
 * Name of the pricing tier.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const SocketAddrOperator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
};
/**
 * Describes operator to be matched
 */
export type SocketAddrOperator = (typeof SocketAddrOperator)[keyof typeof SocketAddrOperator];
export declare const SslProtocol: {
    readonly TLSv1: "TLSv1";
    readonly TLSv1_1: "TLSv1.1";
    readonly TLSv1_2: "TLSv1.2";
};
/**
 * The protocol of an established TLS connection.
 */
export type SslProtocol = (typeof SslProtocol)[keyof typeof SslProtocol];
export declare const SslProtocolOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export type SslProtocolOperator = (typeof SslProtocolOperator)[keyof typeof SslProtocolOperator];
export declare const Transform: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms are applied before matching
 */
export type Transform = (typeof Transform)[keyof typeof Transform];
export declare const TransformType: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms were applied before matching.
 */
export type TransformType = (typeof TransformType)[keyof typeof TransformType];
export declare const UrlFileExtensionOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type UrlFileExtensionOperator = (typeof UrlFileExtensionOperator)[keyof typeof UrlFileExtensionOperator];
export declare const UrlFileNameOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type UrlFileNameOperator = (typeof UrlFileNameOperator)[keyof typeof UrlFileNameOperator];
export declare const UrlPathOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly Wildcard: "Wildcard";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export type UrlPathOperator = (typeof UrlPathOperator)[keyof typeof UrlPathOperator];
export declare const WafMatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly SocketAddr: "SocketAddr";
    readonly RequestMethod: "RequestMethod";
    readonly RequestHeader: "RequestHeader";
    readonly RequestUri: "RequestUri";
    readonly QueryString: "QueryString";
    readonly RequestBody: "RequestBody";
    readonly Cookies: "Cookies";
    readonly PostArgs: "PostArgs";
};
/**
 * Match variable to compare against.
 */
export type WafMatchVariable = (typeof WafMatchVariable)[keyof typeof WafMatchVariable];
