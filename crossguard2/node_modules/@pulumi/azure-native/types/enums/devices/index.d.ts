import * as v20200901preview from "./v20200901preview";
import * as v20220430preview from "./v20220430preview";
import * as v20221115preview from "./v20221115preview";
import * as v20221212 from "./v20221212";
import * as v20230301preview from "./v20230301preview";
import * as v20230630 from "./v20230630";
import * as v20230630preview from "./v20230630preview";
import * as v20250201preview from "./v20250201preview";
export { v20200901preview, v20220430preview, v20221115preview, v20221212, v20230301preview, v20230630, v20230630preview, v20250201preview, };
export declare const AccessRights: {
    readonly RegistryRead: "RegistryRead";
    readonly RegistryWrite: "RegistryWrite";
    readonly ServiceConnect: "ServiceConnect";
    readonly DeviceConnect: "DeviceConnect";
    readonly RegistryRead_RegistryWrite: "RegistryRead, RegistryWrite";
    readonly RegistryRead_ServiceConnect: "RegistryRead, ServiceConnect";
    readonly RegistryRead_DeviceConnect: "RegistryRead, DeviceConnect";
    readonly RegistryWrite_ServiceConnect: "RegistryWrite, ServiceConnect";
    readonly RegistryWrite_DeviceConnect: "RegistryWrite, DeviceConnect";
    readonly ServiceConnect_DeviceConnect: "ServiceConnect, DeviceConnect";
    readonly RegistryRead_RegistryWrite_ServiceConnect: "RegistryRead, RegistryWrite, ServiceConnect";
    readonly RegistryRead_RegistryWrite_DeviceConnect: "RegistryRead, RegistryWrite, DeviceConnect";
    readonly RegistryRead_ServiceConnect_DeviceConnect: "RegistryRead, ServiceConnect, DeviceConnect";
    readonly RegistryWrite_ServiceConnect_DeviceConnect: "RegistryWrite, ServiceConnect, DeviceConnect";
    readonly RegistryRead_RegistryWrite_ServiceConnect_DeviceConnect: "RegistryRead, RegistryWrite, ServiceConnect, DeviceConnect";
};
/**
 * The permissions assigned to the shared access policy.
 */
export type AccessRights = (typeof AccessRights)[keyof typeof AccessRights];
export declare const AccessRightsDescription: {
    readonly ServiceConfig: "ServiceConfig";
    readonly EnrollmentRead: "EnrollmentRead";
    readonly EnrollmentWrite: "EnrollmentWrite";
    readonly DeviceConnect: "DeviceConnect";
    readonly RegistrationStatusRead: "RegistrationStatusRead";
    readonly RegistrationStatusWrite: "RegistrationStatusWrite";
};
/**
 * Rights that this key has.
 */
export type AccessRightsDescription = (typeof AccessRightsDescription)[keyof typeof AccessRightsDescription];
export declare const AllocationPolicy: {
    readonly Hashed: "Hashed";
    readonly GeoLatency: "GeoLatency";
    readonly Static: "Static";
};
/**
 * Allocation policy to be used by this provisioning service.
 */
export type AllocationPolicy = (typeof AllocationPolicy)[keyof typeof AllocationPolicy];
export declare const AuthenticationType: {
    readonly KeyBased: "keyBased";
    readonly IdentityBased: "identityBased";
};
/**
 * Specifies authentication type being used for connecting to the storage account.
 */
export type AuthenticationType = (typeof AuthenticationType)[keyof typeof AuthenticationType];
export declare const Capabilities: {
    readonly None: "None";
    readonly DeviceManagement: "DeviceManagement";
};
/**
 * The capabilities and features enabled for the IoT hub.
 */
export type Capabilities = (typeof Capabilities)[keyof typeof Capabilities];
export declare const DefaultAction: {
    readonly Deny: "Deny";
    readonly Allow: "Allow";
};
/**
 * Default Action for Network Rule Set
 */
export type DefaultAction = (typeof DefaultAction)[keyof typeof DefaultAction];
export declare const IotDpsSku: {
    readonly S1: "S1";
};
/**
 * Sku name.
 */
export type IotDpsSku = (typeof IotDpsSku)[keyof typeof IotDpsSku];
export declare const IotHubSku: {
    readonly F1: "F1";
    readonly S1: "S1";
    readonly S2: "S2";
    readonly S3: "S3";
    readonly B1: "B1";
    readonly B2: "B2";
    readonly B3: "B3";
};
/**
 * The name of the SKU.
 */
export type IotHubSku = (typeof IotHubSku)[keyof typeof IotHubSku];
export declare const IpFilterActionType: {
    readonly Accept: "Accept";
    readonly Reject: "Reject";
};
/**
 * The desired action for requests captured by this rule.
 */
export type IpFilterActionType = (typeof IpFilterActionType)[keyof typeof IpFilterActionType];
export declare const IpFilterTargetType: {
    readonly All: "all";
    readonly ServiceApi: "serviceApi";
    readonly DeviceApi: "deviceApi";
};
/**
 * Target for requests captured by this rule.
 */
export type IpFilterTargetType = (typeof IpFilterTargetType)[keyof typeof IpFilterTargetType];
export declare const NetworkRuleIPAction: {
    readonly Allow: "Allow";
};
/**
 * IP Filter Action
 */
export type NetworkRuleIPAction = (typeof NetworkRuleIPAction)[keyof typeof NetworkRuleIPAction];
export declare const PrivateLinkServiceConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
};
/**
 * The status of a private endpoint connection
 */
export type PrivateLinkServiceConnectionStatus = (typeof PrivateLinkServiceConnectionStatus)[keyof typeof PrivateLinkServiceConnectionStatus];
export declare const PublicNetworkAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether requests from Public Network are allowed
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const ResourceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
 */
export type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];
export declare const RoutingSource: {
    readonly Invalid: "Invalid";
    readonly DeviceMessages: "DeviceMessages";
    readonly TwinChangeEvents: "TwinChangeEvents";
    readonly DeviceLifecycleEvents: "DeviceLifecycleEvents";
    readonly DeviceJobLifecycleEvents: "DeviceJobLifecycleEvents";
    readonly DigitalTwinChangeEvents: "DigitalTwinChangeEvents";
    readonly DeviceConnectionStateEvents: "DeviceConnectionStateEvents";
    readonly MqttBrokerMessages: "MqttBrokerMessages";
};
/**
 * The source that the routing rule is to be applied to, such as DeviceMessages.
 */
export type RoutingSource = (typeof RoutingSource)[keyof typeof RoutingSource];
export declare const State: {
    readonly Activating: "Activating";
    readonly Active: "Active";
    readonly Deleting: "Deleting";
    readonly Deleted: "Deleted";
    readonly ActivationFailed: "ActivationFailed";
    readonly DeletionFailed: "DeletionFailed";
    readonly Transitioning: "Transitioning";
    readonly Suspending: "Suspending";
    readonly Suspended: "Suspended";
    readonly Resuming: "Resuming";
    readonly FailingOver: "FailingOver";
    readonly FailoverFailed: "FailoverFailed";
};
/**
 * Current state of the provisioning service.
 */
export type State = (typeof State)[keyof typeof State];
