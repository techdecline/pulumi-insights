import * as v20220101preview from "./v20220101preview";
import * as v20221001 from "./v20221001";
import * as v20230401preview from "./v20230401preview";
import * as v20230501 from "./v20230501";
import * as v20230502preview from "./v20230502preview";
import * as v20230801preview from "./v20230801preview";
import * as v20231102preview from "./v20231102preview";
import * as v20240202preview from "./v20240202preview";
import * as v20240301 from "./v20240301";
import * as v20240802preview from "./v20240802preview";
import * as v20241002preview from "./v20241002preview";
export { v20220101preview, v20221001, v20230401preview, v20230501, v20230502preview, v20230801preview, v20231102preview, v20240202preview, v20240301, v20240802preview, v20241002preview, };
export declare const AccessMode: {
    readonly ReadOnly: "ReadOnly";
    readonly ReadWrite: "ReadWrite";
};
/**
 * Access mode for storage
 */
export type AccessMode = (typeof AccessMode)[keyof typeof AccessMode];
export declare const Action: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
 */
export type Action = (typeof Action)[keyof typeof Action];
export declare const ActiveRevisionsMode: {
    readonly Multiple: "Multiple";
    readonly Single: "Single";
};
/**
 * ActiveRevisionsMode controls how active revisions are handled for the Container app:
 * <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
 */
export type ActiveRevisionsMode = (typeof ActiveRevisionsMode)[keyof typeof ActiveRevisionsMode];
export declare const AppProtocol: {
    readonly Http: "http";
    readonly Grpc: "grpc";
};
/**
 * Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
 */
export type AppProtocol = (typeof AppProtocol)[keyof typeof AppProtocol];
export declare const BindingType: {
    readonly Disabled: "Disabled";
    readonly SniEnabled: "SniEnabled";
    readonly Auto: "Auto";
};
/**
 * Custom Domain binding type.
 */
export type BindingType = (typeof BindingType)[keyof typeof BindingType];
export declare const ClientCredentialMethod: {
    readonly ClientSecretPost: "ClientSecretPost";
};
/**
 * The method that should be used to authenticate the user.
 */
export type ClientCredentialMethod = (typeof ClientCredentialMethod)[keyof typeof ClientCredentialMethod];
export declare const ContainerType: {
    readonly CustomContainer: "CustomContainer";
    readonly PythonLTS: "PythonLTS";
};
/**
 * The container type of the sessions.
 */
export type ContainerType = (typeof ContainerType)[keyof typeof ContainerType];
export declare const CookieExpirationConvention: {
    readonly FixedTime: "FixedTime";
    readonly IdentityProviderDerived: "IdentityProviderDerived";
};
/**
 * The convention used when determining the session cookie's expiration.
 */
export type CookieExpirationConvention = (typeof CookieExpirationConvention)[keyof typeof CookieExpirationConvention];
export declare const DotNetComponentType: {
    readonly AspireDashboard: "AspireDashboard";
    readonly AspireResourceServerApi: "AspireResourceServerApi";
};
/**
 * Type of the .NET Component.
 */
export type DotNetComponentType = (typeof DotNetComponentType)[keyof typeof DotNetComponentType];
export declare const ExecutionType: {
    readonly Timed: "Timed";
};
/**
 * The execution type of the session pool.
 */
export type ExecutionType = (typeof ExecutionType)[keyof typeof ExecutionType];
export declare const ExtendedLocationTypes: {
    readonly CustomLocation: "CustomLocation";
};
/**
 * The type of the extended location.
 */
export type ExtendedLocationTypes = (typeof ExtendedLocationTypes)[keyof typeof ExtendedLocationTypes];
export declare const ForwardProxyConvention: {
    readonly NoProxy: "NoProxy";
    readonly Standard: "Standard";
    readonly Custom: "Custom";
};
/**
 * The convention used to determine the url of the request made.
 */
export type ForwardProxyConvention = (typeof ForwardProxyConvention)[keyof typeof ForwardProxyConvention];
export declare const IngressClientCertificateMode: {
    readonly Ignore: "ignore";
    readonly Accept: "accept";
    readonly Require: "require";
};
/**
 * Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
 */
export type IngressClientCertificateMode = (typeof IngressClientCertificateMode)[keyof typeof IngressClientCertificateMode];
export declare const IngressTransportMethod: {
    readonly Auto: "auto";
    readonly Http: "http";
    readonly Http2: "http2";
    readonly Tcp: "tcp";
};
/**
 * Ingress transport protocol
 */
export type IngressTransportMethod = (typeof IngressTransportMethod)[keyof typeof IngressTransportMethod];
export declare const JavaComponentType: {
    readonly SpringBootAdmin: "SpringBootAdmin";
    readonly SpringCloudEureka: "SpringCloudEureka";
    readonly SpringCloudConfig: "SpringCloudConfig";
};
/**
 * Type of the Java Component.
 */
export type JavaComponentType = (typeof JavaComponentType)[keyof typeof JavaComponentType];
export declare const LogLevel: {
    readonly Info: "info";
    readonly Debug: "debug";
    readonly Warn: "warn";
    readonly Error: "error";
};
/**
 * Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
 */
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
export declare const ManagedCertificateDomainControlValidation: {
    readonly CNAME: "CNAME";
    readonly HTTP: "HTTP";
    readonly TXT: "TXT";
};
/**
 * Selected type of domain control validation for managed certificates.
 */
export type ManagedCertificateDomainControlValidation = (typeof ManagedCertificateDomainControlValidation)[keyof typeof ManagedCertificateDomainControlValidation];
export declare const ManagedEnvironmentOutBoundType: {
    readonly LoadBalancer: "LoadBalancer";
    readonly UserDefinedRouting: "UserDefinedRouting";
};
/**
 * Outbound type for the cluster
 */
export type ManagedEnvironmentOutBoundType = (typeof ManagedEnvironmentOutBoundType)[keyof typeof ManagedEnvironmentOutBoundType];
export declare const ManagedServiceIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned,UserAssigned";
};
/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const PoolManagementType: {
    readonly Manual: "Manual";
    readonly Dynamic: "Dynamic";
};
/**
 * The pool management type of the session pool.
 */
export type PoolManagementType = (typeof PoolManagementType)[keyof typeof PoolManagementType];
export declare const PrivateEndpointServiceConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
};
/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];
export declare const Scheme: {
    readonly HTTP: "HTTP";
    readonly HTTPS: "HTTPS";
};
/**
 * Scheme to use for connecting to the host. Defaults to HTTP.
 */
export type Scheme = (typeof Scheme)[keyof typeof Scheme];
export declare const SessionNetworkStatus: {
    readonly EgressEnabled: "EgressEnabled";
    readonly EgressDisabled: "EgressDisabled";
};
/**
 * Network status for the sessions.
 */
export type SessionNetworkStatus = (typeof SessionNetworkStatus)[keyof typeof SessionNetworkStatus];
export declare const SkuName: {
    /**
     * Consumption SKU of Managed Environment.
     */
    readonly Consumption: "Consumption";
    /**
     * Premium SKU of Managed Environment.
     */
    readonly Premium: "Premium";
};
/**
 * Name of the Sku.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const StorageType: {
    readonly AzureFile: "AzureFile";
    readonly EmptyDir: "EmptyDir";
    readonly Secret: "Secret";
};
/**
 * Storage type for the volume. If not provided, use EmptyDir.
 */
export type StorageType = (typeof StorageType)[keyof typeof StorageType];
export declare const TriggerType: {
    readonly Schedule: "Schedule";
    readonly Event: "Event";
    readonly Manual: "Manual";
};
/**
 * Trigger type of the job
 */
export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType];
export declare const Type: {
    readonly Liveness: "Liveness";
    readonly Readiness: "Readiness";
    readonly Startup: "Startup";
};
/**
 * The type of probe.
 */
export type Type = (typeof Type)[keyof typeof Type];
export declare const UnauthenticatedClientActionV2: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
    readonly Return401: "Return401";
    readonly Return403: "Return403";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientActionV2 = (typeof UnauthenticatedClientActionV2)[keyof typeof UnauthenticatedClientActionV2];
export declare const WeekDay: {
    readonly Monday: "Monday";
    readonly Tuesday: "Tuesday";
    readonly Wednesday: "Wednesday";
    readonly Thursday: "Thursday";
    readonly Friday: "Friday";
    readonly Saturday: "Saturday";
    readonly Sunday: "Sunday";
};
/**
 * Day of the week when a managed environment can be patched.
 */
export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay];
