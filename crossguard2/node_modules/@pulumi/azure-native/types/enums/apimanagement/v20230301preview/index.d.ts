export declare const AlwaysLog: {
    /**
     * Always log all erroneous request regardless of sampling settings.
     */
    readonly AllErrors: "allErrors";
};
/**
 * Specifies for what type of messages sampling settings should not apply.
 */
export type AlwaysLog = (typeof AlwaysLog)[keyof typeof AlwaysLog];
export declare const ApiType: {
    readonly Http: "http";
    readonly Soap: "soap";
    readonly Websocket: "websocket";
    readonly Graphql: "graphql";
    readonly Odata: "odata";
};
/**
 * Type of API.
 */
export type ApiType = (typeof ApiType)[keyof typeof ApiType];
export declare const ApimIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
 */
export type ApimIdentityType = (typeof ApimIdentityType)[keyof typeof ApimIdentityType];
export declare const AppType: {
    /**
     * User create request was sent by legacy developer portal.
     */
    readonly Portal: "portal";
    /**
     * User create request was sent by new developer portal.
     */
    readonly DeveloperPortal: "developerPortal";
};
/**
 * Determines the type of application which send the create user request. Default is legacy portal.
 */
export type AppType = (typeof AppType)[keyof typeof AppType];
export declare const AuthorizationMethod: {
    readonly HEAD: "HEAD";
    readonly OPTIONS: "OPTIONS";
    readonly TRACE: "TRACE";
    readonly GET: "GET";
    readonly POST: "POST";
    readonly PUT: "PUT";
    readonly PATCH: "PATCH";
    readonly DELETE: "DELETE";
};
export type AuthorizationMethod = (typeof AuthorizationMethod)[keyof typeof AuthorizationMethod];
export declare const AuthorizationType: {
    /**
     * OAuth2 authorization type
     */
    readonly OAuth2: "OAuth2";
};
/**
 * Authorization type options
 */
export type AuthorizationType = (typeof AuthorizationType)[keyof typeof AuthorizationType];
export declare const BackendProtocol: {
    /**
     * The Backend is a RESTful service.
     */
    readonly Http: "http";
    /**
     * The Backend is a SOAP service.
     */
    readonly Soap: "soap";
};
/**
 * Backend communication protocol.
 */
export type BackendProtocol = (typeof BackendProtocol)[keyof typeof BackendProtocol];
export declare const BearerTokenSendingMethod: {
    readonly AuthorizationHeader: "authorizationHeader";
    readonly Query: "query";
};
export type BearerTokenSendingMethod = (typeof BearerTokenSendingMethod)[keyof typeof BearerTokenSendingMethod];
export declare const BearerTokenSendingMethods: {
    /**
     * Access token will be transmitted in the Authorization header using Bearer schema
     */
    readonly AuthorizationHeader: "authorizationHeader";
    /**
     * Access token will be transmitted as query parameters.
     */
    readonly Query: "query";
};
/**
 * Form of an authorization grant, which the client uses to request the access token.
 */
export type BearerTokenSendingMethods = (typeof BearerTokenSendingMethods)[keyof typeof BearerTokenSendingMethods];
export declare const CertificateSource: {
    readonly Managed: "Managed";
    readonly KeyVault: "KeyVault";
    readonly Custom: "Custom";
    readonly BuiltIn: "BuiltIn";
};
/**
 * Certificate Source.
 */
export type CertificateSource = (typeof CertificateSource)[keyof typeof CertificateSource];
export declare const CertificateStatus: {
    readonly Completed: "Completed";
    readonly Failed: "Failed";
    readonly InProgress: "InProgress";
};
/**
 * Certificate Status.
 */
export type CertificateStatus = (typeof CertificateStatus)[keyof typeof CertificateStatus];
export declare const ClientAuthenticationMethod: {
    /**
     * Basic Client Authentication method.
     */
    readonly Basic: "Basic";
    /**
     * Body based Authentication method.
     */
    readonly Body: "Body";
};
export type ClientAuthenticationMethod = (typeof ClientAuthenticationMethod)[keyof typeof ClientAuthenticationMethod];
export declare const Confirmation: {
    /**
     * Send an e-mail to the user confirming they have successfully signed up.
     */
    readonly Signup: "signup";
    /**
     * Send an e-mail inviting the user to sign-up and complete registration.
     */
    readonly Invite: "invite";
};
/**
 * Determines the type of confirmation e-mail that will be sent to the newly created user.
 */
export type Confirmation = (typeof Confirmation)[keyof typeof Confirmation];
export declare const ContentFormat: {
    /**
     * The contents are inline and Content type is a WADL document.
     */
    readonly Wadl_xml: "wadl-xml";
    /**
     * The WADL document is hosted on a publicly accessible internet address.
     */
    readonly Wadl_link_json: "wadl-link-json";
    /**
     * The contents are inline and Content Type is a OpenAPI 2.0 JSON Document.
     */
    readonly Swagger_json: "swagger-json";
    /**
     * The OpenAPI 2.0 JSON document is hosted on a publicly accessible internet address.
     */
    readonly Swagger_link_json: "swagger-link-json";
    /**
     * The contents are inline and the document is a WSDL/Soap document.
     */
    readonly Wsdl: "wsdl";
    /**
     * The WSDL document is hosted on a publicly accessible internet address.
     */
    readonly Wsdl_link: "wsdl-link";
    /**
     * The contents are inline and Content Type is a OpenAPI 3.0 YAML Document.
     */
    readonly Openapi: "openapi";
    /**
     * The contents are inline and Content Type is a OpenAPI 3.0 JSON Document.
     */
    readonly Openapi_json: "openapi+json";
    /**
     * The OpenAPI 3.0 YAML document is hosted on a publicly accessible internet address.
     */
    readonly Openapi_link: "openapi-link";
    /**
     * The OpenAPI 3.0 JSON document is hosted on a publicly accessible internet address.
     */
    readonly Openapi_json_link: "openapi+json-link";
    /**
     * The GraphQL API endpoint hosted on a publicly accessible internet address.
     */
    readonly Graphql_link: "graphql-link";
    /**
     * The contents are inline and Content Type is a OData XML Document.
     */
    readonly Odata: "odata";
    /**
     * The OData metadata document hosted on a publicly accessible internet address.
     */
    readonly Odata_link: "odata-link";
};
/**
 * Format of the Content in which the API is getting imported. New formats can be added in the future
 */
export type ContentFormat = (typeof ContentFormat)[keyof typeof ContentFormat];
export declare const DataMaskingMode: {
    /**
     * Mask the value of an entity.
     */
    readonly Mask: "Mask";
    /**
     * Hide the presence of an entity.
     */
    readonly Hide: "Hide";
};
/**
 * Data masking mode.
 */
export type DataMaskingMode = (typeof DataMaskingMode)[keyof typeof DataMaskingMode];
export declare const DeveloperPortalStatus: {
    /**
     * Developer Portal is enabled for the service.
     */
    readonly Enabled: "Enabled";
    /**
     * Developer Portal is disabled for the service.
     */
    readonly Disabled: "Disabled";
};
/**
 * Status of developer portal in this API Management service.
 */
export type DeveloperPortalStatus = (typeof DeveloperPortalStatus)[keyof typeof DeveloperPortalStatus];
export declare const GatewayListDebugCredentialsContractPurpose: {
    /**
     * The tracing purpose.
     */
    readonly Tracing: "tracing";
};
/**
 * Purpose of debug credential.
 */
export type GatewayListDebugCredentialsContractPurpose = (typeof GatewayListDebugCredentialsContractPurpose)[keyof typeof GatewayListDebugCredentialsContractPurpose];
export declare const GrantType: {
    /**
     * Authorization Code Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.1.
     */
    readonly AuthorizationCode: "authorizationCode";
    /**
     * Implicit Code Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.2.
     */
    readonly Implicit: "implicit";
    /**
     * Resource Owner Password Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.3.
     */
    readonly ResourceOwnerPassword: "resourceOwnerPassword";
    /**
     * Client Credentials Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.4.
     */
    readonly ClientCredentials: "clientCredentials";
};
export type GrantType = (typeof GrantType)[keyof typeof GrantType];
export declare const GroupType: {
    readonly Custom: "custom";
    readonly System: "system";
    readonly External: "external";
};
/**
 * Group type.
 */
export type GroupType = (typeof GroupType)[keyof typeof GroupType];
export declare const HostnameType: {
    readonly Proxy: "Proxy";
    readonly Portal: "Portal";
    readonly Management: "Management";
    readonly Scm: "Scm";
    readonly DeveloperPortal: "DeveloperPortal";
    readonly ConfigurationApi: "ConfigurationApi";
};
/**
 * Hostname type.
 */
export type HostnameType = (typeof HostnameType)[keyof typeof HostnameType];
export declare const HttpCorrelationProtocol: {
    /**
     * Do not read and inject correlation headers.
     */
    readonly None: "None";
    /**
     * Inject Request-Id and Request-Context headers with request correlation data. See https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md.
     */
    readonly Legacy: "Legacy";
    /**
     * Inject Trace Context headers. See https://w3c.github.io/trace-context.
     */
    readonly W3C: "W3C";
};
/**
 * Sets correlation protocol to use for Application Insights diagnostics.
 */
export type HttpCorrelationProtocol = (typeof HttpCorrelationProtocol)[keyof typeof HttpCorrelationProtocol];
export declare const IdentityProviderType: {
    /**
     * Facebook as Identity provider.
     */
    readonly Facebook: "facebook";
    /**
     * Google as Identity provider.
     */
    readonly Google: "google";
    /**
     * Microsoft Live as Identity provider.
     */
    readonly Microsoft: "microsoft";
    /**
     * Twitter as Identity provider.
     */
    readonly Twitter: "twitter";
    /**
     * Azure Active Directory as Identity provider.
     */
    readonly Aad: "aad";
    /**
     * Azure Active Directory B2C as Identity provider.
     */
    readonly AadB2C: "aadB2C";
};
/**
 * Identity Provider Type identifier.
 */
export type IdentityProviderType = (typeof IdentityProviderType)[keyof typeof IdentityProviderType];
export declare const KeyType: {
    readonly Primary: "primary";
    readonly Secondary: "secondary";
};
/**
 * The Key to be used to generate token for user.
 */
export type KeyType = (typeof KeyType)[keyof typeof KeyType];
export declare const LegacyApiState: {
    /**
     * Legacy Configuration API (v1) is enabled for the service and self-hosted gateways can connect to it.
     */
    readonly Enabled: "Enabled";
    /**
     * Legacy Configuration API (v1) is disabled for the service and self-hosted gateways can not connect to it.
     */
    readonly Disabled: "Disabled";
};
/**
 * Indication whether or not the legacy Configuration API (v1) should be exposed on the API Management service. Value is optional but must be 'Enabled' or 'Disabled'. If 'Disabled', legacy Configuration API (v1) will not be available for self-hosted gateways. Default value is 'Enabled'
 */
export type LegacyApiState = (typeof LegacyApiState)[keyof typeof LegacyApiState];
export declare const LegacyPortalStatus: {
    /**
     * Legacy Portal is enabled for the service.
     */
    readonly Enabled: "Enabled";
    /**
     * Legacy Portal is disabled for the service.
     */
    readonly Disabled: "Disabled";
};
/**
 * Status of legacy portal in the API Management service.
 */
export type LegacyPortalStatus = (typeof LegacyPortalStatus)[keyof typeof LegacyPortalStatus];
export declare const LoggerType: {
    /**
     * Azure Event Hub as log destination.
     */
    readonly AzureEventHub: "azureEventHub";
    /**
     * Azure Application Insights as log destination.
     */
    readonly ApplicationInsights: "applicationInsights";
    /**
     * Azure Monitor
     */
    readonly AzureMonitor: "azureMonitor";
};
/**
 * Logger type.
 */
export type LoggerType = (typeof LoggerType)[keyof typeof LoggerType];
export declare const NatGatewayState: {
    /**
     * Nat Gateway is enabled for the service.
     */
    readonly Enabled: "Enabled";
    /**
     * Nat Gateway is disabled for the service.
     */
    readonly Disabled: "Disabled";
};
/**
 * Property can be used to enable NAT Gateway for this API Management service.
 */
export type NatGatewayState = (typeof NatGatewayState)[keyof typeof NatGatewayState];
export declare const OAuth2GrantType: {
    /**
     * Authorization Code grant
     */
    readonly AuthorizationCode: "AuthorizationCode";
    /**
     * Client Credential grant
     */
    readonly ClientCredentials: "ClientCredentials";
};
/**
 * OAuth2 grant type options
 */
export type OAuth2GrantType = (typeof OAuth2GrantType)[keyof typeof OAuth2GrantType];
export declare const OperationNameFormat: {
    /**
     * API_NAME;rev=API_REVISION - OPERATION_NAME
     */
    readonly Name: "Name";
    /**
     * HTTP_VERB URL
     */
    readonly Url: "Url";
};
/**
 * The format of the Operation Name for Application Insights telemetries. Default is Name.
 */
export type OperationNameFormat = (typeof OperationNameFormat)[keyof typeof OperationNameFormat];
export declare const PolicyContentFormat: {
    /**
     * The contents are inline and Content type is an XML document.
     */
    readonly Xml: "xml";
    /**
     * The policy XML document is hosted on a HTTP endpoint accessible from the API Management service.
     */
    readonly Xml_link: "xml-link";
    /**
     * The contents are inline and Content type is a non XML encoded policy document.
     */
    readonly Rawxml: "rawxml";
    /**
     * The policy document is not XML encoded and is hosted on a HTTP endpoint accessible from the API Management service.
     */
    readonly Rawxml_link: "rawxml-link";
};
/**
 * Format of the policyContent.
 */
export type PolicyContentFormat = (typeof PolicyContentFormat)[keyof typeof PolicyContentFormat];
export declare const PolicyFragmentContentFormat: {
    /**
     * The contents are inline and Content type is an XML document.
     */
    readonly Xml: "xml";
    /**
     * The contents are inline and Content type is a non XML encoded policy document.
     */
    readonly Rawxml: "rawxml";
};
/**
 * Format of the policy fragment content.
 */
export type PolicyFragmentContentFormat = (typeof PolicyFragmentContentFormat)[keyof typeof PolicyFragmentContentFormat];
export declare const PrivateEndpointServiceConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
};
/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];
export declare const ProductState: {
    readonly NotPublished: "notPublished";
    readonly Published: "published";
};
/**
 * whether product is published or not. Published products are discoverable by users of developer portal. Non published products are visible only to administrators. Default state of Product is notPublished.
 */
export type ProductState = (typeof ProductState)[keyof typeof ProductState];
export declare const Protocol: {
    readonly Http: "http";
    readonly Https: "https";
    readonly Ws: "ws";
    readonly Wss: "wss";
};
export type Protocol = (typeof Protocol)[keyof typeof Protocol];
export declare const ProvisioningState: {
    readonly Created: "created";
};
/**
 * Provisioning state.
 */
export type ProvisioningState = (typeof ProvisioningState)[keyof typeof ProvisioningState];
export declare const PublicNetworkAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether or not public endpoint access is allowed for this API Management service.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'. If 'Disabled', private endpoints are the exclusive access method. Default value is 'Enabled'
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const SamplingType: {
    /**
     * Fixed-rate sampling.
     */
    readonly Fixed: "fixed";
};
/**
 * Sampling type.
 */
export type SamplingType = (typeof SamplingType)[keyof typeof SamplingType];
export declare const SchemaType: {
    /**
     * XML schema type.
     */
    readonly Xml: "xml";
    /**
     * Json schema type.
     */
    readonly Json: "json";
};
/**
 * Schema Type. Immutable.
 */
export type SchemaType = (typeof SchemaType)[keyof typeof SchemaType];
export declare const SkuType: {
    /**
     * Developer SKU of Api Management.
     */
    readonly Developer: "Developer";
    /**
     * Standard SKU of Api Management.
     */
    readonly Standard: "Standard";
    /**
     * Premium SKU of Api Management.
     */
    readonly Premium: "Premium";
    /**
     * Basic SKU of Api Management.
     */
    readonly Basic: "Basic";
    /**
     * Consumption SKU of Api Management.
     */
    readonly Consumption: "Consumption";
    /**
     * Isolated SKU of Api Management.
     */
    readonly Isolated: "Isolated";
};
/**
 * Name of the Sku.
 */
export type SkuType = (typeof SkuType)[keyof typeof SkuType];
export declare const SoapApiType: {
    /**
     * Imports a SOAP API having a RESTful front end.
     */
    readonly SoapToRest: "http";
    /**
     * Imports the SOAP API having a SOAP front end.
     */
    readonly SoapPassThrough: "soap";
    /**
     * Imports the API having a Websocket front end.
     */
    readonly WebSocket: "websocket";
    /**
     * Imports the API having a GraphQL front end.
     */
    readonly GraphQL: "graphql";
    /**
     * Imports the API having a OData front end.
     */
    readonly OData: "odata";
};
/**
 * Type of API to create.
 *  * `http` creates a REST API
 *  * `soap` creates a SOAP pass-through API
 *  * `websocket` creates websocket API
 *  * `graphql` creates GraphQL API.
 *  New types can be added in the future.
 */
export type SoapApiType = (typeof SoapApiType)[keyof typeof SoapApiType];
export declare const State: {
    /**
     * The issue is proposed.
     */
    readonly Proposed: "proposed";
    /**
     * The issue is opened.
     */
    readonly Open: "open";
    /**
     * The issue was removed.
     */
    readonly Removed: "removed";
    /**
     * The issue is now resolved.
     */
    readonly Resolved: "resolved";
    /**
     * The issue was closed.
     */
    readonly Closed: "closed";
};
/**
 * Status of the issue.
 */
export type State = (typeof State)[keyof typeof State];
export declare const SubscriptionState: {
    readonly Suspended: "suspended";
    readonly Active: "active";
    readonly Expired: "expired";
    readonly Submitted: "submitted";
    readonly Rejected: "rejected";
    readonly Cancelled: "cancelled";
};
/**
 * Initial subscription state. If no value is specified, subscription is created with Submitted state. Possible states are * active – the subscription is active, * suspended – the subscription is blocked, and the subscriber cannot call any APIs of the product, * submitted – the subscription request has been made by the developer, but has not yet been approved or rejected, * rejected – the subscription request has been denied by an administrator, * cancelled – the subscription has been cancelled by the developer or administrator, * expired – the subscription reached its expiration date and was deactivated.
 */
export type SubscriptionState = (typeof SubscriptionState)[keyof typeof SubscriptionState];
export declare const TranslateRequiredQueryParametersConduct: {
    /**
     * Translates required query parameters to template ones. Is a default value
     */
    readonly Template: "template";
    /**
     * Leaves required query parameters as they are (no translation done).
     */
    readonly Query: "query";
};
/**
 * Strategy of translating required query parameters to template ones. By default has value 'template'. Possible values: 'template', 'query'
 */
export type TranslateRequiredQueryParametersConduct = (typeof TranslateRequiredQueryParametersConduct)[keyof typeof TranslateRequiredQueryParametersConduct];
export declare const UserState: {
    /**
     * User state is active.
     */
    readonly Active: "active";
    /**
     * User is blocked. Blocked users cannot authenticate at developer portal or call API.
     */
    readonly Blocked: "blocked";
    /**
     * User account is pending. Requires identity confirmation before it can be made active.
     */
    readonly Pending: "pending";
    /**
     * User account is closed. All identities and related entities are removed.
     */
    readonly Deleted: "deleted";
};
/**
 * Account state. Specifies whether the user is active or not. Blocked users are unable to sign into the developer portal or call any APIs of subscribed products. Default state is Active.
 */
export type UserState = (typeof UserState)[keyof typeof UserState];
export declare const Verbosity: {
    /**
     * All the traces emitted by trace policies will be sent to the logger attached to this diagnostic instance.
     */
    readonly Verbose: "verbose";
    /**
     * Traces with 'severity' set to 'information' and 'error' will be sent to the logger attached to this diagnostic instance.
     */
    readonly Information: "information";
    /**
     * Only traces with 'severity' set to 'error' will be sent to the logger attached to this diagnostic instance.
     */
    readonly Error: "error";
};
/**
 * The verbosity level applied to traces emitted by trace policies.
 */
export type Verbosity = (typeof Verbosity)[keyof typeof Verbosity];
export declare const VersioningScheme: {
    /**
     * The API Version is passed in a path segment.
     */
    readonly Segment: "Segment";
    /**
     * The API Version is passed in a query parameter.
     */
    readonly Query: "Query";
    /**
     * The API Version is passed in a HTTP header.
     */
    readonly Header: "Header";
};
/**
 * An value that determines where the API Version identifier will be located in a HTTP request.
 */
export type VersioningScheme = (typeof VersioningScheme)[keyof typeof VersioningScheme];
export declare const VirtualNetworkType: {
    /**
     * The service is not part of any Virtual Network.
     */
    readonly None: "None";
    /**
     * The service is part of Virtual Network and it is accessible from Internet.
     */
    readonly External: "External";
    /**
     * The service is part of Virtual Network and it is only accessible from within the virtual network.
     */
    readonly Internal: "Internal";
};
/**
 * The type of VPN in which API Management service needs to be configured in. None (Default Value) means the API Management service is not part of any Virtual Network, External means the API Management deployment is set up inside a Virtual Network having an Internet Facing Endpoint, and Internal means that API Management deployment is setup inside a Virtual Network having an Intranet Facing Endpoint only.
 */
export type VirtualNetworkType = (typeof VirtualNetworkType)[keyof typeof VirtualNetworkType];
