"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeProperties = exports.deserializeProperties = void 0;
const pulumi_1 = require("@pulumi/pulumi");
const rpc_1 = require("@pulumi/pulumi/runtime/rpc");
const policy_1 = require("./policy");
const proxy_1 = require("./proxy");
const secret_1 = require("./secret");
/**
 * deserializeProperties fetches the raw outputs and deserializes them from a gRPC call result.
 * @internal
 */
function deserializeProperties(outputsStruct, proxySecrets) {
    let props = {};
    const outputs = outputsStruct.toJavaScript();
    for (const k of Object.keys(outputs)) {
        // We treat properties with undefined values as if they do not exist.
        if (outputs[k] !== undefined) {
            props[k] = deserializeProperty(outputs[k], proxySecrets);
        }
    }
    if (proxySecrets) {
        props = secret_1.secretsPreservingProxy(props);
    }
    return props;
}
exports.deserializeProperties = deserializeProperties;
/**
 * deserializeProperty is partly based on, but not functionally or superficially identical to, the
 * deserialization code in `@pulumi/pulumi/runtime/rpc.ts`.
 *
 * Specifically, we explicitly do not want to be compatible with Output<T>. Policies interact with
 * raw JSON representations of resource definitions, so things like secrets must be "fully unpacked"
 * into plain-old-JSON that the policies can interact with as normal data. If things like secrets
 * are not unpacked, every field in every resource type would have to be type `T | Secret<T>`, which
 * would severely detract from usability.
 */
function deserializeProperty(prop, proxySecrets) {
    if (prop === undefined) {
        throw new Error("unexpected undefined property value during deserialization");
    }
    else if (prop === null ||
        typeof prop === "boolean" ||
        typeof prop === "number" ||
        typeof prop === "string") {
        return prop;
    }
    else if (prop instanceof Array) {
        const elems = [];
        for (const e of prop) {
            elems.push(deserializeProperty(e, proxySecrets));
        }
        return elems;
    }
    else {
        // We need to recognize assets and archives specially, so we can produce the right runtime
        // objects.
        const sig = prop[rpc_1.specialSigKey];
        if (sig) {
            switch (sig) {
                case rpc_1.specialAssetSig:
                    if (prop["path"]) {
                        return new pulumi_1.asset.FileAsset(prop["path"]);
                    }
                    else if (prop["text"]) {
                        return new pulumi_1.asset.StringAsset(prop["text"]);
                    }
                    else if (prop["uri"]) {
                        return new pulumi_1.asset.RemoteAsset(prop["uri"]);
                    }
                    else {
                        throw new Error("Invalid asset encountered when unmarshaling resource property");
                    }
                case rpc_1.specialArchiveSig:
                    if (prop["assets"]) {
                        const assets = {};
                        for (const name of Object.keys(prop["assets"])) {
                            const a = deserializeProperty(prop["assets"][name], proxySecrets);
                            if (!pulumi_1.asset.Asset.isInstance(a) && !pulumi_1.asset.Archive.isInstance(a)) {
                                throw new Error("Expected an AssetArchive's assets to be unmarshaled Asset or Archive objects");
                            }
                            assets[name] = a;
                        }
                        return new pulumi_1.asset.AssetArchive(assets);
                    }
                    else if (prop["path"]) {
                        return new pulumi_1.asset.FileArchive(prop["path"]);
                    }
                    else if (prop["uri"]) {
                        return new pulumi_1.asset.RemoteArchive(prop["uri"]);
                    }
                    else {
                        throw new Error("Invalid archive encountered when unmarshaling resource property");
                    }
                case rpc_1.specialSecretSig:
                    let value = deserializeProperty(prop["value"], proxySecrets);
                    if (proxySecrets) {
                        // Wrap the value so that a proxy wrapper can detect it later on.
                        value = new policy_1.Secret(value);
                    }
                    return value;
                default:
                    throw new Error(`Unrecognized signature '${sig}' when unmarshaling resource property`);
            }
        }
        const obj = {};
        for (const k of Object.keys(prop)) {
            obj[k] = deserializeProperty(prop[k], proxySecrets);
        }
        return obj;
    }
}
/**
 * serializeProperties serializes a runtime resource object to ready it for a gRPC call result.
 * @internal
 */
function serializeProperties(obj) {
    return __awaiter(this, void 0, void 0, function* () {
        return serializeProperty(obj);
    });
}
exports.serializeProperties = serializeProperties;
/**
 * serializeProperty is partly based on, but not functionally or superficially identical to, the
 * serialization code in `@pulumi/pulumi/runtime/rpc.ts`. It has to handle the slightly different
 * serialization semantics for policies which treat outputs and secrets with different semantics.
 */
function serializeProperty(prop) {
    return __awaiter(this, void 0, void 0, function* () {
        if (prop === undefined) {
            return null;
        }
        if (prop === null ||
            typeof prop === "boolean" ||
            typeof prop === "number" ||
            typeof prop === "string") {
            return prop;
        }
        if (prop[proxy_1.isSpecialProxy]) {
            return yield serializeProperty(prop[proxy_1.getSpecialProxyTarget]);
        }
        if (prop instanceof Promise) {
            return serializeProperty(yield prop);
        }
        if (prop instanceof Array) {
            const elems = [];
            for (const e of prop) {
                const se = yield serializeProperty(e);
                elems.push(se === undefined ? null : se);
            }
            return elems;
        }
        if (prop instanceof pulumi_1.asset.FileAsset) {
            return { [rpc_1.specialSigKey]: rpc_1.specialAssetSig, path: yield serializeProperty(prop.path) };
        }
        if (prop instanceof pulumi_1.asset.StringAsset) {
            return { [rpc_1.specialSigKey]: rpc_1.specialAssetSig, text: yield serializeProperty(prop.text) };
        }
        if (prop instanceof pulumi_1.asset.RemoteAsset) {
            return { [rpc_1.specialSigKey]: rpc_1.specialAssetSig, uri: yield serializeProperty(prop.uri) };
        }
        if (prop instanceof pulumi_1.asset.AssetArchive) {
            const assets = [];
            for (const a of Object.keys(yield prop.assets)) {
                assets.push(yield serializeProperty(a));
            }
            return { [rpc_1.specialSigKey]: rpc_1.specialArchiveSig, assets };
        }
        if (prop instanceof pulumi_1.asset.FileArchive) {
            return { [rpc_1.specialSigKey]: rpc_1.specialArchiveSig, path: yield serializeProperty(prop.path) };
        }
        if (prop instanceof pulumi_1.asset.RemoteArchive) {
            return { [rpc_1.specialSigKey]: rpc_1.specialArchiveSig, uri: yield serializeProperty(prop.uri) };
        }
        if (prop instanceof policy_1.Secret) {
            // Because of the way secrets proxying works, we very well may encounter a
            // secret in its raw form, since serialization explicitly unwraps the proxy and
            // accesses the raw underlying values.
            return {
                [rpc_1.specialSigKey]: rpc_1.specialSecretSig,
                value: yield serializeProperty(prop.value),
            };
        }
        // Unsupported types:
        if (pulumi_1.Output.isInstance(prop)) {
            throw new Error("Serializing output values not supported from within a policy pack");
        }
        const obj = {};
        for (const k of Object.keys(prop)) {
            const value = yield serializeProperty(prop[k]);
            if (value !== undefined) {
                obj[k] = value;
            }
        }
        return obj;
    });
}
