"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRemediateResponse = exports.normalizeConfig = exports.convertEnforcementLevel = exports.mapEnforcementLevel = exports.makeAnalyzeResponse = exports.makeAnalyzerInfo = exports.asGrpcError = void 0;
const analyzerproto = require("@pulumi/pulumi/proto/analyzer_pb.js");
const analyzerrpc = require("@pulumi/pulumi/proto/analyzer_grpc_pb.js");
const structproto = require("google-protobuf/google/protobuf/struct_pb.js");
const plugproto = require("@pulumi/pulumi/proto/plugin_pb.js");
/** @internal */
function asGrpcError(e, message) {
    if (message === undefined || message === "") {
        message = "";
    }
    else {
        message = message + ":\n";
    }
    //
    // gRPC throws away the stack trace of `Error`. We choose to preserve it.
    //
    if (e instanceof Error) {
        return new Error(`${message}${e.stack}`);
    }
    else {
        return new Error(`${message}${e}`);
    }
}
exports.asGrpcError = asGrpcError;
// ------------------------------------------------------------------------------------------------
// RPC utilities. Translates the requests and results of the Analyzer gRPC interface into structures
// that are more managable and convenient.
// ------------------------------------------------------------------------------------------------
/** @internal */
function makeAnalyzerInfo(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies, initialConfig) {
    const ai = new analyzerproto.AnalyzerInfo();
    ai.setName(policyPackName);
    ai.setVersion(policyPackVersion);
    ai.setSupportsconfig(true);
    const policyInfos = [];
    for (const policy of policies) {
        const policyInfo = new analyzerproto.PolicyInfo();
        policyInfo.setName(policy.name);
        policyInfo.setDescription(policy.description);
        policyInfo.setEnforcementlevel(mapEnforcementLevel(policy.enforcementLevel || policyPackEnforcementLevel));
        if (policy.configSchema) {
            const schema = new analyzerproto.PolicyConfigSchema();
            schema.setProperties(structproto.Struct.fromJavaScript(policy.configSchema.properties));
            schema.setRequiredList(policy.configSchema.required);
            policyInfo.setConfigschema(schema);
        }
        policyInfos.push(policyInfo);
    }
    ai.setPoliciesList(policyInfos);
    if (initialConfig) {
        const normalizedConfig = normalizeConfig(initialConfig);
        let configMap;
        for (const key of Object.keys(normalizedConfig)) {
            const val = normalizedConfig[key];
            let config;
            if (val.enforcementLevel) {
                config = new analyzerproto.PolicyConfig();
                config.setEnforcementlevel(mapEnforcementLevel(val.enforcementLevel));
            }
            if (val.properties) {
                config = config || new analyzerproto.PolicyConfig();
                config.setProperties(structproto.Struct.fromJavaScript(val.properties));
            }
            if (config) {
                configMap = configMap || ai.getInitialconfigMap();
                configMap.set(key, config);
            }
        }
    }
    return ai;
}
exports.makeAnalyzerInfo = makeAnalyzerInfo;
/**
 * makeAnalyzeResponse creates a protobuf encoding the given list of diagnostics.
 * @internal
 */
function makeAnalyzeResponse(ds) {
    const resp = new analyzerproto.AnalyzeResponse();
    const diagnostics = [];
    for (const d of ds) {
        const diagnostic = new analyzerproto.AnalyzeDiagnostic();
        diagnostic.setPolicyname(d.policyName);
        diagnostic.setPolicypackname(d.policyPackName);
        diagnostic.setPolicypackversion(d.policyPackVersion);
        diagnostic.setDescription(d.description);
        diagnostic.setMessage(d.message);
        diagnostic.setEnforcementlevel(mapEnforcementLevel(d.enforcementLevel));
        diagnostic.setUrn(d.urn);
        diagnostics.push(diagnostic);
    }
    resp.setDiagnosticsList(diagnostics);
    return resp;
}
exports.makeAnalyzeResponse = makeAnalyzeResponse;
/** @internal */
function mapEnforcementLevel(el) {
    switch (el) {
        case "advisory":
            return analyzerproto.EnforcementLevel.ADVISORY;
        case "mandatory":
            return analyzerproto.EnforcementLevel.MANDATORY;
        case "remediate":
            return analyzerproto.EnforcementLevel.REMEDIATE;
        case "disabled":
            return analyzerproto.EnforcementLevel.DISABLED;
        default:
            throw new UnknownEnforcementLevelError(el);
    }
}
exports.mapEnforcementLevel = mapEnforcementLevel;
/** @internal */
function convertEnforcementLevel(el) {
    switch (el) {
        case analyzerproto.EnforcementLevel.ADVISORY:
            return "advisory";
        case analyzerproto.EnforcementLevel.MANDATORY:
            return "mandatory";
        case analyzerproto.EnforcementLevel.REMEDIATE:
            return "remediate";
        case analyzerproto.EnforcementLevel.DISABLED:
            return "disabled";
        default:
            throw new Error(`Unknown enforcement level ${el}.`);
    }
}
exports.convertEnforcementLevel = convertEnforcementLevel;
/** @internal */
function normalizeConfig(config) {
    const result = {};
    for (const key of Object.keys(config)) {
        const val = config[key];
        // If the value is a string, it's just an enforcement level.
        if (typeof val === "string") {
            result[key] = { enforcementLevel: val };
            continue;
        }
        // Otherwise, it's an object that may have an enforcement level and additional
        // properties.
        let resultVal;
        if (val.enforcementLevel) {
            resultVal = {};
            resultVal.enforcementLevel = val.enforcementLevel;
        }
        const { enforcementLevel } = val, properties = __rest(val, ["enforcementLevel"]);
        if (Object.keys(properties).length > 0) {
            resultVal = resultVal || {};
            resultVal.properties = properties;
        }
        if (resultVal) {
            result[key] = resultVal;
        }
    }
    return result;
}
exports.normalizeConfig = normalizeConfig;
// Ensures all possible values are covered in the switch.
class UnknownEnforcementLevelError extends Error {
    constructor(el) {
        super(`Unknown enforcement level type '${el}'`);
    }
}
/**
 * makeRemediateResponse creates a protobuf encoding the returned property bag.
 * @internal
 */
function makeRemediateResponse(rs) {
    const resp = new analyzerproto.RemediateResponse();
    const remediations = [];
    for (const r of rs) {
        if (!r.properties && !r.diagnostic) {
            throw new Error("Expected a remediation to have either properties or a diagnostic");
        }
        const remediation = new analyzerproto.Remediation();
        remediation.setPolicyname(r.policyName);
        remediation.setPolicypackname(r.policyPackName);
        remediation.setPolicypackversion(r.policyPackVersion);
        remediation.setDescription(r.description);
        remediation.setProperties(structproto.Struct.fromJavaScript(r.properties));
        remediation.setDiagnostic(r.diagnostic);
        remediations.push(remediation);
    }
    resp.setRemediationsList(remediations);
    return resp;
}
exports.makeRemediateResponse = makeRemediateResponse;
