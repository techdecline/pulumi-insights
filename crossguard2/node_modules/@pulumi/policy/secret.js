"use strict";
// Copyright 2016-2023, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.secretsPreservingProxy = void 0;
const policy_1 = require("./policy");
const proxy_1 = require("./proxy");
/**
 * `secretsPreservingProxy` is a helper that takes an input and ensures any properties
 * that are secrets are (a) unwrapped to return raw values and (b) preserve secretness
 * upon writes. This ensures that secret values are preserved even if replaced.
 *
 * @param toProxy the object whose property accesses to proxy.
 */
function secretsPreservingProxy(toProxy) {
    if (!(toProxy instanceof Object)) {
        return toProxy;
    }
    const isSecret = (target, p) => {
        const value = target[p];
        if (value && value instanceof policy_1.Secret) {
            return [value.value, true];
        }
        return [value, false];
    };
    return new Proxy(toProxy, {
        get: (target, p) => {
            // Check for special symbols.
            if (p === proxy_1.isSpecialProxy) {
                return true;
            }
            else if (p === proxy_1.getSpecialProxyTarget) {
                return target;
            }
            // If it's a secret, pluck out the raw value.
            const [value, _] = isSecret(target, p);
            // And in either case, make sure to deeply apply this transformation.
            return secretsPreservingProxy(value);
        },
        set: (target, p, value, receiver) => {
            // First check if the existing value is a secret. If it is, make any new values secret too.
            const [_, secret] = isSecret(target, p);
            if (secret) {
                value = new policy_1.Secret(value);
            }
            target[p] = value;
            return true;
        },
    });
}
exports.secretsPreservingProxy = secretsPreservingProxy;
