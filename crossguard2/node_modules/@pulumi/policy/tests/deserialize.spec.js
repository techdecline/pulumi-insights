"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const pulumi_1 = require("@pulumi/pulumi");
const rpc_1 = require("@pulumi/pulumi/runtime/rpc");
const deserialize_1 = require("../deserialize");
const policy_1 = require("../policy");
const util_1 = require("./util");
const gstruct = require("google-protobuf/google/protobuf/struct_pb.js");
function runWithSerialization(inputs, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const usePolicySerialization of [false, true]) {
            let transfer = undefined;
            if (usePolicySerialization) {
                // Use the policy SDK's serialization to check round-tripping.
                transfer = gstruct.Struct.fromJavaScript(yield deserialize_1.serializeProperties(inputs));
            }
            else {
                // Use the runtime serialization as a check to ensure we are behaving consistently.
                transfer = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", inputs));
            }
            // Run the callback with the serialized properties.
            callback(transfer);
        }
    });
}
describe("runtime", () => {
    describe("deserializeProperties", () => {
        it("marshals basic properties correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const inputs = {
                aNum: 42,
                bStr: "a string",
                cUnd: undefined,
                dArr: Promise.resolve([
                    "x",
                    42,
                    Promise.resolve(true),
                    Promise.resolve(undefined),
                ]),
                id: "foo",
                urn: "bar",
            };
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            yield runWithSerialization(inputs, (transfer) => {
                const result = deserialize_1.deserializeProperties(transfer, false);
                assert.equal(result.aNum, 42);
                assert.equal(result.bStr, "a string");
                assert.equal(result.cUnd, undefined);
                assert.deepEqual(result.dArr, ["x", 42, true, null]);
                assert.equal(result.id, "foo");
                assert.equal(result.urn, "bar");
            });
        })));
        it("marshals secrets correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const inputs = {
                secret1: pulumi_1.secret(1),
                secret2: pulumi_1.secret(undefined),
                secret3: {
                    "deeply": {
                        "nested": {
                            "secret": pulumi_1.secret("youfoundme"),
                        },
                    },
                },
            };
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            const transfer = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", inputs));
            const result = deserialize_1.deserializeProperties(transfer, false);
            assert.equal(result.secret1, 1);
            assert.equal(result.secret2, undefined);
            assert.deepEqual(result.secret3, {
                "deeply": {
                    "nested": {
                        "secret": "youfoundme",
                    },
                },
            });
        })));
        it("marshals secrets correctly even when being proxied", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const inputs = {
                secret1: pulumi_1.secret(1),
                secret2: pulumi_1.secret(undefined),
                secret3: {
                    "deeply": {
                        "nested": {
                            "secret": pulumi_1.secret("youfoundme"),
                        },
                    },
                },
            };
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            const transfer = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", inputs));
            const result = deserialize_1.deserializeProperties(transfer, true);
            assert.equal(result.secret1, 1);
            assert.equal(result.secret2, undefined);
            assert.deepEqual(result.secret3, {
                "deeply": {
                    "nested": {
                        "secret": "youfoundme",
                    },
                },
            });
        })));
    });
    describe("deserializeProperty", () => {
        it("fails on unsupported secret values", () => {
            assert.throws(() => pulumi_1.runtime.deserializeProperty({
                [pulumi_1.runtime.specialSigKey]: pulumi_1.runtime.specialSecretSig,
            }));
        });
        it("fails on unknown signature keys", () => {
            assert.throws(() => pulumi_1.runtime.deserializeProperty({
                [pulumi_1.runtime.specialSigKey]: "foobar",
            }));
        });
        it("fully unmarshalls secrets (does not push secretness up)", () => {
            const secretValue = {
                [pulumi_1.runtime.specialSigKey]: pulumi_1.runtime.specialSecretSig,
                value: "a secret value",
            };
            const props = gstruct.Struct.fromJavaScript({
                regular: "a normal value",
                list: ["a normal value", "another value", secretValue],
                map: { regular: "a normal value", secret: secretValue },
                mapWithList: {
                    regular: "a normal value",
                    list: ["a normal value", secretValue],
                },
                listWithMap: [
                    {
                        regular: "a normal value",
                        secret: secretValue,
                    },
                ],
            });
            // Ensure this works the same regardless of whether secrets are proxied or not.
            for (const proxySecrets of [false, true]) {
                const result = deserialize_1.deserializeProperties(props, proxySecrets);
                // Regular had no secrets in it, so it is returned as is.
                assert.equal(result.regular, "a normal value");
                // One of the elements in the list was a secret, so the secretness is promoted to top level.
                assert.equal(result.list[pulumi_1.runtime.specialSigKey], undefined);
                assert.equal(result.list[0], "a normal value");
                assert.equal(result.list[1], "another value");
                assert.equal(result.list[2], "a secret value");
                // One of the values of the map was a secret, so the secretness is promoted to top level.
                assert.equal(result.map[pulumi_1.runtime.specialSigKey], undefined);
                assert.equal(result.map.regular, "a normal value");
                assert.equal(result.map.secret, "a secret value");
                // The nested map had a secret in one of the values, so the entire thing becomes a secret.
                assert.equal(result.mapWithList[pulumi_1.runtime.specialSigKey], undefined);
                assert.equal(result.mapWithList.regular, "a normal value");
                assert.equal(result.mapWithList.list[0], "a normal value");
                assert.equal(result.mapWithList.list[1], "a secret value");
                // An array element contained a secret (via a nested map), so the entrie array becomes a secret.
                assert.equal(result.listWithMap[pulumi_1.runtime.specialSigKey], undefined);
                assert.equal(result.listWithMap[0].regular, "a normal value");
                assert.equal(result.listWithMap[0].secret, "a secret value");
            }
        });
    });
    describe("serializeProperties", () => {
        it("marshals equivalently to the runtime", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const inputs = {
                aNum: 42,
                bStr: "a string",
                cUnd: undefined,
                dArr: Promise.resolve([
                    "x",
                    42,
                    Promise.resolve(true),
                    Promise.resolve(undefined),
                ]),
                id: "foo",
                urn: "bar",
            };
            const policySer = gstruct.Struct.fromJavaScript(yield deserialize_1.serializeProperties(inputs));
            const runtimeSer = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", inputs));
            assert.equal(policySer.aNum, runtimeSer.aNum);
            assert.equal(policySer.bStr, runtimeSer.bStr);
            assert.equal(policySer.cUnd, runtimeSer.cUnd);
            assert.deepEqual(policySer.dArr, runtimeSer.dArr);
            assert.equal(policySer.id, runtimeSer.id);
            assert.equal(policySer.urn, runtimeSer.urn);
        })));
        it("marshals secrets correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const makeInputs = (secretFunc) => ({
                secret1: secretFunc(1),
                secret2: secretFunc(undefined),
                secret3: {
                    "deeply": {
                        "nested": {
                            "secret": secretFunc("youfoundme"),
                        },
                    },
                },
            });
            // Policy inputs uses the policy version of a Secret marker:
            const policyInputs = makeInputs((v) => new policy_1.Secret(v));
            const policySer = gstruct.Struct.fromJavaScript(yield deserialize_1.serializeProperties(policyInputs));
            // While the runtime uses the normal Pulumi runtime version of a Secret marker:
            const runtimeInputs = makeInputs((v) => pulumi_1.secret(v));
            const runtimeSer = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", runtimeInputs));
            // Both should lead to the same place.
            assert.deepEqual(policySer.secret1, runtimeSer.secret1);
            assert.deepEqual(policySer.secret2, runtimeSer.secret2);
            assert.deepEqual(policySer.secret3, runtimeSer.secret3);
        })));
        it("round-trips proxied secrets correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            // Set mocks, which will enable secrets serialization.
            pulumi_1.runtime.setMocks({
                call: (_) => {
                    throw new Error("unexpected call");
                },
                newResource: (args) => {
                    return { id: `${args.name}_id`, state: {} };
                },
            });
            // Start with a runtime representation of secrets.
            const inputs = {
                secret1: pulumi_1.secret(1),
                secret2: pulumi_1.secret(undefined),
                secret3: {
                    "deeply": {
                        "nested": {
                            "secret": pulumi_1.secret("youfoundme"),
                        },
                    },
                },
            };
            // Serialize using the runtime, deserialize (proxying secrets), re-serialize using the policy
            // serialization, and finally deserialize using runtime logic. This should preserve secretness.
            // This mimics the way a policy will work: it sends properties from its space, the policy engine
            // deserializes them, then a remediation can serialize new state, and finally the engine will
            // deserialize that state on its side.
            const runtimeSerialized = gstruct.Struct.fromJavaScript(yield pulumi_1.runtime.serializeProperties("test", inputs));
            console.log(JSON.stringify(yield pulumi_1.runtime.serializeProperties("test", inputs), null, 4));
            const policyDeserializedAndProxied = deserialize_1.deserializeProperties(runtimeSerialized, true);
            assert.equal(policyDeserializedAndProxied.secret1, 1);
            assert.equal(policyDeserializedAndProxied.secret2, undefined);
            assert.deepEqual(policyDeserializedAndProxied.secret3, {
                "deeply": {
                    "nested": {
                        "secret": "youfoundme",
                    },
                },
            });
            const policySerialized = gstruct.Struct.fromJavaScript(yield deserialize_1.serializeProperties(policyDeserializedAndProxied));
            console.log(JSON.stringify(yield deserialize_1.serializeProperties(policyDeserializedAndProxied), null, 4));
            // The final result should include secrets.
            const runtimeDeserialized = pulumi_1.runtime.deserializeProperties(policySerialized);
            console.log(JSON.stringify(runtimeDeserialized, null, 4));
            assert.deepEqual(runtimeDeserialized.secret1, {
                [rpc_1.specialSigKey]: rpc_1.specialSecretSig,
                "value": 1,
            });
            assert.deepEqual(runtimeDeserialized.secret2, {
                [rpc_1.specialSigKey]: rpc_1.specialSecretSig,
                "value": null,
            });
            assert.deepEqual(runtimeDeserialized.secret3, {
                [rpc_1.specialSigKey]: rpc_1.specialSecretSig,
                "value": {
                    "deeply": {
                        "nested": {
                            "secret": "youfoundme",
                        },
                    },
                },
            });
        })));
    });
});
