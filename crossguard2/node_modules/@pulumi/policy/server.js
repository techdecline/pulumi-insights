"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serve = void 0;
const process = require("process");
const grpc = require("@grpc/grpc-js");
const deserialize_1 = require("./deserialize");
const protoutil_1 = require("./protoutil");
const proxy_1 = require("./proxy");
const version_1 = require("./version");
const plugproto = require("@pulumi/pulumi/proto/plugin_pb.js");
const analyzerrpc = require("@pulumi/pulumi/proto/analyzer_grpc_pb.js");
const analyzerproto = require("@pulumi/pulumi/proto/analyzer_pb.js");
// ------------------------------------------------------------------------------------------------
// Analyzer RPC implementation. Receives requests from the engine to validate (or `analyze`)
// resources, and validates them against a set of policies provided by the user. Failures are
// returned with metadata about the policy that was violated.
// ------------------------------------------------------------------------------------------------
// Name of the policy pack currently being served, if applicable.
let servingPolicyPack = undefined;
// Regular expression for the policy pack name.
const packNameRE = "^[a-zA-Z0-9-_.]{1,100}$";
// maxRPCMessageSize raises the gRPC Max Message size from `4194304` (4mb) to `419430400` (400mb)
const maxRPCMessageSize = 1024 * 1024 * 400;
let policyPackConfig = {};
/**
  * Starts the gRPC server to communicate with the Pulumi CLI client for analyzing resources.
  *
  * Only one gRPC server can be running at a time, and the port the server is running on will
  * be written to STDOUT.
  *
  * @param policyPackName Friendly name of the policy pack.
  * @param policyPackVersion Version of the policy pack used.
  * @param policyPackEnforcementLevel Enforcement level of the policy pack.
  * @param policies The policies to be served.
  * @internal
  */
function serve(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies, initialConfig) {
    var _a;
    if (!policyPackName || !policyPackName.match(packNameRE)) {
        console.error(`Invalid policy pack name "${policyPackName}". Policy pack names may only contain alphanumerics, hyphens, underscores, or periods.`);
        process.exit(1);
    }
    for (const policy of (policies || [])) {
        if (policy.name === "all") {
            console.error("Invalid policy name \"all\". \"all\" is a reserved name.");
            process.exit(1);
        }
        if (policy.configSchema) {
            if ((_a = policy.configSchema.properties) === null || _a === void 0 ? void 0 : _a.enforcementLevel) {
                console.error("enforcementLevel cannot be explicitly specified in properties.");
                process.exit(1);
            }
            if (policy.configSchema.required && policy.configSchema.required.includes("enforcementLevel")) {
                console.error("\"enforcementLevel\" cannot be specified in required.");
                process.exit(1);
            }
        }
    }
    if (servingPolicyPack) {
        // We only support running one gRPC instance at a time. (Since the Pulumi CLI is looking for a single
        // PID to be written to STDOUT.) So we just print an error and kill the process if a second policy pack
        // is about to be served.
        console.error(`Already serving policy pack '${servingPolicyPack}'. Only one policy pack may be defined per-process.`);
        process.exit(1);
    }
    servingPolicyPack = policyPackName;
    // Finally connect up the gRPC client/server and listen for incoming requests.
    const server = new grpc.Server({
        "grpc.max_receive_message_length": maxRPCMessageSize,
    });
    server.addService(analyzerrpc.AnalyzerService, {
        analyze: makeAnalyzeRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies),
        analyzeStack: makeAnalyzeStackRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies),
        remediate: makeRemediateRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies),
        getAnalyzerInfo: makeGetAnalyzerInfoRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies, initialConfig),
        getPluginInfo: getPluginInfoRpc,
        configure: configure,
    });
    server.bindAsync("127.0.0.1:0", grpc.ServerCredentials.createInsecure(), (err, port) => {
        if (err) {
            console.error(err);
            process.exit(1);
        }
        // Emit the address so the monitor can read it to connect.  The gRPC server will keep the
        // message loop alive.
        // We explicitly convert the number to a string so that Node doesn't colorize the output.
        console.log(port.toString());
    });
}
exports.serve = serve;
function makeGetAnalyzerInfoRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies, initialConfig) {
    return function (call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                callback(undefined, protoutil_1.makeAnalyzerInfo(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies, initialConfig));
            }
            catch (e) {
                callback(protoutil_1.asGrpcError(e), undefined);
            }
        });
    };
}
function getPluginInfoRpc(call, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const resp = new plugproto.PluginInfo();
            resp.setVersion(version_1.version);
            callback(undefined, resp);
        }
        catch (e) {
            callback(protoutil_1.asGrpcError(e), undefined);
        }
    });
}
function configure(call, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        const req = call.request;
        try {
            const config = {};
            for (const [k, v] of req.getPolicyconfigMap().entries()) {
                const props = v.getProperties().toJavaScript();
                props.enforcementLevel = protoutil_1.convertEnforcementLevel(v.getEnforcementlevel());
                config[k] = props;
            }
            policyPackConfig = config;
            // We need to return an new instance of `Empty` from the "google-protobuf/google/protobuf/empty_pb.js" module,
            // but we can't use `Empty` from the module that this package depends on -- it must be from the module that
            // @pulumi/pulumi depends on, because there is an `arg instanceof google_protobuf_empty_pb.Empty` check that
            // will fail if `Empty` isn't from the same module. To workaround, we can simply use
            // `AnalyzerService.configure.responseType`, which is set to `Empty` in @pulumi/pulumi.
            callback(undefined, new analyzerrpc.AnalyzerService.configure.responseType());
        }
        catch (e) {
            callback(protoutil_1.asGrpcError(e), undefined);
        }
    });
}
// analyze is the RPC call that will analyze an individual resource, one at a time, called with the
// "inputs" to the resource, before it is updated.
function makeAnalyzeRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies) {
    return function (call, callback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Prep to perform the analysis.
            const req = call.request;
            // Run the analysis for every analyzer in the global list, tracking any diagnostics.
            const ds = [];
            try {
                for (const p of policies) {
                    let enforcementLevel = ((_a = policyPackConfig[p.name]) === null || _a === void 0 ? void 0 : _a.enforcementLevel) || p.enforcementLevel || policyPackEnforcementLevel;
                    if (enforcementLevel === "disabled" || !isResourcePolicy(p) || !p.validateResource) {
                        continue;
                    }
                    if (enforcementLevel === "remediate") {
                        // If we ran a remediation, but we are still somehow triggering a violation,
                        // "downgrade" the level we report from remediate to mandatory.
                        enforcementLevel = "mandatory";
                    }
                    const reportViolation = (message, urn) => {
                        let violationMessage = p.description;
                        if (message) {
                            violationMessage += `\n${message}`;
                        }
                        ds.push({
                            policyName: p.name,
                            policyPackName,
                            policyPackVersion,
                            message: violationMessage,
                            urn,
                            description: p.description,
                            enforcementLevel,
                        });
                    };
                    const validations = Array.isArray(p.validateResource)
                        ? p.validateResource
                        : [p.validateResource];
                    for (const validation of validations) {
                        try {
                            const type = req.getType();
                            const deserd = deserialize_1.deserializeProperties(req.getProperties(), false);
                            const props = proxy_1.unknownCheckingProxy(deserd);
                            const args = {
                                type,
                                props,
                                urn: req.getUrn(),
                                name: req.getName(),
                                opts: getResourceOptions(req),
                                isType: function (resourceClass) {
                                    return isTypeOf(type, resourceClass);
                                },
                                asType: function (resourceClass) {
                                    return isTypeOf(type, resourceClass)
                                        ? props
                                        : undefined;
                                },
                                getConfig: makeGetConfigFun(p.name),
                            };
                            const provider = getProviderResource(req);
                            if (provider) {
                                args.provider = provider;
                            }
                            // Pass the result of the validate call to Promise.resolve.
                            // If the value is a promise, that promise is returned; otherwise
                            // the returned promise will be fulfilled with the value.
                            yield Promise.resolve(validation(args, reportViolation));
                        }
                        catch (e) {
                            const policyPack = `'${policyPackName}@v${policyPackVersion}'`;
                            const policyFrom = `policy '${p.name}' from policy pack ${policyPack}`;
                            if (e instanceof proxy_1.UnknownValueError) {
                                const { validateResource, name } = p, diag = __rest(p, ["validateResource", "name"]);
                                ds.push(Object.assign(Object.assign({ policyName: name, policyPackName,
                                    policyPackVersion, message: `can't run ${policyFrom} during preview: ${e.message}` }, diag), { enforcementLevel: "advisory" }));
                            }
                            else {
                                throw protoutil_1.asGrpcError(e, `Error validating resource with ${policyFrom}`);
                            }
                        }
                    }
                }
            }
            catch (err) {
                callback(err, undefined);
                return;
            }
            // Now marshal the results into a resulting diagnostics list, and invoke the callback to finish.
            callback(undefined, protoutil_1.makeAnalyzeResponse(ds));
        });
    };
}
// analyzeStack is the RPC call that will analyze all resources within a stack, at the end of a successful
// preview or update. The provided resources are the "outputs", after any mutations have taken place.
function makeAnalyzeStackRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies) {
    return function (call, callback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Prep to perform the analysis.
            const req = call.request;
            // Run the analysis for every analyzer in the global list, tracking any diagnostics.
            const ds = [];
            try {
                for (const p of policies) {
                    let enforcementLevel = ((_a = policyPackConfig[p.name]) === null || _a === void 0 ? void 0 : _a.enforcementLevel) || p.enforcementLevel || policyPackEnforcementLevel;
                    if (enforcementLevel === "disabled" || !isStackPolicy(p)) {
                        continue;
                    }
                    if (enforcementLevel === "remediate") {
                        // Stack policies cannot be remediated, so treat the level as mandatory.
                        enforcementLevel = "mandatory";
                    }
                    const reportViolation = (message, urn) => {
                        let violationMessage = p.description;
                        if (message) {
                            violationMessage += `\n${message}`;
                        }
                        ds.push({
                            policyName: p.name,
                            policyPackName,
                            policyPackVersion,
                            message: violationMessage,
                            urn,
                            description: p.description,
                            enforcementLevel,
                        });
                    };
                    try {
                        const intermediates = [];
                        for (const r of req.getResourcesList()) {
                            const type = r.getType();
                            const deserd = deserialize_1.deserializeProperties(r.getProperties(), false);
                            const props = proxy_1.unknownCheckingProxy(deserd);
                            const resource = {
                                type,
                                props,
                                urn: r.getUrn(),
                                name: r.getName(),
                                opts: getResourceOptions(r),
                                // We will go back and fill in the dependencies and optional parent.
                                dependencies: [],
                                propertyDependencies: {},
                                isType: function (resourceClass) {
                                    return isTypeOf(type, resourceClass);
                                },
                                asType: function (resourceClass) {
                                    return isTypeOf(type, resourceClass)
                                        ? props
                                        : undefined;
                                },
                            };
                            const provider = getProviderResource(r);
                            if (provider) {
                                resource.provider = provider;
                            }
                            intermediates.push({
                                resource,
                                parent: r.getParent(),
                                dependencies: r.getDependenciesList(),
                                propertyDependencies: getPropertyDependencies(r),
                            });
                        }
                        // Create a map of URNs to resources, used to fill in the parent and dependencies
                        // with references to the actual resource objects.
                        const urnsToResources = new Map();
                        for (const i of intermediates) {
                            urnsToResources.set(i.resource.urn, i.resource);
                        }
                        // Go through each intermediate result and set the parent and dependencies.
                        for (const i of intermediates) {
                            // If the resource has a parent, lookup and set it to the actual resource object.
                            if (i.parent) {
                                const parent = urnsToResources.get(i.parent);
                                if (parent) {
                                    i.resource.parent = parent;
                                }
                            }
                            // Set dependencies to actual resource objects.
                            i.resource.dependencies = i.dependencies
                                .map(d => urnsToResources.get(d))
                                .filter(d => d);
                            // Set propertyDependencies to actual resource objects.
                            for (const k of Object.keys(i.propertyDependencies)) {
                                const v = i.propertyDependencies[k];
                                i.resource.propertyDependencies[k] = v
                                    .map(d => urnsToResources.get(d))
                                    .filter(d => d);
                            }
                        }
                        const args = {
                            resources: intermediates.map(r => r.resource),
                            getConfig: makeGetConfigFun(p.name),
                        };
                        // Pass the result of the validate call to Promise.resolve.
                        // If the value is a promise, that promise is returned; otherwise
                        // the returned promise will be fulfilled with the value.
                        yield Promise.resolve(p.validateStack(args, reportViolation));
                    }
                    catch (e) {
                        const policyPack = `'${policyPackName}@v${policyPackVersion}'`;
                        const policyFrom = `policy '${p.name}' from policy pack ${policyPack}`;
                        if (e instanceof proxy_1.UnknownValueError) {
                            const { validateStack, name } = p, diag = __rest(p, ["validateStack", "name"]);
                            ds.push(Object.assign(Object.assign({ policyName: name, policyPackName,
                                policyPackVersion, message: `can't run ${policyFrom} during preview: ${e.message}` }, diag), { enforcementLevel: "advisory" }));
                        }
                        else {
                            throw protoutil_1.asGrpcError(e, `Error validating resource with ${policyFrom}`);
                        }
                    }
                }
            }
            catch (err) {
                callback(err, undefined);
                return;
            }
            // Now marshal the results into a resulting diagnostics list, and invoke the callback to finish.
            callback(undefined, protoutil_1.makeAnalyzeResponse(ds));
        });
    };
}
// Creates a function for retrieving the configuration for a policy.
function makeGetConfigFun(policyName) {
    return function () {
        // If we don't have config, or don't have config for this policy,
        // return an empty object.
        const c = policyPackConfig[policyName];
        if (!c) {
            return {};
        }
        // Otherwise, return the config properties (except enforcementLevel).
        const { enforcementLevel: ef } = c, properties = __rest(c, ["enforcementLevel"]);
        return properties;
    };
}
// Creates a PolicyResourceOptions object from the GRPC request.
function getResourceOptions(r) {
    const opts = r.getOptions();
    // If the result of `getOptions` is undefined, an older version of the CLI is being used.
    // Provide a nicer error message to the user.
    if (!opts) {
        throw new Error("A more recent version of the Pulumi CLI is required. " +
            "To upgrade, see https://www.pulumi.com/docs/get-started/install/");
    }
    const result = {
        protect: opts.getProtect(),
        ignoreChanges: opts.getIgnorechangesList(),
        aliases: opts.getAliasesList(),
        customTimeouts: getCustomTimeouts(opts),
        additionalSecretOutputs: opts.getAdditionalsecretoutputsList(),
    };
    if (opts.getDeletebeforereplacedefined()) {
        result.deleteBeforeReplace = opts.getDeletebeforereplace();
    }
    return result;
}
// Creates a CustomTimeouts object from the GRPC request.
function getCustomTimeouts(opts) {
    var _a, _b, _c;
    const timeouts = opts.getCustomtimeouts();
    return {
        createSeconds: (_a = timeouts === null || timeouts === void 0 ? void 0 : timeouts.getCreate()) !== null && _a !== void 0 ? _a : 0.0,
        updateSeconds: (_b = timeouts === null || timeouts === void 0 ? void 0 : timeouts.getUpdate()) !== null && _b !== void 0 ? _b : 0.0,
        deleteSeconds: (_c = timeouts === null || timeouts === void 0 ? void 0 : timeouts.getDelete()) !== null && _c !== void 0 ? _c : 0.0,
    };
}
// Creates a PolicyProviderResource object from the GRPC request.
function getProviderResource(r) {
    const prov = r.getProvider();
    if (!prov) {
        return undefined;
    }
    const deserd = deserialize_1.deserializeProperties(prov.getProperties(), false);
    const props = proxy_1.unknownCheckingProxy(deserd);
    return {
        type: prov.getType(),
        props,
        urn: prov.getUrn(),
        name: prov.getName(),
    };
}
// Creates a Record<string, string[]> from the GRPC request.
function getPropertyDependencies(r) {
    const result = {};
    const map = r.getPropertydependenciesMap();
    if (map) {
        for (const [k, v] of map.entries()) {
            const urns = v.getUrnsList();
            result[k] = urns;
        }
    }
    return result;
}
// Type guard used to determine if the `Policy` is a `ResourceValidationPolicy`.
function isResourcePolicy(p) {
    // If the policy has a validate routine, it is a resource policy:
    const validation = p.validateResource;
    if (typeof validation === "function") {
        return true;
    }
    if (Array.isArray(validation)) {
        for (const v of validation) {
            if (typeof v !== "function") {
                return false;
            }
        }
        return true;
    }
    // Alternatively, if the policy has a remediation routine, it is also a resource policy.
    const remediation = p.remediateResource;
    if (typeof remediation === "function") {
        return true;
    }
    return false;
}
// Type guard used to determine if the `Policy` is a `StackValidationPolicy`.
function isStackPolicy(p) {
    return typeof p.validateStack === "function";
}
// Helper to check if `type` is the type of `resourceClass`.
function isTypeOf(type, resourceClass) {
    const isInstance = resourceClass.isInstance;
    return isInstance &&
        typeof isInstance === "function" &&
        isInstance({ __pulumiType: type }) === true;
}
// Remediate is the RPC call that will remediate an individual resource, one at a time, called with the
// "inputs" to the resource, before it is updated.
function makeRemediateRpcFun(policyPackName, policyPackVersion, policyPackEnforcementLevel, policies) {
    return function (call, callback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Prep to perform the analysis.
            const req = call.request;
            // Pluck out all of the values common across all remediations. We need to maintain
            // mutations across many remediations which could affect the same resource.
            const urn = req.getUrn();
            const name = req.getName();
            const type = req.getType();
            const opts = getResourceOptions(req);
            let props = proxy_1.unknownCheckingProxy(deserialize_1.deserializeProperties(req.getProperties(), true));
            // Run any remediations in our policy list.
            const rs = [];
            try {
                for (const p of policies) {
                    // Only run remediations that are enabled.
                    const enforcementLevel = ((_a = policyPackConfig[p.name]) === null || _a === void 0 ? void 0 : _a.enforcementLevel) || p.enforcementLevel || policyPackEnforcementLevel;
                    if (enforcementLevel !== "remediate" || !isResourcePolicy(p) || !p.remediateResource) {
                        continue;
                    }
                    const args = {
                        urn, name, type, opts, props,
                        getConfig: makeGetConfigFun(p.name),
                        isType: function (resourceClass) {
                            return isTypeOf(type, resourceClass);
                        },
                        asType: function (resourceClass) {
                            return isTypeOf(type, resourceClass)
                                ? props
                                : undefined;
                        },
                    };
                    const provider = getProviderResource(req);
                    if (provider) {
                        args.provider = provider;
                    }
                    // Attempt to run the remediation; wrap this in a try block in case the user code throws.
                    let result = undefined;
                    let diagnostic = undefined;
                    try {
                        // Pass the result of the validate call to Promise.resolve.
                        // If the value is a promise, that promise is returned; otherwise
                        // the returned promise will be fulfilled with the value.
                        result = yield Promise.resolve(p.remediateResource(args));
                        if (result) {
                            props = result;
                        }
                    }
                    catch (e) {
                        const policyPack = `'${policyPackName}@v${policyPackVersion}'`;
                        const policyFrom = `remediation '${p.name}' from policy pack ${policyPack}`;
                        if (e instanceof proxy_1.UnknownValueError) {
                            diagnostic = `can't run ${policyFrom} during preview: ${e.message}`;
                        }
                        else {
                            throw protoutil_1.asGrpcError(e, `Error remediating resource with ${policyFrom}`);
                        }
                    }
                    if (result || diagnostic) {
                        // Serialize the result, which translates runtime objects, secrets, and removes proxies.
                        if (result) {
                            result = yield deserialize_1.serializeProperties(result);
                        }
                        rs.push({
                            policyName: p.name,
                            policyPackName,
                            policyPackVersion,
                            description: p.description,
                            properties: result,
                            diagnostic: diagnostic,
                        });
                    }
                }
            }
            catch (err) {
                callback(err, undefined);
                return;
            }
            // Now marshal the results into the response, and invoke the callback to finish.
            callback(undefined, protoutil_1.makeRemediateResponse(rs));
        });
    };
}
